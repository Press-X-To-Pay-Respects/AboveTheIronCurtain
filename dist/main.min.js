(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"./src/js/main.js":[function(require,module,exports){
'use strict';

var game = new Phaser.Game(800, 800, Phaser.AUTO, 'atic-game');

window.playerState = {
    currentLevel: 'Game'
};

game.state.add('Boot', require('./states/boot'));
game.state.add('Splash', require('./states/splash'));
game.state.add('Preloader', require('./states/preloader'));
game.state.add('Menu', require('./states/menu'));
game.state.add('Game', require('./states/game'));

game.state.start('Boot');
},{"./states/boot":"C:\\Users\\mattd_000\\Documents\\GitHub\\AboveTheIronCurtain\\src\\js\\states\\boot.js","./states/game":"C:\\Users\\mattd_000\\Documents\\GitHub\\AboveTheIronCurtain\\src\\js\\states\\game.js","./states/menu":"C:\\Users\\mattd_000\\Documents\\GitHub\\AboveTheIronCurtain\\src\\js\\states\\menu.js","./states/preloader":"C:\\Users\\mattd_000\\Documents\\GitHub\\AboveTheIronCurtain\\src\\js\\states\\preloader.js","./states/splash":"C:\\Users\\mattd_000\\Documents\\GitHub\\AboveTheIronCurtain\\src\\js\\states\\splash.js"}],"C:\\Users\\mattd_000\\Documents\\GitHub\\AboveTheIronCurtain\\src\\js\\entities\\Module.js":[function(require,module,exports){
//Don't use this function to create modules, instead use moduleBuilder()
var Module = function(setCube) {
	this.cube = setCube;
   setCube.module = this;
};

Module.prototype.constructor = Module;

module.exports = Module;
},{}],"C:\\Users\\mattd_000\\Documents\\GitHub\\AboveTheIronCurtain\\src\\js\\entities\\ModuleBuilder.js":[function(require,module,exports){
var Cube = require('./cube');
var Module = require('./Module');

//Use this to create a moduleBuilder- only need to create one instance of it
var ModuleBuilder = function(setGameState) {
	//Ensure that cannot create multiple instances of this class
	if(ModuleBuilder.prototype.exists) {
		return ModuleBuilder.prototype.existingReference;
	}
		
	this.gameState = setGameState;
	this.coreExists = false;	//records if core has been created
	this.core = null;			//stores core when it is created
	ModuleBuilder.prototype.exists = true;
	ModuleBuilder.prototype.existingReference = this;
};

ModuleBuilder.prototype.constructor = ModuleBuilder;

//These var's help create the singleton functionality
ModuleBuilder.prototype.exists = false;
ModuleBuilder.prototype.existingReference = null;

//call this function from ModuleBuilder to construct modules
//TYPES: 'core' 'shield' 'thruster' 'solarPannel'
ModuleBuilder.prototype.build = function(type, x, y) {
	//Check if core has been created
	if(type === 'core' && this.coreExists) {
		//if so, return existing core b/c is singleton
		//b/c of this, can call ModuleBuilder.build('core') to access reference to existing core
		return this.core;
	}
	
	//Create cube object to be stored within module
	//Sprite names for modules are directly mapped to module names, so just pass 'type' as sprite name
	var newCube = new Cube(this.gameState.game, x, y, type);
    var scale = 0.5;
    newCube.name = this.gameState.debugNum++;
    newCube.scale.x = scale;
    newCube.scale.y = scale;
    newCube.anchor.setTo(0.5, 0.5);
    this.gameState.game.physics.p2.enable(newCube);
    newCube.body.onBeginContact.add(newCube.cubeCollide, newCube);
    newCube.body.damping = 0.9;
    newCube.body.angularDamping = 0.9;
    if (!this.gameState.rootSpawned) {
       newCube.root = true;
       this.gameState.rootSpawned = true;
    }
	
	//Create module to wrap around cube class
	var newModule = new Module(newCube);
		
	//TODO: edit special module atributes based on 'type'
	
	//Store module if it is core
	if(type === 'core')
	{
		this.core = newModule;
		this.coreExists = true;
	}
   // solar panel testing
   if (type === 'solarPannel') {
      newModule.cube.runAstar();
   }
	
	//Return the module object
	return newModule;
};


module.exports = ModuleBuilder;
},{"./Module":"C:\\Users\\mattd_000\\Documents\\GitHub\\AboveTheIronCurtain\\src\\js\\entities\\Module.js","./cube":"C:\\Users\\mattd_000\\Documents\\GitHub\\AboveTheIronCurtain\\src\\js\\entities\\cube.js"}],"C:\\Users\\mattd_000\\Documents\\GitHub\\AboveTheIronCurtain\\src\\js\\entities\\cube.js":[function(require,module,exports){
/*
Defines a cube.
*/

var Astar = require('../libs/javascript-astar/astar');

var Cube = function (game, x, y, sprite) {
    Phaser.Sprite.call(this, game, x, y, sprite);
    game.add.existing(this);
    this.group = undefined;
    this.module = undefined;
};

Cube.prototype = Object.create(Phaser.Sprite.prototype);
Cube.prototype.constructor = Cube;

/**
 * Automatically called by World.update
 */
Cube.prototype.update = function() {
};

Cube.prototype.cubeCollide = function(other) {
   if (this.group === undefined) {
      return;
   }
   this.group.handleCollision(this, other.sprite);
};

Cube.prototype.toString = function() {
   var string = '';
   string += this.concat('name', this.name);
   return string;
};

Cube.prototype.concat = function(string, val) {
   return string + ': ' + val + '\n';
};

Cube.prototype.runAstar = function() {
   var graph = new Astar.Graph([
        [1,1,1,1],
        [0,1,1,0],
        [0,0,1,1]
    ]);
    var start = graph.grid[0][0];
    var end = graph.grid[1][2];
    var result = Astar.astar.search(graph, start, end);
    for(var i = 0; i < result.length; i++) {
       console.log(result[i].x, result[i].y);
    }
};

module.exports = Cube;















},{"../libs/javascript-astar/astar":"C:\\Users\\mattd_000\\Documents\\GitHub\\AboveTheIronCurtain\\src\\js\\libs\\javascript-astar\\astar.js"}],"C:\\Users\\mattd_000\\Documents\\GitHub\\AboveTheIronCurtain\\src\\js\\entities\\cube_group.js":[function(require,module,exports){
/*
Defines a cube group.
*/

var CubeGroup = function (game, root) {
   this.game = game;
   this.root = root;
   this.cubes = [];
   var col = [];
   col.push(this.root);
   this.cubes.push(col);
   this.root.group = this;
   this.DIR = {NORTH: 0, EAST: 1, SOUTH: 2, WEST: 3};
   this.offset = 2;
};

CubeGroup.prototype.constructor = CubeGroup;

/**
 * Automatically called by World.update
 */
CubeGroup.prototype.update = function() {
};

CubeGroup.prototype.add = function(cube) {
  cube.group = this; 
};

CubeGroup.prototype.handleCollision = function(origin, other) {
   // stop if other does not exist, either is not a cube, both are in same group
   if (other === null || origin.prototype !== other.prototype || origin.group === other.group) {
      return;
   }
   var relSide = this.relativeSide(origin.body, other.body);
   var originLoc = this.find(origin);
   var otherLoc = this.adjust(originLoc, relSide);
   if (this.getCube(otherLoc)) {
      return;
   }
   switch (relSide) {
      case this.DIR.NORTH:
      if (originLoc.y === this.cubesHeight() - 1) {
         this.addTopRow();
      }
      break;
      case this.DIR.EAST:
      if (originLoc.x === this.cubesWidth() - 1) {
         this.addRightCol();
      }
      break;
      case this.DIR.SOUTH:
      if (originLoc.y === 0) {
         this.addBotRow();
      }
      break;
      case this.DIR.WEST:
      if (originLoc.x === 0) {
         this.addLeftCol();
      }
      break;
   }
   originLoc = this.find(origin);
   otherLoc = this.adjust(originLoc, relSide);
   this.createConstraints(otherLoc, other);
   if (!otherLoc) {
      console.log('hande collision failed to find second other loc');
      return;
   }
   this.set(otherLoc, other);
   other.group = this;
};

CubeGroup.prototype.createConstraints = function(loc, me) {
   var myNorth = this.get(this.adjust(loc, this.DIR.NORTH));
   var myEast = this.get(this.adjust(loc, this.DIR.EAST));
   var mySouth = this.get(this.adjust(loc, this.DIR.SOUTH));
   var myWest = this.get(this.adjust(loc, this.DIR.WEST));
   if (myNorth) {
      this.game.physics.p2.createLockConstraint(me.body, myNorth.body, [0, me.width + this.offset]); // me - north
   }
   if (myEast) {
      this.game.physics.p2.createLockConstraint(me.body, myEast.body, [-me.width - this.offset, 0]); // me - east
   }
   if (mySouth) {
      this.game.physics.p2.createLockConstraint(mySouth.body, me.body, [0, me.width + this.offset]); // south - me
   }
   if (myWest) {
      this.game.physics.p2.createLockConstraint(myWest.body, me.body, [-me.width - this.offset, 0]); // west - me
   }
};

CubeGroup.prototype.relativeSide = function(thisBody, otherBody) {
  var thisPoint = new Phaser.Point(thisBody.x, thisBody.y);
  var otherPoint = new Phaser.Point(otherBody.x, otherBody.y);
  var angleToOther = Phaser.Point.angle(thisPoint, otherPoint);
  if (angleToOther < 0) { // fix dumb part of Phaser.Point.angle()
     angleToOther = 2 * Math.PI + angleToOther;
  }
  angleToOther = (angleToOther + 3/2 * Math.PI) % (2 * Math.PI); // rotate 90 d clockwise
  var diffAngle = angleToOther - thisBody.rotation;
   if (diffAngle < 1 / 4 * Math.PI || diffAngle > 7 / 4 * Math.PI) { // north
     return this.DIR.NORTH;
  } else if (diffAngle >= 1 / 4 * Math.PI && diffAngle < 3 / 4 * Math.PI) { // east
     return this.DIR.EAST;
  } else if (diffAngle >= 3 / 4 * Math.PI && diffAngle < 5 / 4 * Math.PI) { // south
     return this.DIR.SOUTH;
  } else if (diffAngle >= 5 / 4 * Math.PI && diffAngle < 7 / 4 * Math.PI) { // west
     return this.DIR.WEST;
  }
};

CubeGroup.prototype.find = function(cube) {
   for (var row = 0; row < this.cubesWidth(); row++) {
      for (var col = 0; col < this.cubesHeight(); col++) {
         if (this.cubes[row][col] === cube) {
            return new Phaser.Point(row, col);
         }
      }
   }
   return undefined;
};

CubeGroup.prototype.get = function(point) {
  if (!point || this.outOfBounds(point)) {
      return;
  }
  return this.cubes[point.x][point.y];
};

CubeGroup.prototype.cubesWidth = function() {
   return this.cubes.length;
};

CubeGroup.prototype.cubesHeight = function() {
   return this.cubes[0].length;
};

/*
[0,height] ...  [width, height]
.                 
.               .
.               .
[0,1] [1,1] ... .
[0,0] [1,0] ... [width,0]
*/
CubeGroup.prototype.addTopRow = function() {
   for (var row = 0; row < this.cubesWidth(); row++) {
      this.cubes[row].push(undefined);
   }
};

CubeGroup.prototype.addRightCol = function() {
   var newCol = new Array(this.cubesHeight);
   this.cubes.push(newCol);
};

CubeGroup.prototype.addBotRow = function() {
   for (var row = 0; row < this.cubesWidth(); row++) {
      this.cubes[row].unshift(undefined);
   }
};

CubeGroup.prototype.addLeftCol = function() {
   var newCol = new Array(this.cubesHeight());
   this.cubes.unshift(newCol);
};

CubeGroup.prototype.getCube = function(point) {
   if (!point || this.outOfBounds(point)) {
      return undefined;
   }
   return this.cubes[point.x][point.y];
};

CubeGroup.prototype.adjust = function(point, dir) {
  if (!point) {
     console.log('adjust given undefined point');
     return;
  }
  var newPoint = new Phaser.Point(point.x, point.y);
  switch (dir) {
      case this.DIR.NORTH:
      newPoint.y++;
      break;
      case this.DIR.EAST:
      newPoint.x++;
      break;
      case this.DIR.SOUTH:
      newPoint.y--;
      break;
      case this.DIR.WEST:
      newPoint.x--;
      break;
   }
   return newPoint;
};

CubeGroup.prototype.set = function(point, cube) {
   if (!point) {
      console.log('set given undefined point');
      return;
   }
   if (this.outOfBounds(point)) {
      return;
   }
   this.cubes[point.x][point.y] = cube;
};

CubeGroup.prototype.outOfBounds = function(point) {
   if (!point) {
      console.log('out of bounds given undefined point');
      return;
   }
   if (point.x < 0 || point.x >= this.cubesWidth() || point.y < 0 || point.y >= this.cubesHeight()) {
      return true;
   }
   return false;
};

CubeGroup.prototype.displayCubes = function() {
   for (var row = 0; row < this.cubesWidth(); row++) {
      var string = '';
      for (var col = 0; col < this.cubesHeight(); col++) {
         var cube = this.cubes[row][col];
         if (cube) {
            string += '# ';
         } else {
            string += '_ ';
         }
      }
      console.log('row ' + row + ': ' + string + '| ' + this.cubes[row].length);
   }
};

module.exports = CubeGroup;

















},{}],"C:\\Users\\mattd_000\\Documents\\GitHub\\AboveTheIronCurtain\\src\\js\\libs\\javascript-astar\\astar.js":[function(require,module,exports){
// javascript-astar 0.4.0
// http://github.com/bgrins/javascript-astar
// Freely distributable under the MIT License.
// Implements the astar search algorithm in javascript using a Binary Heap.
// Includes Binary Heap (with modifications) from Marijn Haverbeke.
// http://eloquentjavascript.net/appendix2.html

(function(definition) {
    /* global module, define */
    if(typeof module === 'object' && typeof module.exports === 'object') {
        module.exports = definition();
    } else if(typeof define === 'function' && define.amd) {
        define([], definition);
    } else {
        var exports = definition();
        window.astar = exports.astar;
        window.Graph = exports.Graph;
    }
})(function() {

function pathTo(node){
    var curr = node,
        path = [];
    while(curr.parent) {
        path.push(curr);
        curr = curr.parent;
    }
    return path.reverse();
}

function getHeap() {
    return new BinaryHeap(function(node) {
        return node.f;
    });
}

var astar = {
    /**
    * Perform an A* Search on a graph given a start and end node.
    * @param {Graph} graph
    * @param {GridNode} start
    * @param {GridNode} end
    * @param {Object} [options]
    * @param {bool} [options.closest] Specifies whether to return the
               path to the closest node if the target is unreachable.
    * @param {Function} [options.heuristic] Heuristic function (see
    *          astar.heuristics).
    */
    search: function(graph, start, end, options) {
        graph.cleanDirty();
        options = options || {};
        var heuristic = options.heuristic || astar.heuristics.manhattan,
            closest = options.closest || false;

        var openHeap = getHeap(),
            closestNode = start; // set the start node to be the closest if required

        start.h = heuristic(start, end);

        openHeap.push(start);

        while(openHeap.size() > 0) {

            // Grab the lowest f(x) to process next.  Heap keeps this sorted for us.
            var currentNode = openHeap.pop();

            // End case -- result has been found, return the traced path.
            if(currentNode === end) {
                return pathTo(currentNode);
            }

            // Normal case -- move currentNode from open to closed, process each of its neighbors.
            currentNode.closed = true;

            // Find all neighbors for the current node.
            var neighbors = graph.neighbors(currentNode);

            for (var i = 0, il = neighbors.length; i < il; ++i) {
                var neighbor = neighbors[i];

                if (neighbor.closed || neighbor.isWall()) {
                    // Not a valid node to process, skip to next neighbor.
                    continue;
                }

                // The g score is the shortest distance from start to current node.
                // We need to check if the path we have arrived at this neighbor is the shortest one we have seen yet.
                var gScore = currentNode.g + neighbor.getCost(currentNode),
                    beenVisited = neighbor.visited;

                if (!beenVisited || gScore < neighbor.g) {

                    // Found an optimal (so far) path to this node.  Take score for node to see how good it is.
                    neighbor.visited = true;
                    neighbor.parent = currentNode;
                    neighbor.h = neighbor.h || heuristic(neighbor, end);
                    neighbor.g = gScore;
                    neighbor.f = neighbor.g + neighbor.h;
                    graph.markDirty(neighbor);
                    if (closest) {
                        // If the neighbour is closer than the current closestNode or if it's equally close but has
                        // a cheaper path than the current closest node then it becomes the closest node
                        if (neighbor.h < closestNode.h || (neighbor.h === closestNode.h && neighbor.g < closestNode.g)) {
                            closestNode = neighbor;
                        }
                    }

                    if (!beenVisited) {
                        // Pushing to heap will put it in proper place based on the 'f' value.
                        openHeap.push(neighbor);
                    }
                    else {
                        // Already seen the node, but since it has been rescored we need to reorder it in the heap
                        openHeap.rescoreElement(neighbor);
                    }
                }
            }
        }

        if (closest) {
            return pathTo(closestNode);
        }

        // No result was found - empty array signifies failure to find path.
        return [];
    },
    // See list of heuristics: http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html
    heuristics: {
        manhattan: function(pos0, pos1) {
            var d1 = Math.abs(pos1.x - pos0.x);
            var d2 = Math.abs(pos1.y - pos0.y);
            return d1 + d2;
        },
        diagonal: function(pos0, pos1) {
            var D = 1;
            var D2 = Math.sqrt(2);
            var d1 = Math.abs(pos1.x - pos0.x);
            var d2 = Math.abs(pos1.y - pos0.y);
            return (D * (d1 + d2)) + ((D2 - (2 * D)) * Math.min(d1, d2));
        }
    },
    cleanNode:function(node){
        node.f = 0;
        node.g = 0;
        node.h = 0;
        node.visited = false;
        node.closed = false;
        node.parent = null;
    }
};

/**
* A graph memory structure
* @param {Array} gridIn 2D array of input weights
* @param {Object} [options]
* @param {bool} [options.diagonal] Specifies whether diagonal moves are allowed
*/
function Graph(gridIn, options) {
    options = options || {};
    this.nodes = [];
    this.diagonal = !!options.diagonal;
    this.grid = [];
    for (var x = 0; x < gridIn.length; x++) {
        this.grid[x] = [];

        for (var y = 0, row = gridIn[x]; y < row.length; y++) {
            var node = new GridNode(x, y, row[y]);
            this.grid[x][y] = node;
            this.nodes.push(node);
        }
    }
    this.init();
}

Graph.prototype.init = function() {
    this.dirtyNodes = [];
    for (var i = 0; i < this.nodes.length; i++) {
        astar.cleanNode(this.nodes[i]);
    }
};

Graph.prototype.cleanDirty = function() {
    for (var i = 0; i < this.dirtyNodes.length; i++) {
        astar.cleanNode(this.dirtyNodes[i]);
    }
    this.dirtyNodes = [];
};

Graph.prototype.markDirty = function(node) {
    this.dirtyNodes.push(node);
};

Graph.prototype.neighbors = function(node) {
    var ret = [],
        x = node.x,
        y = node.y,
        grid = this.grid;

    // West
    if(grid[x-1] && grid[x-1][y]) {
        ret.push(grid[x-1][y]);
    }

    // East
    if(grid[x+1] && grid[x+1][y]) {
        ret.push(grid[x+1][y]);
    }

    // South
    if(grid[x] && grid[x][y-1]) {
        ret.push(grid[x][y-1]);
    }

    // North
    if(grid[x] && grid[x][y+1]) {
        ret.push(grid[x][y+1]);
    }

    if (this.diagonal) {
        // Southwest
        if(grid[x-1] && grid[x-1][y-1]) {
            ret.push(grid[x-1][y-1]);
        }

        // Southeast
        if(grid[x+1] && grid[x+1][y-1]) {
            ret.push(grid[x+1][y-1]);
        }

        // Northwest
        if(grid[x-1] && grid[x-1][y+1]) {
            ret.push(grid[x-1][y+1]);
        }

        // Northeast
        if(grid[x+1] && grid[x+1][y+1]) {
            ret.push(grid[x+1][y+1]);
        }
    }

    return ret;
};

Graph.prototype.toString = function() {
    var graphString = [],
        nodes = this.grid, // when using grid
        rowDebug, row, y, l;
    for (var x = 0, len = nodes.length; x < len; x++) {
        rowDebug = [];
        row = nodes[x];
        for (y = 0, l = row.length; y < l; y++) {
            rowDebug.push(row[y].weight);
        }
        graphString.push(rowDebug.join(' '));
    }
    return graphString.join('\n');
};

function GridNode(x, y, weight) {
    this.x = x;
    this.y = y;
    this.weight = weight;
}

GridNode.prototype.toString = function() {
    return '[' + this.x + ' ' + this.y + ']';
};

GridNode.prototype.getCost = function(fromNeighbor) {
    // Take diagonal weight into consideration.
    if (fromNeighbor && fromNeighbor.x !== this.x && fromNeighbor.y !== this.y) {
        return this.weight * 1.41421;
    }
    return this.weight;
};

GridNode.prototype.isWall = function() {
    return this.weight === 0;
};

function BinaryHeap(scoreFunction){
    this.content = [];
    this.scoreFunction = scoreFunction;
}

BinaryHeap.prototype = {
    push: function(element) {
        // Add the new element to the end of the array.
        this.content.push(element);

        // Allow it to sink down.
        this.sinkDown(this.content.length - 1);
    },
    pop: function() {
        // Store the first element so we can return it later.
        var result = this.content[0];
        // Get the element at the end of the array.
        var end = this.content.pop();
        // If there are any elements left, put the end element at the
        // start, and let it bubble up.
        if (this.content.length > 0) {
            this.content[0] = end;
            this.bubbleUp(0);
        }
        return result;
    },
    remove: function(node) {
        var i = this.content.indexOf(node);

        // When it is found, the process seen in 'pop' is repeated
        // to fill up the hole.
        var end = this.content.pop();

        if (i !== this.content.length - 1) {
            this.content[i] = end;

            if (this.scoreFunction(end) < this.scoreFunction(node)) {
                this.sinkDown(i);
            }
            else {
                this.bubbleUp(i);
            }
        }
    },
    size: function() {
        return this.content.length;
    },
    rescoreElement: function(node) {
        this.sinkDown(this.content.indexOf(node));
    },
    sinkDown: function(n) {
        // Fetch the element that has to be sunk.
        var element = this.content[n];

        // When at 0, an element can not sink any further.
        while (n > 0) {

            // Compute the parent element's index, and fetch it.
            var parentN = ((n + 1) >> 1) - 1,
                parent = this.content[parentN];
            // Swap the elements if the parent is greater.
            if (this.scoreFunction(element) < this.scoreFunction(parent)) {
                this.content[parentN] = element;
                this.content[n] = parent;
                // Update 'n' to continue at the new position.
                n = parentN;
            }
            // Found a parent that is less, no need to sink any further.
            else {
                break;
            }
        }
    },
    bubbleUp: function(n) {
        // Look up the target element and its score.
        var length = this.content.length,
            element = this.content[n],
            elemScore = this.scoreFunction(element);

        while(true) {
            // Compute the indices of the child elements.
            var child2N = (n + 1) << 1,
                child1N = child2N - 1;
            // This is used to store the new position of the element, if any.
            var swap = null,
                child1Score;
            // If the first child exists (is inside the array)...
            if (child1N < length) {
                // Look it up and compute its score.
                var child1 = this.content[child1N];
                child1Score = this.scoreFunction(child1);

                // If the score is less than our element's, we need to swap.
                if (child1Score < elemScore){
                    swap = child1N;
                }
            }

            // Do the same checks for the other child.
            if (child2N < length) {
                var child2 = this.content[child2N],
                    child2Score = this.scoreFunction(child2);
                if (child2Score < (swap === null ? elemScore : child1Score)) {
                    swap = child2N;
                }
            }

            // If the element needs to be moved, swap it, and continue.
            if (swap !== null) {
                this.content[n] = this.content[swap];
                this.content[swap] = element;
                n = swap;
            }
            // Otherwise, we are done.
            else {
                break;
            }
        }
    }
};

return {
    astar: astar,
    Graph: Graph
};

});

},{}],"C:\\Users\\mattd_000\\Documents\\GitHub\\AboveTheIronCurtain\\src\\js\\states\\boot.js":[function(require,module,exports){
var Boot = function () {};

module.exports = Boot;

Boot.prototype = {

  preload: function () {
    this.load.image('preloader', 'assets/preloader.gif');
  },

  create: function () {
    this.game.input.maxPointers = 1;

    if (this.game.device.desktop) {
      this.game.stage.scale.pageAlignHorizontally = true;
    } else {
      this.game.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL;
      this.game.scale.minWidth =  480;
      this.game.scale.minHeight = 260;
      this.game.scale.maxWidth = 640;
      this.game.scale.maxHeight = 480;
      this.game.scale.forceLandscape = true;
      this.game.scale.pageAlignHorizontally = true;
      this.game.scale.setScreenSize(true);
    }

    this.game.state.start('Preloader');
  }
};

},{}],"C:\\Users\\mattd_000\\Documents\\GitHub\\AboveTheIronCurtain\\src\\js\\states\\game.js":[function(require,module,exports){
/*
Main testing environment.
*/

var ModuleBuilder = require('../entities/ModuleBuilder');
var Cube = require('../entities/cube');
var ModuleBuilder = require('../entities/ModuleBuilder');
var Utils = require('../utils');
var CubeGroup = require('../entities/cube_group');

var mouseBody; // physics body for mouse

var Game = function () {
  this.testentity = null;
};

module.exports = Game;

Game.prototype = {
	
  create: function () {
    this.game.physics.startSystem(Phaser.Physics.P2JS);
    this.game.physics.p2.setImpactEvents(true);
    mouseBody = new p2.Body(); // jshint ignore:line
    this.game.physics.p2.world.addBody(mouseBody);
    
	//create ModuleBuilder and store it in this game state object
	this.moduleBuilder = new ModuleBuilder(this);
	//create and store the core module
	this.coreModule = this.moduleBuilder.build('core', 200, 200);
   this.player = new CubeGroup(this, this.coreModule.cube);
   
	
	//DEBUGGING LISTENERS- allow you to create modules by pressing keys
	//core
	this.placeCoreKey = this.game.input.keyboard.addKey(Phaser.Keyboard.P);
   this.placeCoreKey.onDown.add(this.addCore, this);
	//shield
	this.placeShieldKey = this.game.input.keyboard.addKey(Phaser.Keyboard.O);
    this.placeShieldKey.onDown.add(this.addShield, this);
	//thruster
	this.placeThrusterKey = this.game.input.keyboard.addKey(Phaser.Keyboard.I);
    this.placeThrusterKey.onDown.add(this.addThruster, this);
	//solarPannel
	this.placeSPKey = this.game.input.keyboard.addKey(Phaser.Keyboard.U);
    this.placeSPKey.onDown.add(this.addSP, this);
	//END
    
    this.mouseX = 0;
    this.mouseY = 0;
    
    this.input.onDown.add(this.click, this);
    this.input.onUp.add(this.release, this);
    this.input.addMoveCallback(this.move, this);
    this.grabbed = undefined;
    this.line = new Phaser.Line(0, 0, 0, 0);
    
    this.rootSpawned = false;
    
    this.debugNum = 0;
    this.myRoot = undefined;
  },

  update: function () {
    if (this.grabbed) {
      var angle = Math.atan2(this.grabbed.sprite.y - this.input.position.y, this.grabbed.sprite.x - this.input.position.x) + Math.PI;
      var dist = Utils.distance(this.grabbed.sprite.x, this.grabbed.sprite.y, this.input.position.x, this.input.position.y);
      var weight = 10;
      this.grabbed.force.x = Math.cos(angle) * dist * weight;
      this.grabbed.force.y = Math.sin(angle) * dist * weight;
      this.line.setTo(this.grabbed.sprite.x, this.grabbed.sprite.y, this.input.position.x, this.input.position.y);
    } else {
       this.line.setTo(0, 0, 0, 0);
    }
  },
  
  render: function () {
    this.game.debug.geom(this.line);
  },

  click: function (pointer) {
    var bodies = this.game.physics.p2.hitTest(pointer.position);
    if (bodies.length)
    {
        this.grabbed = bodies[0].parent;
    }
  },
  
  release: function () {
     if (this.grabbed) {
        this.grabbed = undefined;
     }
  },
  
  move: function (pointer) {
    // p2 uses different coordinate system, so convert the pointer position to p2's coordinate system
    mouseBody.position[0] = this.game.physics.p2.pxmi(pointer.position.x);
    mouseBody.position[1] = this.game.physics.p2.pxmi(pointer.position.y);
    this.mouseX = pointer.position.x;
    this.mouseY = pointer.position.y;
  },
  
  //DEBUG FUNCTIONS- event functions called from listeners that allow you to create modules with key presses
  addCore: function () {
	//Attempts to create more core modules here will only return the existing core
	this.moduleBuilder.build('core', this.mouseX, this.mouseY);
  },
  addShield: function () {
	this.moduleBuilder.build('shield', this.mouseX, this.mouseY);
  },
  addThruster: function () {
	this.moduleBuilder.build('thruster', this.mouseX, this.mouseY);
  },
  addSP: function () {
	this.moduleBuilder.build('solarPannel', this.mouseX, this.mouseY);
  },
  placeCube: function () {
    var entity = new Cube(this.game, this.mouseX, this.mouseY);
    var scale = 0.5;
    entity.name = this.debugNum++;
    entity.scale.x = scale;
    entity.scale.y = scale;
    entity.anchor.setTo(0.5, 0.5);
    this.game.physics.p2.enable(entity);
    entity.body.onBeginContact.add(entity.cubeCollide, entity);
    entity.body.damping = 0.9;
    entity.body.angularDamping = 0.9;
    if (!this.rootSpawned) {
       entity.root = true;
       this.rootSpawned = true;
    }
  }
};




























},{"../entities/ModuleBuilder":"C:\\Users\\mattd_000\\Documents\\GitHub\\AboveTheIronCurtain\\src\\js\\entities\\ModuleBuilder.js","../entities/cube":"C:\\Users\\mattd_000\\Documents\\GitHub\\AboveTheIronCurtain\\src\\js\\entities\\cube.js","../entities/cube_group":"C:\\Users\\mattd_000\\Documents\\GitHub\\AboveTheIronCurtain\\src\\js\\entities\\cube_group.js","../utils":"C:\\Users\\mattd_000\\Documents\\GitHub\\AboveTheIronCurtain\\src\\js\\utils.js"}],"C:\\Users\\mattd_000\\Documents\\GitHub\\AboveTheIronCurtain\\src\\js\\states\\menu.js":[function(require,module,exports){
var Menu = function () {
  this.text = null;
};

module.exports = Menu;

Menu.prototype = {

  create: function () {
    var x = this.game.width / 2;
    var y = this.game.height / 2;

    var style = { font: '65px Arial', fill: '#ffffff', align: 'center' };

    this.text = this.add.text(x - 300, y - 200, 'Press to Start', style);

    this.input.onDown.add(this.onDown, this);
  },

  update: function () {
  },

  onDown: function () {
    this.game.state.start(playerState.currentLevel); // jshint ignore:line
  }
};

},{}],"C:\\Users\\mattd_000\\Documents\\GitHub\\AboveTheIronCurtain\\src\\js\\states\\preloader.js":[function(require,module,exports){
var Preloader = function (game) {
  game = null;
  this.asset = null;
  this.ready = false;
};

module.exports = Preloader;

Preloader.prototype = {

  preload: function () {
    this.asset = this.add.sprite(320, 240, 'preloader');
    this.asset.anchor.setTo(0.5, 0.5);

    this.load.onLoadComplete.addOnce(this.onLoadComplete, this);
    this.load.setPreloadSprite(this.asset);
    this.load.image('testsprite', 'assets/test2.png');
	this.load.image('core', 'assets/core.png');
	this.load.image('thruster', 'assets/thruster.png');
	this.load.image('shield', 'assets/shield.png');
	this.load.image('solarPannel', 'assets/solarPannel.png');
	
    this.load.physics('module_physics', 'assets/module_physics.json');
  },

  create: function () {
    this.asset.cropEnabled = false;
  },

  update: function () {
    if (!!this.ready) {
      // this.game.state.start('Menu');
      this.game.state.start(playerState.currentLevel); // jshint ignore:line
    }
  },

  onLoadComplete: function () {
    this.ready = true;
  }
};

},{}],"C:\\Users\\mattd_000\\Documents\\GitHub\\AboveTheIronCurtain\\src\\js\\states\\splash.js":[function(require,module,exports){
var Splash = function () {
};

module.exports = Splash;

Splash.prototype = {
  create: function () {
  }
};
},{}],"C:\\Users\\mattd_000\\Documents\\GitHub\\AboveTheIronCurtain\\src\\js\\utils.js":[function(require,module,exports){
/*
Collection of utility functions.
*/

var Utils = {
    containsObject: function(obj, list) {
        var i;
        for (i = 0; i < list.length; i++) {
            if (list[i] === obj) {
                return true;
            }
        }

        return false;
    },
    distance: function(x1, y1, x2, y2) {
       return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
    }
};

module.exports = Utils;
},{}]},{},["./src/js/main.js"])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlc1xcYnJvd3NlcmlmeVxcbm9kZV9tb2R1bGVzXFxicm93c2VyLXBhY2tcXF9wcmVsdWRlLmpzIiwic3JjL2pzL21haW4uanMiLCJzcmMvanMvZW50aXRpZXMvTW9kdWxlLmpzIiwic3JjL2pzL2VudGl0aWVzL01vZHVsZUJ1aWxkZXIuanMiLCJzcmMvanMvZW50aXRpZXMvY3ViZS5qcyIsInNyYy9qcy9lbnRpdGllcy9jdWJlX2dyb3VwLmpzIiwic3JjL2pzL2xpYnMvamF2YXNjcmlwdC1hc3Rhci9hc3Rhci5qcyIsInNyYy9qcy9zdGF0ZXMvYm9vdC5qcyIsInNyYy9qcy9zdGF0ZXMvZ2FtZS5qcyIsInNyYy9qcy9zdGF0ZXMvbWVudS5qcyIsInNyYy9qcy9zdGF0ZXMvcHJlbG9hZGVyLmpzIiwic3JjL2pzL3N0YXRlcy9zcGxhc2guanMiLCJzcmMvanMvdXRpbHMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2WkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGdhbWUgPSBuZXcgUGhhc2VyLkdhbWUoODAwLCA4MDAsIFBoYXNlci5BVVRPLCAnYXRpYy1nYW1lJyk7XHJcblxyXG53aW5kb3cucGxheWVyU3RhdGUgPSB7XHJcbiAgICBjdXJyZW50TGV2ZWw6ICdHYW1lJ1xyXG59O1xyXG5cclxuZ2FtZS5zdGF0ZS5hZGQoJ0Jvb3QnLCByZXF1aXJlKCcuL3N0YXRlcy9ib290JykpO1xyXG5nYW1lLnN0YXRlLmFkZCgnU3BsYXNoJywgcmVxdWlyZSgnLi9zdGF0ZXMvc3BsYXNoJykpO1xyXG5nYW1lLnN0YXRlLmFkZCgnUHJlbG9hZGVyJywgcmVxdWlyZSgnLi9zdGF0ZXMvcHJlbG9hZGVyJykpO1xyXG5nYW1lLnN0YXRlLmFkZCgnTWVudScsIHJlcXVpcmUoJy4vc3RhdGVzL21lbnUnKSk7XHJcbmdhbWUuc3RhdGUuYWRkKCdHYW1lJywgcmVxdWlyZSgnLi9zdGF0ZXMvZ2FtZScpKTtcclxuXHJcbmdhbWUuc3RhdGUuc3RhcnQoJ0Jvb3QnKTsiLCIvL0Rvbid0IHVzZSB0aGlzIGZ1bmN0aW9uIHRvIGNyZWF0ZSBtb2R1bGVzLCBpbnN0ZWFkIHVzZSBtb2R1bGVCdWlsZGVyKClcclxudmFyIE1vZHVsZSA9IGZ1bmN0aW9uKHNldEN1YmUpIHtcclxuXHR0aGlzLmN1YmUgPSBzZXRDdWJlO1xyXG4gICBzZXRDdWJlLm1vZHVsZSA9IHRoaXM7XHJcbn07XHJcblxyXG5Nb2R1bGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTW9kdWxlO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBNb2R1bGU7IiwidmFyIEN1YmUgPSByZXF1aXJlKCcuL2N1YmUnKTtcclxudmFyIE1vZHVsZSA9IHJlcXVpcmUoJy4vTW9kdWxlJyk7XHJcblxyXG4vL1VzZSB0aGlzIHRvIGNyZWF0ZSBhIG1vZHVsZUJ1aWxkZXItIG9ubHkgbmVlZCB0byBjcmVhdGUgb25lIGluc3RhbmNlIG9mIGl0XHJcbnZhciBNb2R1bGVCdWlsZGVyID0gZnVuY3Rpb24oc2V0R2FtZVN0YXRlKSB7XHJcblx0Ly9FbnN1cmUgdGhhdCBjYW5ub3QgY3JlYXRlIG11bHRpcGxlIGluc3RhbmNlcyBvZiB0aGlzIGNsYXNzXHJcblx0aWYoTW9kdWxlQnVpbGRlci5wcm90b3R5cGUuZXhpc3RzKSB7XHJcblx0XHRyZXR1cm4gTW9kdWxlQnVpbGRlci5wcm90b3R5cGUuZXhpc3RpbmdSZWZlcmVuY2U7XHJcblx0fVxyXG5cdFx0XHJcblx0dGhpcy5nYW1lU3RhdGUgPSBzZXRHYW1lU3RhdGU7XHJcblx0dGhpcy5jb3JlRXhpc3RzID0gZmFsc2U7XHQvL3JlY29yZHMgaWYgY29yZSBoYXMgYmVlbiBjcmVhdGVkXHJcblx0dGhpcy5jb3JlID0gbnVsbDtcdFx0XHQvL3N0b3JlcyBjb3JlIHdoZW4gaXQgaXMgY3JlYXRlZFxyXG5cdE1vZHVsZUJ1aWxkZXIucHJvdG90eXBlLmV4aXN0cyA9IHRydWU7XHJcblx0TW9kdWxlQnVpbGRlci5wcm90b3R5cGUuZXhpc3RpbmdSZWZlcmVuY2UgPSB0aGlzO1xyXG59O1xyXG5cclxuTW9kdWxlQnVpbGRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNb2R1bGVCdWlsZGVyO1xyXG5cclxuLy9UaGVzZSB2YXIncyBoZWxwIGNyZWF0ZSB0aGUgc2luZ2xldG9uIGZ1bmN0aW9uYWxpdHlcclxuTW9kdWxlQnVpbGRlci5wcm90b3R5cGUuZXhpc3RzID0gZmFsc2U7XHJcbk1vZHVsZUJ1aWxkZXIucHJvdG90eXBlLmV4aXN0aW5nUmVmZXJlbmNlID0gbnVsbDtcclxuXHJcbi8vY2FsbCB0aGlzIGZ1bmN0aW9uIGZyb20gTW9kdWxlQnVpbGRlciB0byBjb25zdHJ1Y3QgbW9kdWxlc1xyXG4vL1RZUEVTOiAnY29yZScgJ3NoaWVsZCcgJ3RocnVzdGVyJyAnc29sYXJQYW5uZWwnXHJcbk1vZHVsZUJ1aWxkZXIucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24odHlwZSwgeCwgeSkge1xyXG5cdC8vQ2hlY2sgaWYgY29yZSBoYXMgYmVlbiBjcmVhdGVkXHJcblx0aWYodHlwZSA9PT0gJ2NvcmUnICYmIHRoaXMuY29yZUV4aXN0cykge1xyXG5cdFx0Ly9pZiBzbywgcmV0dXJuIGV4aXN0aW5nIGNvcmUgYi9jIGlzIHNpbmdsZXRvblxyXG5cdFx0Ly9iL2Mgb2YgdGhpcywgY2FuIGNhbGwgTW9kdWxlQnVpbGRlci5idWlsZCgnY29yZScpIHRvIGFjY2VzcyByZWZlcmVuY2UgdG8gZXhpc3RpbmcgY29yZVxyXG5cdFx0cmV0dXJuIHRoaXMuY29yZTtcclxuXHR9XHJcblx0XHJcblx0Ly9DcmVhdGUgY3ViZSBvYmplY3QgdG8gYmUgc3RvcmVkIHdpdGhpbiBtb2R1bGVcclxuXHQvL1Nwcml0ZSBuYW1lcyBmb3IgbW9kdWxlcyBhcmUgZGlyZWN0bHkgbWFwcGVkIHRvIG1vZHVsZSBuYW1lcywgc28ganVzdCBwYXNzICd0eXBlJyBhcyBzcHJpdGUgbmFtZVxyXG5cdHZhciBuZXdDdWJlID0gbmV3IEN1YmUodGhpcy5nYW1lU3RhdGUuZ2FtZSwgeCwgeSwgdHlwZSk7XHJcbiAgICB2YXIgc2NhbGUgPSAwLjU7XHJcbiAgICBuZXdDdWJlLm5hbWUgPSB0aGlzLmdhbWVTdGF0ZS5kZWJ1Z051bSsrO1xyXG4gICAgbmV3Q3ViZS5zY2FsZS54ID0gc2NhbGU7XHJcbiAgICBuZXdDdWJlLnNjYWxlLnkgPSBzY2FsZTtcclxuICAgIG5ld0N1YmUuYW5jaG9yLnNldFRvKDAuNSwgMC41KTtcclxuICAgIHRoaXMuZ2FtZVN0YXRlLmdhbWUucGh5c2ljcy5wMi5lbmFibGUobmV3Q3ViZSk7XHJcbiAgICBuZXdDdWJlLmJvZHkub25CZWdpbkNvbnRhY3QuYWRkKG5ld0N1YmUuY3ViZUNvbGxpZGUsIG5ld0N1YmUpO1xyXG4gICAgbmV3Q3ViZS5ib2R5LmRhbXBpbmcgPSAwLjk7XHJcbiAgICBuZXdDdWJlLmJvZHkuYW5ndWxhckRhbXBpbmcgPSAwLjk7XHJcbiAgICBpZiAoIXRoaXMuZ2FtZVN0YXRlLnJvb3RTcGF3bmVkKSB7XHJcbiAgICAgICBuZXdDdWJlLnJvb3QgPSB0cnVlO1xyXG4gICAgICAgdGhpcy5nYW1lU3RhdGUucm9vdFNwYXduZWQgPSB0cnVlO1xyXG4gICAgfVxyXG5cdFxyXG5cdC8vQ3JlYXRlIG1vZHVsZSB0byB3cmFwIGFyb3VuZCBjdWJlIGNsYXNzXHJcblx0dmFyIG5ld01vZHVsZSA9IG5ldyBNb2R1bGUobmV3Q3ViZSk7XHJcblx0XHRcclxuXHQvL1RPRE86IGVkaXQgc3BlY2lhbCBtb2R1bGUgYXRyaWJ1dGVzIGJhc2VkIG9uICd0eXBlJ1xyXG5cdFxyXG5cdC8vU3RvcmUgbW9kdWxlIGlmIGl0IGlzIGNvcmVcclxuXHRpZih0eXBlID09PSAnY29yZScpXHJcblx0e1xyXG5cdFx0dGhpcy5jb3JlID0gbmV3TW9kdWxlO1xyXG5cdFx0dGhpcy5jb3JlRXhpc3RzID0gdHJ1ZTtcclxuXHR9XHJcbiAgIC8vIHNvbGFyIHBhbmVsIHRlc3RpbmdcclxuICAgaWYgKHR5cGUgPT09ICdzb2xhclBhbm5lbCcpIHtcclxuICAgICAgbmV3TW9kdWxlLmN1YmUucnVuQXN0YXIoKTtcclxuICAgfVxyXG5cdFxyXG5cdC8vUmV0dXJuIHRoZSBtb2R1bGUgb2JqZWN0XHJcblx0cmV0dXJuIG5ld01vZHVsZTtcclxufTtcclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE1vZHVsZUJ1aWxkZXI7IiwiLypcclxuRGVmaW5lcyBhIGN1YmUuXHJcbiovXHJcblxyXG52YXIgQXN0YXIgPSByZXF1aXJlKCcuLi9saWJzL2phdmFzY3JpcHQtYXN0YXIvYXN0YXInKTtcclxuXHJcbnZhciBDdWJlID0gZnVuY3Rpb24gKGdhbWUsIHgsIHksIHNwcml0ZSkge1xyXG4gICAgUGhhc2VyLlNwcml0ZS5jYWxsKHRoaXMsIGdhbWUsIHgsIHksIHNwcml0ZSk7XHJcbiAgICBnYW1lLmFkZC5leGlzdGluZyh0aGlzKTtcclxuICAgIHRoaXMuZ3JvdXAgPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLm1vZHVsZSA9IHVuZGVmaW5lZDtcclxufTtcclxuXHJcbkN1YmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShQaGFzZXIuU3ByaXRlLnByb3RvdHlwZSk7XHJcbkN1YmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ3ViZTtcclxuXHJcbi8qKlxyXG4gKiBBdXRvbWF0aWNhbGx5IGNhbGxlZCBieSBXb3JsZC51cGRhdGVcclxuICovXHJcbkN1YmUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xyXG59O1xyXG5cclxuQ3ViZS5wcm90b3R5cGUuY3ViZUNvbGxpZGUgPSBmdW5jdGlvbihvdGhlcikge1xyXG4gICBpZiAodGhpcy5ncm91cCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgfVxyXG4gICB0aGlzLmdyb3VwLmhhbmRsZUNvbGxpc2lvbih0aGlzLCBvdGhlci5zcHJpdGUpO1xyXG59O1xyXG5cclxuQ3ViZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuICAgdmFyIHN0cmluZyA9ICcnO1xyXG4gICBzdHJpbmcgKz0gdGhpcy5jb25jYXQoJ25hbWUnLCB0aGlzLm5hbWUpO1xyXG4gICByZXR1cm4gc3RyaW5nO1xyXG59O1xyXG5cclxuQ3ViZS5wcm90b3R5cGUuY29uY2F0ID0gZnVuY3Rpb24oc3RyaW5nLCB2YWwpIHtcclxuICAgcmV0dXJuIHN0cmluZyArICc6ICcgKyB2YWwgKyAnXFxuJztcclxufTtcclxuXHJcbkN1YmUucHJvdG90eXBlLnJ1bkFzdGFyID0gZnVuY3Rpb24oKSB7XHJcbiAgIHZhciBncmFwaCA9IG5ldyBBc3Rhci5HcmFwaChbXHJcbiAgICAgICAgWzEsMSwxLDFdLFxyXG4gICAgICAgIFswLDEsMSwwXSxcclxuICAgICAgICBbMCwwLDEsMV1cclxuICAgIF0pO1xyXG4gICAgdmFyIHN0YXJ0ID0gZ3JhcGguZ3JpZFswXVswXTtcclxuICAgIHZhciBlbmQgPSBncmFwaC5ncmlkWzFdWzJdO1xyXG4gICAgdmFyIHJlc3VsdCA9IEFzdGFyLmFzdGFyLnNlYXJjaChncmFwaCwgc3RhcnQsIGVuZCk7XHJcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICBjb25zb2xlLmxvZyhyZXN1bHRbaV0ueCwgcmVzdWx0W2ldLnkpO1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDdWJlO1xyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbiIsIi8qXHJcbkRlZmluZXMgYSBjdWJlIGdyb3VwLlxyXG4qL1xyXG5cclxudmFyIEN1YmVHcm91cCA9IGZ1bmN0aW9uIChnYW1lLCByb290KSB7XHJcbiAgIHRoaXMuZ2FtZSA9IGdhbWU7XHJcbiAgIHRoaXMucm9vdCA9IHJvb3Q7XHJcbiAgIHRoaXMuY3ViZXMgPSBbXTtcclxuICAgdmFyIGNvbCA9IFtdO1xyXG4gICBjb2wucHVzaCh0aGlzLnJvb3QpO1xyXG4gICB0aGlzLmN1YmVzLnB1c2goY29sKTtcclxuICAgdGhpcy5yb290Lmdyb3VwID0gdGhpcztcclxuICAgdGhpcy5ESVIgPSB7Tk9SVEg6IDAsIEVBU1Q6IDEsIFNPVVRIOiAyLCBXRVNUOiAzfTtcclxuICAgdGhpcy5vZmZzZXQgPSAyO1xyXG59O1xyXG5cclxuQ3ViZUdyb3VwLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEN1YmVHcm91cDtcclxuXHJcbi8qKlxyXG4gKiBBdXRvbWF0aWNhbGx5IGNhbGxlZCBieSBXb3JsZC51cGRhdGVcclxuICovXHJcbkN1YmVHcm91cC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKSB7XHJcbn07XHJcblxyXG5DdWJlR3JvdXAucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGN1YmUpIHtcclxuICBjdWJlLmdyb3VwID0gdGhpczsgXHJcbn07XHJcblxyXG5DdWJlR3JvdXAucHJvdG90eXBlLmhhbmRsZUNvbGxpc2lvbiA9IGZ1bmN0aW9uKG9yaWdpbiwgb3RoZXIpIHtcclxuICAgLy8gc3RvcCBpZiBvdGhlciBkb2VzIG5vdCBleGlzdCwgZWl0aGVyIGlzIG5vdCBhIGN1YmUsIGJvdGggYXJlIGluIHNhbWUgZ3JvdXBcclxuICAgaWYgKG90aGVyID09PSBudWxsIHx8IG9yaWdpbi5wcm90b3R5cGUgIT09IG90aGVyLnByb3RvdHlwZSB8fCBvcmlnaW4uZ3JvdXAgPT09IG90aGVyLmdyb3VwKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgfVxyXG4gICB2YXIgcmVsU2lkZSA9IHRoaXMucmVsYXRpdmVTaWRlKG9yaWdpbi5ib2R5LCBvdGhlci5ib2R5KTtcclxuICAgdmFyIG9yaWdpbkxvYyA9IHRoaXMuZmluZChvcmlnaW4pO1xyXG4gICB2YXIgb3RoZXJMb2MgPSB0aGlzLmFkanVzdChvcmlnaW5Mb2MsIHJlbFNpZGUpO1xyXG4gICBpZiAodGhpcy5nZXRDdWJlKG90aGVyTG9jKSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgIH1cclxuICAgc3dpdGNoIChyZWxTaWRlKSB7XHJcbiAgICAgIGNhc2UgdGhpcy5ESVIuTk9SVEg6XHJcbiAgICAgIGlmIChvcmlnaW5Mb2MueSA9PT0gdGhpcy5jdWJlc0hlaWdodCgpIC0gMSkge1xyXG4gICAgICAgICB0aGlzLmFkZFRvcFJvdygpO1xyXG4gICAgICB9XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIHRoaXMuRElSLkVBU1Q6XHJcbiAgICAgIGlmIChvcmlnaW5Mb2MueCA9PT0gdGhpcy5jdWJlc1dpZHRoKCkgLSAxKSB7XHJcbiAgICAgICAgIHRoaXMuYWRkUmlnaHRDb2woKTtcclxuICAgICAgfVxyXG4gICAgICBicmVhaztcclxuICAgICAgY2FzZSB0aGlzLkRJUi5TT1VUSDpcclxuICAgICAgaWYgKG9yaWdpbkxvYy55ID09PSAwKSB7XHJcbiAgICAgICAgIHRoaXMuYWRkQm90Um93KCk7XHJcbiAgICAgIH1cclxuICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgdGhpcy5ESVIuV0VTVDpcclxuICAgICAgaWYgKG9yaWdpbkxvYy54ID09PSAwKSB7XHJcbiAgICAgICAgIHRoaXMuYWRkTGVmdENvbCgpO1xyXG4gICAgICB9XHJcbiAgICAgIGJyZWFrO1xyXG4gICB9XHJcbiAgIG9yaWdpbkxvYyA9IHRoaXMuZmluZChvcmlnaW4pO1xyXG4gICBvdGhlckxvYyA9IHRoaXMuYWRqdXN0KG9yaWdpbkxvYywgcmVsU2lkZSk7XHJcbiAgIHRoaXMuY3JlYXRlQ29uc3RyYWludHMob3RoZXJMb2MsIG90aGVyKTtcclxuICAgaWYgKCFvdGhlckxvYykge1xyXG4gICAgICBjb25zb2xlLmxvZygnaGFuZGUgY29sbGlzaW9uIGZhaWxlZCB0byBmaW5kIHNlY29uZCBvdGhlciBsb2MnKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICB9XHJcbiAgIHRoaXMuc2V0KG90aGVyTG9jLCBvdGhlcik7XHJcbiAgIG90aGVyLmdyb3VwID0gdGhpcztcclxufTtcclxuXHJcbkN1YmVHcm91cC5wcm90b3R5cGUuY3JlYXRlQ29uc3RyYWludHMgPSBmdW5jdGlvbihsb2MsIG1lKSB7XHJcbiAgIHZhciBteU5vcnRoID0gdGhpcy5nZXQodGhpcy5hZGp1c3QobG9jLCB0aGlzLkRJUi5OT1JUSCkpO1xyXG4gICB2YXIgbXlFYXN0ID0gdGhpcy5nZXQodGhpcy5hZGp1c3QobG9jLCB0aGlzLkRJUi5FQVNUKSk7XHJcbiAgIHZhciBteVNvdXRoID0gdGhpcy5nZXQodGhpcy5hZGp1c3QobG9jLCB0aGlzLkRJUi5TT1VUSCkpO1xyXG4gICB2YXIgbXlXZXN0ID0gdGhpcy5nZXQodGhpcy5hZGp1c3QobG9jLCB0aGlzLkRJUi5XRVNUKSk7XHJcbiAgIGlmIChteU5vcnRoKSB7XHJcbiAgICAgIHRoaXMuZ2FtZS5waHlzaWNzLnAyLmNyZWF0ZUxvY2tDb25zdHJhaW50KG1lLmJvZHksIG15Tm9ydGguYm9keSwgWzAsIG1lLndpZHRoICsgdGhpcy5vZmZzZXRdKTsgLy8gbWUgLSBub3J0aFxyXG4gICB9XHJcbiAgIGlmIChteUVhc3QpIHtcclxuICAgICAgdGhpcy5nYW1lLnBoeXNpY3MucDIuY3JlYXRlTG9ja0NvbnN0cmFpbnQobWUuYm9keSwgbXlFYXN0LmJvZHksIFstbWUud2lkdGggLSB0aGlzLm9mZnNldCwgMF0pOyAvLyBtZSAtIGVhc3RcclxuICAgfVxyXG4gICBpZiAobXlTb3V0aCkge1xyXG4gICAgICB0aGlzLmdhbWUucGh5c2ljcy5wMi5jcmVhdGVMb2NrQ29uc3RyYWludChteVNvdXRoLmJvZHksIG1lLmJvZHksIFswLCBtZS53aWR0aCArIHRoaXMub2Zmc2V0XSk7IC8vIHNvdXRoIC0gbWVcclxuICAgfVxyXG4gICBpZiAobXlXZXN0KSB7XHJcbiAgICAgIHRoaXMuZ2FtZS5waHlzaWNzLnAyLmNyZWF0ZUxvY2tDb25zdHJhaW50KG15V2VzdC5ib2R5LCBtZS5ib2R5LCBbLW1lLndpZHRoIC0gdGhpcy5vZmZzZXQsIDBdKTsgLy8gd2VzdCAtIG1lXHJcbiAgIH1cclxufTtcclxuXHJcbkN1YmVHcm91cC5wcm90b3R5cGUucmVsYXRpdmVTaWRlID0gZnVuY3Rpb24odGhpc0JvZHksIG90aGVyQm9keSkge1xyXG4gIHZhciB0aGlzUG9pbnQgPSBuZXcgUGhhc2VyLlBvaW50KHRoaXNCb2R5LngsIHRoaXNCb2R5LnkpO1xyXG4gIHZhciBvdGhlclBvaW50ID0gbmV3IFBoYXNlci5Qb2ludChvdGhlckJvZHkueCwgb3RoZXJCb2R5LnkpO1xyXG4gIHZhciBhbmdsZVRvT3RoZXIgPSBQaGFzZXIuUG9pbnQuYW5nbGUodGhpc1BvaW50LCBvdGhlclBvaW50KTtcclxuICBpZiAoYW5nbGVUb090aGVyIDwgMCkgeyAvLyBmaXggZHVtYiBwYXJ0IG9mIFBoYXNlci5Qb2ludC5hbmdsZSgpXHJcbiAgICAgYW5nbGVUb090aGVyID0gMiAqIE1hdGguUEkgKyBhbmdsZVRvT3RoZXI7XHJcbiAgfVxyXG4gIGFuZ2xlVG9PdGhlciA9IChhbmdsZVRvT3RoZXIgKyAzLzIgKiBNYXRoLlBJKSAlICgyICogTWF0aC5QSSk7IC8vIHJvdGF0ZSA5MCBkIGNsb2Nrd2lzZVxyXG4gIHZhciBkaWZmQW5nbGUgPSBhbmdsZVRvT3RoZXIgLSB0aGlzQm9keS5yb3RhdGlvbjtcclxuICAgaWYgKGRpZmZBbmdsZSA8IDEgLyA0ICogTWF0aC5QSSB8fCBkaWZmQW5nbGUgPiA3IC8gNCAqIE1hdGguUEkpIHsgLy8gbm9ydGhcclxuICAgICByZXR1cm4gdGhpcy5ESVIuTk9SVEg7XHJcbiAgfSBlbHNlIGlmIChkaWZmQW5nbGUgPj0gMSAvIDQgKiBNYXRoLlBJICYmIGRpZmZBbmdsZSA8IDMgLyA0ICogTWF0aC5QSSkgeyAvLyBlYXN0XHJcbiAgICAgcmV0dXJuIHRoaXMuRElSLkVBU1Q7XHJcbiAgfSBlbHNlIGlmIChkaWZmQW5nbGUgPj0gMyAvIDQgKiBNYXRoLlBJICYmIGRpZmZBbmdsZSA8IDUgLyA0ICogTWF0aC5QSSkgeyAvLyBzb3V0aFxyXG4gICAgIHJldHVybiB0aGlzLkRJUi5TT1VUSDtcclxuICB9IGVsc2UgaWYgKGRpZmZBbmdsZSA+PSA1IC8gNCAqIE1hdGguUEkgJiYgZGlmZkFuZ2xlIDwgNyAvIDQgKiBNYXRoLlBJKSB7IC8vIHdlc3RcclxuICAgICByZXR1cm4gdGhpcy5ESVIuV0VTVDtcclxuICB9XHJcbn07XHJcblxyXG5DdWJlR3JvdXAucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbihjdWJlKSB7XHJcbiAgIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IHRoaXMuY3ViZXNXaWR0aCgpOyByb3crKykge1xyXG4gICAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCB0aGlzLmN1YmVzSGVpZ2h0KCk7IGNvbCsrKSB7XHJcbiAgICAgICAgIGlmICh0aGlzLmN1YmVzW3Jvd11bY29sXSA9PT0gY3ViZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBoYXNlci5Qb2ludChyb3csIGNvbCk7XHJcbiAgICAgICAgIH1cclxuICAgICAgfVxyXG4gICB9XHJcbiAgIHJldHVybiB1bmRlZmluZWQ7XHJcbn07XHJcblxyXG5DdWJlR3JvdXAucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKHBvaW50KSB7XHJcbiAgaWYgKCFwb2ludCB8fCB0aGlzLm91dE9mQm91bmRzKHBvaW50KSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgfVxyXG4gIHJldHVybiB0aGlzLmN1YmVzW3BvaW50LnhdW3BvaW50LnldO1xyXG59O1xyXG5cclxuQ3ViZUdyb3VwLnByb3RvdHlwZS5jdWJlc1dpZHRoID0gZnVuY3Rpb24oKSB7XHJcbiAgIHJldHVybiB0aGlzLmN1YmVzLmxlbmd0aDtcclxufTtcclxuXHJcbkN1YmVHcm91cC5wcm90b3R5cGUuY3ViZXNIZWlnaHQgPSBmdW5jdGlvbigpIHtcclxuICAgcmV0dXJuIHRoaXMuY3ViZXNbMF0ubGVuZ3RoO1xyXG59O1xyXG5cclxuLypcclxuWzAsaGVpZ2h0XSAuLi4gIFt3aWR0aCwgaGVpZ2h0XVxyXG4uICAgICAgICAgICAgICAgICBcclxuLiAgICAgICAgICAgICAgIC5cclxuLiAgICAgICAgICAgICAgIC5cclxuWzAsMV0gWzEsMV0gLi4uIC5cclxuWzAsMF0gWzEsMF0gLi4uIFt3aWR0aCwwXVxyXG4qL1xyXG5DdWJlR3JvdXAucHJvdG90eXBlLmFkZFRvcFJvdyA9IGZ1bmN0aW9uKCkge1xyXG4gICBmb3IgKHZhciByb3cgPSAwOyByb3cgPCB0aGlzLmN1YmVzV2lkdGgoKTsgcm93KyspIHtcclxuICAgICAgdGhpcy5jdWJlc1tyb3ddLnB1c2godW5kZWZpbmVkKTtcclxuICAgfVxyXG59O1xyXG5cclxuQ3ViZUdyb3VwLnByb3RvdHlwZS5hZGRSaWdodENvbCA9IGZ1bmN0aW9uKCkge1xyXG4gICB2YXIgbmV3Q29sID0gbmV3IEFycmF5KHRoaXMuY3ViZXNIZWlnaHQpO1xyXG4gICB0aGlzLmN1YmVzLnB1c2gobmV3Q29sKTtcclxufTtcclxuXHJcbkN1YmVHcm91cC5wcm90b3R5cGUuYWRkQm90Um93ID0gZnVuY3Rpb24oKSB7XHJcbiAgIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IHRoaXMuY3ViZXNXaWR0aCgpOyByb3crKykge1xyXG4gICAgICB0aGlzLmN1YmVzW3Jvd10udW5zaGlmdCh1bmRlZmluZWQpO1xyXG4gICB9XHJcbn07XHJcblxyXG5DdWJlR3JvdXAucHJvdG90eXBlLmFkZExlZnRDb2wgPSBmdW5jdGlvbigpIHtcclxuICAgdmFyIG5ld0NvbCA9IG5ldyBBcnJheSh0aGlzLmN1YmVzSGVpZ2h0KCkpO1xyXG4gICB0aGlzLmN1YmVzLnVuc2hpZnQobmV3Q29sKTtcclxufTtcclxuXHJcbkN1YmVHcm91cC5wcm90b3R5cGUuZ2V0Q3ViZSA9IGZ1bmN0aW9uKHBvaW50KSB7XHJcbiAgIGlmICghcG9pbnQgfHwgdGhpcy5vdXRPZkJvdW5kcyhwb2ludCkpIHtcclxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgfVxyXG4gICByZXR1cm4gdGhpcy5jdWJlc1twb2ludC54XVtwb2ludC55XTtcclxufTtcclxuXHJcbkN1YmVHcm91cC5wcm90b3R5cGUuYWRqdXN0ID0gZnVuY3Rpb24ocG9pbnQsIGRpcikge1xyXG4gIGlmICghcG9pbnQpIHtcclxuICAgICBjb25zb2xlLmxvZygnYWRqdXN0IGdpdmVuIHVuZGVmaW5lZCBwb2ludCcpO1xyXG4gICAgIHJldHVybjtcclxuICB9XHJcbiAgdmFyIG5ld1BvaW50ID0gbmV3IFBoYXNlci5Qb2ludChwb2ludC54LCBwb2ludC55KTtcclxuICBzd2l0Y2ggKGRpcikge1xyXG4gICAgICBjYXNlIHRoaXMuRElSLk5PUlRIOlxyXG4gICAgICBuZXdQb2ludC55Kys7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIHRoaXMuRElSLkVBU1Q6XHJcbiAgICAgIG5ld1BvaW50LngrKztcclxuICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgdGhpcy5ESVIuU09VVEg6XHJcbiAgICAgIG5ld1BvaW50LnktLTtcclxuICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgdGhpcy5ESVIuV0VTVDpcclxuICAgICAgbmV3UG9pbnQueC0tO1xyXG4gICAgICBicmVhaztcclxuICAgfVxyXG4gICByZXR1cm4gbmV3UG9pbnQ7XHJcbn07XHJcblxyXG5DdWJlR3JvdXAucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKHBvaW50LCBjdWJlKSB7XHJcbiAgIGlmICghcG9pbnQpIHtcclxuICAgICAgY29uc29sZS5sb2coJ3NldCBnaXZlbiB1bmRlZmluZWQgcG9pbnQnKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICB9XHJcbiAgIGlmICh0aGlzLm91dE9mQm91bmRzKHBvaW50KSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgIH1cclxuICAgdGhpcy5jdWJlc1twb2ludC54XVtwb2ludC55XSA9IGN1YmU7XHJcbn07XHJcblxyXG5DdWJlR3JvdXAucHJvdG90eXBlLm91dE9mQm91bmRzID0gZnVuY3Rpb24ocG9pbnQpIHtcclxuICAgaWYgKCFwb2ludCkge1xyXG4gICAgICBjb25zb2xlLmxvZygnb3V0IG9mIGJvdW5kcyBnaXZlbiB1bmRlZmluZWQgcG9pbnQnKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICB9XHJcbiAgIGlmIChwb2ludC54IDwgMCB8fCBwb2ludC54ID49IHRoaXMuY3ViZXNXaWR0aCgpIHx8IHBvaW50LnkgPCAwIHx8IHBvaW50LnkgPj0gdGhpcy5jdWJlc0hlaWdodCgpKSB7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICB9XHJcbiAgIHJldHVybiBmYWxzZTtcclxufTtcclxuXHJcbkN1YmVHcm91cC5wcm90b3R5cGUuZGlzcGxheUN1YmVzID0gZnVuY3Rpb24oKSB7XHJcbiAgIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IHRoaXMuY3ViZXNXaWR0aCgpOyByb3crKykge1xyXG4gICAgICB2YXIgc3RyaW5nID0gJyc7XHJcbiAgICAgIGZvciAodmFyIGNvbCA9IDA7IGNvbCA8IHRoaXMuY3ViZXNIZWlnaHQoKTsgY29sKyspIHtcclxuICAgICAgICAgdmFyIGN1YmUgPSB0aGlzLmN1YmVzW3Jvd11bY29sXTtcclxuICAgICAgICAgaWYgKGN1YmUpIHtcclxuICAgICAgICAgICAgc3RyaW5nICs9ICcjICc7XHJcbiAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHN0cmluZyArPSAnXyAnO1xyXG4gICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgY29uc29sZS5sb2coJ3JvdyAnICsgcm93ICsgJzogJyArIHN0cmluZyArICd8ICcgKyB0aGlzLmN1YmVzW3Jvd10ubGVuZ3RoKTtcclxuICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDdWJlR3JvdXA7XHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG4iLCIvLyBqYXZhc2NyaXB0LWFzdGFyIDAuNC4wXG4vLyBodHRwOi8vZ2l0aHViLmNvbS9iZ3JpbnMvamF2YXNjcmlwdC1hc3RhclxuLy8gRnJlZWx5IGRpc3RyaWJ1dGFibGUgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuLy8gSW1wbGVtZW50cyB0aGUgYXN0YXIgc2VhcmNoIGFsZ29yaXRobSBpbiBqYXZhc2NyaXB0IHVzaW5nIGEgQmluYXJ5IEhlYXAuXG4vLyBJbmNsdWRlcyBCaW5hcnkgSGVhcCAod2l0aCBtb2RpZmljYXRpb25zKSBmcm9tIE1hcmlqbiBIYXZlcmJla2UuXG4vLyBodHRwOi8vZWxvcXVlbnRqYXZhc2NyaXB0Lm5ldC9hcHBlbmRpeDIuaHRtbFxuXG4oZnVuY3Rpb24oZGVmaW5pdGlvbikge1xuICAgIC8qIGdsb2JhbCBtb2R1bGUsIGRlZmluZSAqL1xuICAgIGlmKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBkZWZpbml0aW9uKCk7XG4gICAgfSBlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoW10sIGRlZmluaXRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBleHBvcnRzID0gZGVmaW5pdGlvbigpO1xuICAgICAgICB3aW5kb3cuYXN0YXIgPSBleHBvcnRzLmFzdGFyO1xuICAgICAgICB3aW5kb3cuR3JhcGggPSBleHBvcnRzLkdyYXBoO1xuICAgIH1cbn0pKGZ1bmN0aW9uKCkge1xuXG5mdW5jdGlvbiBwYXRoVG8obm9kZSl7XG4gICAgdmFyIGN1cnIgPSBub2RlLFxuICAgICAgICBwYXRoID0gW107XG4gICAgd2hpbGUoY3Vyci5wYXJlbnQpIHtcbiAgICAgICAgcGF0aC5wdXNoKGN1cnIpO1xuICAgICAgICBjdXJyID0gY3Vyci5wYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiBwYXRoLnJldmVyc2UoKTtcbn1cblxuZnVuY3Rpb24gZ2V0SGVhcCgpIHtcbiAgICByZXR1cm4gbmV3IEJpbmFyeUhlYXAoZnVuY3Rpb24obm9kZSkge1xuICAgICAgICByZXR1cm4gbm9kZS5mO1xuICAgIH0pO1xufVxuXG52YXIgYXN0YXIgPSB7XG4gICAgLyoqXG4gICAgKiBQZXJmb3JtIGFuIEEqIFNlYXJjaCBvbiBhIGdyYXBoIGdpdmVuIGEgc3RhcnQgYW5kIGVuZCBub2RlLlxuICAgICogQHBhcmFtIHtHcmFwaH0gZ3JhcGhcbiAgICAqIEBwYXJhbSB7R3JpZE5vZGV9IHN0YXJ0XG4gICAgKiBAcGFyYW0ge0dyaWROb2RlfSBlbmRcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICAqIEBwYXJhbSB7Ym9vbH0gW29wdGlvbnMuY2xvc2VzdF0gU3BlY2lmaWVzIHdoZXRoZXIgdG8gcmV0dXJuIHRoZVxuICAgICAgICAgICAgICAgcGF0aCB0byB0aGUgY2xvc2VzdCBub2RlIGlmIHRoZSB0YXJnZXQgaXMgdW5yZWFjaGFibGUuXG4gICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5oZXVyaXN0aWNdIEhldXJpc3RpYyBmdW5jdGlvbiAoc2VlXG4gICAgKiAgICAgICAgICBhc3Rhci5oZXVyaXN0aWNzKS5cbiAgICAqL1xuICAgIHNlYXJjaDogZnVuY3Rpb24oZ3JhcGgsIHN0YXJ0LCBlbmQsIG9wdGlvbnMpIHtcbiAgICAgICAgZ3JhcGguY2xlYW5EaXJ0eSgpO1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgdmFyIGhldXJpc3RpYyA9IG9wdGlvbnMuaGV1cmlzdGljIHx8IGFzdGFyLmhldXJpc3RpY3MubWFuaGF0dGFuLFxuICAgICAgICAgICAgY2xvc2VzdCA9IG9wdGlvbnMuY2xvc2VzdCB8fCBmYWxzZTtcblxuICAgICAgICB2YXIgb3BlbkhlYXAgPSBnZXRIZWFwKCksXG4gICAgICAgICAgICBjbG9zZXN0Tm9kZSA9IHN0YXJ0OyAvLyBzZXQgdGhlIHN0YXJ0IG5vZGUgdG8gYmUgdGhlIGNsb3Nlc3QgaWYgcmVxdWlyZWRcblxuICAgICAgICBzdGFydC5oID0gaGV1cmlzdGljKHN0YXJ0LCBlbmQpO1xuXG4gICAgICAgIG9wZW5IZWFwLnB1c2goc3RhcnQpO1xuXG4gICAgICAgIHdoaWxlKG9wZW5IZWFwLnNpemUoKSA+IDApIHtcblxuICAgICAgICAgICAgLy8gR3JhYiB0aGUgbG93ZXN0IGYoeCkgdG8gcHJvY2VzcyBuZXh0LiAgSGVhcCBrZWVwcyB0aGlzIHNvcnRlZCBmb3IgdXMuXG4gICAgICAgICAgICB2YXIgY3VycmVudE5vZGUgPSBvcGVuSGVhcC5wb3AoKTtcblxuICAgICAgICAgICAgLy8gRW5kIGNhc2UgLS0gcmVzdWx0IGhhcyBiZWVuIGZvdW5kLCByZXR1cm4gdGhlIHRyYWNlZCBwYXRoLlxuICAgICAgICAgICAgaWYoY3VycmVudE5vZGUgPT09IGVuZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXRoVG8oY3VycmVudE5vZGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBOb3JtYWwgY2FzZSAtLSBtb3ZlIGN1cnJlbnROb2RlIGZyb20gb3BlbiB0byBjbG9zZWQsIHByb2Nlc3MgZWFjaCBvZiBpdHMgbmVpZ2hib3JzLlxuICAgICAgICAgICAgY3VycmVudE5vZGUuY2xvc2VkID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy8gRmluZCBhbGwgbmVpZ2hib3JzIGZvciB0aGUgY3VycmVudCBub2RlLlxuICAgICAgICAgICAgdmFyIG5laWdoYm9ycyA9IGdyYXBoLm5laWdoYm9ycyhjdXJyZW50Tm9kZSk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IG5laWdoYm9ycy5sZW5ndGg7IGkgPCBpbDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5laWdoYm9yID0gbmVpZ2hib3JzW2ldO1xuXG4gICAgICAgICAgICAgICAgaWYgKG5laWdoYm9yLmNsb3NlZCB8fCBuZWlnaGJvci5pc1dhbGwoKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBOb3QgYSB2YWxpZCBub2RlIHRvIHByb2Nlc3MsIHNraXAgdG8gbmV4dCBuZWlnaGJvci5cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gVGhlIGcgc2NvcmUgaXMgdGhlIHNob3J0ZXN0IGRpc3RhbmNlIGZyb20gc3RhcnQgdG8gY3VycmVudCBub2RlLlxuICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgaWYgdGhlIHBhdGggd2UgaGF2ZSBhcnJpdmVkIGF0IHRoaXMgbmVpZ2hib3IgaXMgdGhlIHNob3J0ZXN0IG9uZSB3ZSBoYXZlIHNlZW4geWV0LlxuICAgICAgICAgICAgICAgIHZhciBnU2NvcmUgPSBjdXJyZW50Tm9kZS5nICsgbmVpZ2hib3IuZ2V0Q29zdChjdXJyZW50Tm9kZSksXG4gICAgICAgICAgICAgICAgICAgIGJlZW5WaXNpdGVkID0gbmVpZ2hib3IudmlzaXRlZDtcblxuICAgICAgICAgICAgICAgIGlmICghYmVlblZpc2l0ZWQgfHwgZ1Njb3JlIDwgbmVpZ2hib3IuZykge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEZvdW5kIGFuIG9wdGltYWwgKHNvIGZhcikgcGF0aCB0byB0aGlzIG5vZGUuICBUYWtlIHNjb3JlIGZvciBub2RlIHRvIHNlZSBob3cgZ29vZCBpdCBpcy5cbiAgICAgICAgICAgICAgICAgICAgbmVpZ2hib3IudmlzaXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIG5laWdoYm9yLnBhcmVudCA9IGN1cnJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICBuZWlnaGJvci5oID0gbmVpZ2hib3IuaCB8fCBoZXVyaXN0aWMobmVpZ2hib3IsIGVuZCk7XG4gICAgICAgICAgICAgICAgICAgIG5laWdoYm9yLmcgPSBnU2NvcmU7XG4gICAgICAgICAgICAgICAgICAgIG5laWdoYm9yLmYgPSBuZWlnaGJvci5nICsgbmVpZ2hib3IuaDtcbiAgICAgICAgICAgICAgICAgICAgZ3JhcGgubWFya0RpcnR5KG5laWdoYm9yKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNsb3Nlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBuZWlnaGJvdXIgaXMgY2xvc2VyIHRoYW4gdGhlIGN1cnJlbnQgY2xvc2VzdE5vZGUgb3IgaWYgaXQncyBlcXVhbGx5IGNsb3NlIGJ1dCBoYXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGEgY2hlYXBlciBwYXRoIHRoYW4gdGhlIGN1cnJlbnQgY2xvc2VzdCBub2RlIHRoZW4gaXQgYmVjb21lcyB0aGUgY2xvc2VzdCBub2RlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmVpZ2hib3IuaCA8IGNsb3Nlc3ROb2RlLmggfHwgKG5laWdoYm9yLmggPT09IGNsb3Nlc3ROb2RlLmggJiYgbmVpZ2hib3IuZyA8IGNsb3Nlc3ROb2RlLmcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VzdE5vZGUgPSBuZWlnaGJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICghYmVlblZpc2l0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFB1c2hpbmcgdG8gaGVhcCB3aWxsIHB1dCBpdCBpbiBwcm9wZXIgcGxhY2UgYmFzZWQgb24gdGhlICdmJyB2YWx1ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5IZWFwLnB1c2gobmVpZ2hib3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxyZWFkeSBzZWVuIHRoZSBub2RlLCBidXQgc2luY2UgaXQgaGFzIGJlZW4gcmVzY29yZWQgd2UgbmVlZCB0byByZW9yZGVyIGl0IGluIHRoZSBoZWFwXG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVuSGVhcC5yZXNjb3JlRWxlbWVudChuZWlnaGJvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2xvc2VzdCkge1xuICAgICAgICAgICAgcmV0dXJuIHBhdGhUbyhjbG9zZXN0Tm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBObyByZXN1bHQgd2FzIGZvdW5kIC0gZW1wdHkgYXJyYXkgc2lnbmlmaWVzIGZhaWx1cmUgdG8gZmluZCBwYXRoLlxuICAgICAgICByZXR1cm4gW107XG4gICAgfSxcbiAgICAvLyBTZWUgbGlzdCBvZiBoZXVyaXN0aWNzOiBodHRwOi8vdGhlb3J5LnN0YW5mb3JkLmVkdS9+YW1pdHAvR2FtZVByb2dyYW1taW5nL0hldXJpc3RpY3MuaHRtbFxuICAgIGhldXJpc3RpY3M6IHtcbiAgICAgICAgbWFuaGF0dGFuOiBmdW5jdGlvbihwb3MwLCBwb3MxKSB7XG4gICAgICAgICAgICB2YXIgZDEgPSBNYXRoLmFicyhwb3MxLnggLSBwb3MwLngpO1xuICAgICAgICAgICAgdmFyIGQyID0gTWF0aC5hYnMocG9zMS55IC0gcG9zMC55KTtcbiAgICAgICAgICAgIHJldHVybiBkMSArIGQyO1xuICAgICAgICB9LFxuICAgICAgICBkaWFnb25hbDogZnVuY3Rpb24ocG9zMCwgcG9zMSkge1xuICAgICAgICAgICAgdmFyIEQgPSAxO1xuICAgICAgICAgICAgdmFyIEQyID0gTWF0aC5zcXJ0KDIpO1xuICAgICAgICAgICAgdmFyIGQxID0gTWF0aC5hYnMocG9zMS54IC0gcG9zMC54KTtcbiAgICAgICAgICAgIHZhciBkMiA9IE1hdGguYWJzKHBvczEueSAtIHBvczAueSk7XG4gICAgICAgICAgICByZXR1cm4gKEQgKiAoZDEgKyBkMikpICsgKChEMiAtICgyICogRCkpICogTWF0aC5taW4oZDEsIGQyKSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGNsZWFuTm9kZTpmdW5jdGlvbihub2RlKXtcbiAgICAgICAgbm9kZS5mID0gMDtcbiAgICAgICAgbm9kZS5nID0gMDtcbiAgICAgICAgbm9kZS5oID0gMDtcbiAgICAgICAgbm9kZS52aXNpdGVkID0gZmFsc2U7XG4gICAgICAgIG5vZGUuY2xvc2VkID0gZmFsc2U7XG4gICAgICAgIG5vZGUucGFyZW50ID0gbnVsbDtcbiAgICB9XG59O1xuXG4vKipcbiogQSBncmFwaCBtZW1vcnkgc3RydWN0dXJlXG4qIEBwYXJhbSB7QXJyYXl9IGdyaWRJbiAyRCBhcnJheSBvZiBpbnB1dCB3ZWlnaHRzXG4qIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiogQHBhcmFtIHtib29sfSBbb3B0aW9ucy5kaWFnb25hbF0gU3BlY2lmaWVzIHdoZXRoZXIgZGlhZ29uYWwgbW92ZXMgYXJlIGFsbG93ZWRcbiovXG5mdW5jdGlvbiBHcmFwaChncmlkSW4sIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB0aGlzLm5vZGVzID0gW107XG4gICAgdGhpcy5kaWFnb25hbCA9ICEhb3B0aW9ucy5kaWFnb25hbDtcbiAgICB0aGlzLmdyaWQgPSBbXTtcbiAgICBmb3IgKHZhciB4ID0gMDsgeCA8IGdyaWRJbi5sZW5ndGg7IHgrKykge1xuICAgICAgICB0aGlzLmdyaWRbeF0gPSBbXTtcblxuICAgICAgICBmb3IgKHZhciB5ID0gMCwgcm93ID0gZ3JpZEluW3hdOyB5IDwgcm93Lmxlbmd0aDsgeSsrKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IG5ldyBHcmlkTm9kZSh4LCB5LCByb3dbeV0pO1xuICAgICAgICAgICAgdGhpcy5ncmlkW3hdW3ldID0gbm9kZTtcbiAgICAgICAgICAgIHRoaXMubm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmluaXQoKTtcbn1cblxuR3JhcGgucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmRpcnR5Tm9kZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXN0YXIuY2xlYW5Ob2RlKHRoaXMubm9kZXNbaV0pO1xuICAgIH1cbn07XG5cbkdyYXBoLnByb3RvdHlwZS5jbGVhbkRpcnR5ID0gZnVuY3Rpb24oKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRpcnR5Tm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXN0YXIuY2xlYW5Ob2RlKHRoaXMuZGlydHlOb2Rlc1tpXSk7XG4gICAgfVxuICAgIHRoaXMuZGlydHlOb2RlcyA9IFtdO1xufTtcblxuR3JhcGgucHJvdG90eXBlLm1hcmtEaXJ0eSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB0aGlzLmRpcnR5Tm9kZXMucHVzaChub2RlKTtcbn07XG5cbkdyYXBoLnByb3RvdHlwZS5uZWlnaGJvcnMgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdmFyIHJldCA9IFtdLFxuICAgICAgICB4ID0gbm9kZS54LFxuICAgICAgICB5ID0gbm9kZS55LFxuICAgICAgICBncmlkID0gdGhpcy5ncmlkO1xuXG4gICAgLy8gV2VzdFxuICAgIGlmKGdyaWRbeC0xXSAmJiBncmlkW3gtMV1beV0pIHtcbiAgICAgICAgcmV0LnB1c2goZ3JpZFt4LTFdW3ldKTtcbiAgICB9XG5cbiAgICAvLyBFYXN0XG4gICAgaWYoZ3JpZFt4KzFdICYmIGdyaWRbeCsxXVt5XSkge1xuICAgICAgICByZXQucHVzaChncmlkW3grMV1beV0pO1xuICAgIH1cblxuICAgIC8vIFNvdXRoXG4gICAgaWYoZ3JpZFt4XSAmJiBncmlkW3hdW3ktMV0pIHtcbiAgICAgICAgcmV0LnB1c2goZ3JpZFt4XVt5LTFdKTtcbiAgICB9XG5cbiAgICAvLyBOb3J0aFxuICAgIGlmKGdyaWRbeF0gJiYgZ3JpZFt4XVt5KzFdKSB7XG4gICAgICAgIHJldC5wdXNoKGdyaWRbeF1beSsxXSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZGlhZ29uYWwpIHtcbiAgICAgICAgLy8gU291dGh3ZXN0XG4gICAgICAgIGlmKGdyaWRbeC0xXSAmJiBncmlkW3gtMV1beS0xXSkge1xuICAgICAgICAgICAgcmV0LnB1c2goZ3JpZFt4LTFdW3ktMV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU291dGhlYXN0XG4gICAgICAgIGlmKGdyaWRbeCsxXSAmJiBncmlkW3grMV1beS0xXSkge1xuICAgICAgICAgICAgcmV0LnB1c2goZ3JpZFt4KzFdW3ktMV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTm9ydGh3ZXN0XG4gICAgICAgIGlmKGdyaWRbeC0xXSAmJiBncmlkW3gtMV1beSsxXSkge1xuICAgICAgICAgICAgcmV0LnB1c2goZ3JpZFt4LTFdW3krMV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTm9ydGhlYXN0XG4gICAgICAgIGlmKGdyaWRbeCsxXSAmJiBncmlkW3grMV1beSsxXSkge1xuICAgICAgICAgICAgcmV0LnB1c2goZ3JpZFt4KzFdW3krMV0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbn07XG5cbkdyYXBoLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBncmFwaFN0cmluZyA9IFtdLFxuICAgICAgICBub2RlcyA9IHRoaXMuZ3JpZCwgLy8gd2hlbiB1c2luZyBncmlkXG4gICAgICAgIHJvd0RlYnVnLCByb3csIHksIGw7XG4gICAgZm9yICh2YXIgeCA9IDAsIGxlbiA9IG5vZGVzLmxlbmd0aDsgeCA8IGxlbjsgeCsrKSB7XG4gICAgICAgIHJvd0RlYnVnID0gW107XG4gICAgICAgIHJvdyA9IG5vZGVzW3hdO1xuICAgICAgICBmb3IgKHkgPSAwLCBsID0gcm93Lmxlbmd0aDsgeSA8IGw7IHkrKykge1xuICAgICAgICAgICAgcm93RGVidWcucHVzaChyb3dbeV0ud2VpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBncmFwaFN0cmluZy5wdXNoKHJvd0RlYnVnLmpvaW4oJyAnKSk7XG4gICAgfVxuICAgIHJldHVybiBncmFwaFN0cmluZy5qb2luKCdcXG4nKTtcbn07XG5cbmZ1bmN0aW9uIEdyaWROb2RlKHgsIHksIHdlaWdodCkge1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgICB0aGlzLndlaWdodCA9IHdlaWdodDtcbn1cblxuR3JpZE5vZGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICdbJyArIHRoaXMueCArICcgJyArIHRoaXMueSArICddJztcbn07XG5cbkdyaWROb2RlLnByb3RvdHlwZS5nZXRDb3N0ID0gZnVuY3Rpb24oZnJvbU5laWdoYm9yKSB7XG4gICAgLy8gVGFrZSBkaWFnb25hbCB3ZWlnaHQgaW50byBjb25zaWRlcmF0aW9uLlxuICAgIGlmIChmcm9tTmVpZ2hib3IgJiYgZnJvbU5laWdoYm9yLnggIT09IHRoaXMueCAmJiBmcm9tTmVpZ2hib3IueSAhPT0gdGhpcy55KSB7XG4gICAgICAgIHJldHVybiB0aGlzLndlaWdodCAqIDEuNDE0MjE7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLndlaWdodDtcbn07XG5cbkdyaWROb2RlLnByb3RvdHlwZS5pc1dhbGwgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy53ZWlnaHQgPT09IDA7XG59O1xuXG5mdW5jdGlvbiBCaW5hcnlIZWFwKHNjb3JlRnVuY3Rpb24pe1xuICAgIHRoaXMuY29udGVudCA9IFtdO1xuICAgIHRoaXMuc2NvcmVGdW5jdGlvbiA9IHNjb3JlRnVuY3Rpb247XG59XG5cbkJpbmFyeUhlYXAucHJvdG90eXBlID0ge1xuICAgIHB1c2g6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgLy8gQWRkIHRoZSBuZXcgZWxlbWVudCB0byB0aGUgZW5kIG9mIHRoZSBhcnJheS5cbiAgICAgICAgdGhpcy5jb250ZW50LnB1c2goZWxlbWVudCk7XG5cbiAgICAgICAgLy8gQWxsb3cgaXQgdG8gc2luayBkb3duLlxuICAgICAgICB0aGlzLnNpbmtEb3duKHRoaXMuY29udGVudC5sZW5ndGggLSAxKTtcbiAgICB9LFxuICAgIHBvcDogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIFN0b3JlIHRoZSBmaXJzdCBlbGVtZW50IHNvIHdlIGNhbiByZXR1cm4gaXQgbGF0ZXIuXG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmNvbnRlbnRbMF07XG4gICAgICAgIC8vIEdldCB0aGUgZWxlbWVudCBhdCB0aGUgZW5kIG9mIHRoZSBhcnJheS5cbiAgICAgICAgdmFyIGVuZCA9IHRoaXMuY29udGVudC5wb3AoKTtcbiAgICAgICAgLy8gSWYgdGhlcmUgYXJlIGFueSBlbGVtZW50cyBsZWZ0LCBwdXQgdGhlIGVuZCBlbGVtZW50IGF0IHRoZVxuICAgICAgICAvLyBzdGFydCwgYW5kIGxldCBpdCBidWJibGUgdXAuXG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5jb250ZW50WzBdID0gZW5kO1xuICAgICAgICAgICAgdGhpcy5idWJibGVVcCgwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG4gICAgcmVtb3ZlOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIHZhciBpID0gdGhpcy5jb250ZW50LmluZGV4T2Yobm9kZSk7XG5cbiAgICAgICAgLy8gV2hlbiBpdCBpcyBmb3VuZCwgdGhlIHByb2Nlc3Mgc2VlbiBpbiAncG9wJyBpcyByZXBlYXRlZFxuICAgICAgICAvLyB0byBmaWxsIHVwIHRoZSBob2xlLlxuICAgICAgICB2YXIgZW5kID0gdGhpcy5jb250ZW50LnBvcCgpO1xuXG4gICAgICAgIGlmIChpICE9PSB0aGlzLmNvbnRlbnQubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgdGhpcy5jb250ZW50W2ldID0gZW5kO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5zY29yZUZ1bmN0aW9uKGVuZCkgPCB0aGlzLnNjb3JlRnVuY3Rpb24obm9kZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNpbmtEb3duKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5idWJibGVVcChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgc2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQubGVuZ3RoO1xuICAgIH0sXG4gICAgcmVzY29yZUVsZW1lbnQ6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgdGhpcy5zaW5rRG93bih0aGlzLmNvbnRlbnQuaW5kZXhPZihub2RlKSk7XG4gICAgfSxcbiAgICBzaW5rRG93bjogZnVuY3Rpb24obikge1xuICAgICAgICAvLyBGZXRjaCB0aGUgZWxlbWVudCB0aGF0IGhhcyB0byBiZSBzdW5rLlxuICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuY29udGVudFtuXTtcblxuICAgICAgICAvLyBXaGVuIGF0IDAsIGFuIGVsZW1lbnQgY2FuIG5vdCBzaW5rIGFueSBmdXJ0aGVyLlxuICAgICAgICB3aGlsZSAobiA+IDApIHtcblxuICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgcGFyZW50IGVsZW1lbnQncyBpbmRleCwgYW5kIGZldGNoIGl0LlxuICAgICAgICAgICAgdmFyIHBhcmVudE4gPSAoKG4gKyAxKSA+PiAxKSAtIDEsXG4gICAgICAgICAgICAgICAgcGFyZW50ID0gdGhpcy5jb250ZW50W3BhcmVudE5dO1xuICAgICAgICAgICAgLy8gU3dhcCB0aGUgZWxlbWVudHMgaWYgdGhlIHBhcmVudCBpcyBncmVhdGVyLlxuICAgICAgICAgICAgaWYgKHRoaXMuc2NvcmVGdW5jdGlvbihlbGVtZW50KSA8IHRoaXMuc2NvcmVGdW5jdGlvbihwYXJlbnQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZW50W3BhcmVudE5dID0gZWxlbWVudDtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnRbbl0gPSBwYXJlbnQ7XG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlICduJyB0byBjb250aW51ZSBhdCB0aGUgbmV3IHBvc2l0aW9uLlxuICAgICAgICAgICAgICAgIG4gPSBwYXJlbnROO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRm91bmQgYSBwYXJlbnQgdGhhdCBpcyBsZXNzLCBubyBuZWVkIHRvIHNpbmsgYW55IGZ1cnRoZXIuXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgYnViYmxlVXA6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgLy8gTG9vayB1cCB0aGUgdGFyZ2V0IGVsZW1lbnQgYW5kIGl0cyBzY29yZS5cbiAgICAgICAgdmFyIGxlbmd0aCA9IHRoaXMuY29udGVudC5sZW5ndGgsXG4gICAgICAgICAgICBlbGVtZW50ID0gdGhpcy5jb250ZW50W25dLFxuICAgICAgICAgICAgZWxlbVNjb3JlID0gdGhpcy5zY29yZUZ1bmN0aW9uKGVsZW1lbnQpO1xuXG4gICAgICAgIHdoaWxlKHRydWUpIHtcbiAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIGluZGljZXMgb2YgdGhlIGNoaWxkIGVsZW1lbnRzLlxuICAgICAgICAgICAgdmFyIGNoaWxkMk4gPSAobiArIDEpIDw8IDEsXG4gICAgICAgICAgICAgICAgY2hpbGQxTiA9IGNoaWxkMk4gLSAxO1xuICAgICAgICAgICAgLy8gVGhpcyBpcyB1c2VkIHRvIHN0b3JlIHRoZSBuZXcgcG9zaXRpb24gb2YgdGhlIGVsZW1lbnQsIGlmIGFueS5cbiAgICAgICAgICAgIHZhciBzd2FwID0gbnVsbCxcbiAgICAgICAgICAgICAgICBjaGlsZDFTY29yZTtcbiAgICAgICAgICAgIC8vIElmIHRoZSBmaXJzdCBjaGlsZCBleGlzdHMgKGlzIGluc2lkZSB0aGUgYXJyYXkpLi4uXG4gICAgICAgICAgICBpZiAoY2hpbGQxTiA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIExvb2sgaXQgdXAgYW5kIGNvbXB1dGUgaXRzIHNjb3JlLlxuICAgICAgICAgICAgICAgIHZhciBjaGlsZDEgPSB0aGlzLmNvbnRlbnRbY2hpbGQxTl07XG4gICAgICAgICAgICAgICAgY2hpbGQxU2NvcmUgPSB0aGlzLnNjb3JlRnVuY3Rpb24oY2hpbGQxKTtcblxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBzY29yZSBpcyBsZXNzIHRoYW4gb3VyIGVsZW1lbnQncywgd2UgbmVlZCB0byBzd2FwLlxuICAgICAgICAgICAgICAgIGlmIChjaGlsZDFTY29yZSA8IGVsZW1TY29yZSl7XG4gICAgICAgICAgICAgICAgICAgIHN3YXAgPSBjaGlsZDFOO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRG8gdGhlIHNhbWUgY2hlY2tzIGZvciB0aGUgb3RoZXIgY2hpbGQuXG4gICAgICAgICAgICBpZiAoY2hpbGQyTiA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZDIgPSB0aGlzLmNvbnRlbnRbY2hpbGQyTl0sXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkMlNjb3JlID0gdGhpcy5zY29yZUZ1bmN0aW9uKGNoaWxkMik7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkMlNjb3JlIDwgKHN3YXAgPT09IG51bGwgPyBlbGVtU2NvcmUgOiBjaGlsZDFTY29yZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dhcCA9IGNoaWxkMk47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiB0aGUgZWxlbWVudCBuZWVkcyB0byBiZSBtb3ZlZCwgc3dhcCBpdCwgYW5kIGNvbnRpbnVlLlxuICAgICAgICAgICAgaWYgKHN3YXAgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnRbbl0gPSB0aGlzLmNvbnRlbnRbc3dhcF07XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZW50W3N3YXBdID0gZWxlbWVudDtcbiAgICAgICAgICAgICAgICBuID0gc3dhcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgd2UgYXJlIGRvbmUuXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnJldHVybiB7XG4gICAgYXN0YXI6IGFzdGFyLFxuICAgIEdyYXBoOiBHcmFwaFxufTtcblxufSk7XG4iLCJ2YXIgQm9vdCA9IGZ1bmN0aW9uICgpIHt9O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCb290O1xyXG5cclxuQm9vdC5wcm90b3R5cGUgPSB7XHJcblxyXG4gIHByZWxvYWQ6IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMubG9hZC5pbWFnZSgncHJlbG9hZGVyJywgJ2Fzc2V0cy9wcmVsb2FkZXIuZ2lmJyk7XHJcbiAgfSxcclxuXHJcbiAgY3JlYXRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLmdhbWUuaW5wdXQubWF4UG9pbnRlcnMgPSAxO1xyXG5cclxuICAgIGlmICh0aGlzLmdhbWUuZGV2aWNlLmRlc2t0b3ApIHtcclxuICAgICAgdGhpcy5nYW1lLnN0YWdlLnNjYWxlLnBhZ2VBbGlnbkhvcml6b250YWxseSA9IHRydWU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLmdhbWUuc2NhbGUuc2NhbGVNb2RlID0gUGhhc2VyLlNjYWxlTWFuYWdlci5TSE9XX0FMTDtcclxuICAgICAgdGhpcy5nYW1lLnNjYWxlLm1pbldpZHRoID0gIDQ4MDtcclxuICAgICAgdGhpcy5nYW1lLnNjYWxlLm1pbkhlaWdodCA9IDI2MDtcclxuICAgICAgdGhpcy5nYW1lLnNjYWxlLm1heFdpZHRoID0gNjQwO1xyXG4gICAgICB0aGlzLmdhbWUuc2NhbGUubWF4SGVpZ2h0ID0gNDgwO1xyXG4gICAgICB0aGlzLmdhbWUuc2NhbGUuZm9yY2VMYW5kc2NhcGUgPSB0cnVlO1xyXG4gICAgICB0aGlzLmdhbWUuc2NhbGUucGFnZUFsaWduSG9yaXpvbnRhbGx5ID0gdHJ1ZTtcclxuICAgICAgdGhpcy5nYW1lLnNjYWxlLnNldFNjcmVlblNpemUodHJ1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5nYW1lLnN0YXRlLnN0YXJ0KCdQcmVsb2FkZXInKTtcclxuICB9XHJcbn07XHJcbiIsIi8qXHJcbk1haW4gdGVzdGluZyBlbnZpcm9ubWVudC5cclxuKi9cclxuXHJcbnZhciBNb2R1bGVCdWlsZGVyID0gcmVxdWlyZSgnLi4vZW50aXRpZXMvTW9kdWxlQnVpbGRlcicpO1xyXG52YXIgQ3ViZSA9IHJlcXVpcmUoJy4uL2VudGl0aWVzL2N1YmUnKTtcclxudmFyIE1vZHVsZUJ1aWxkZXIgPSByZXF1aXJlKCcuLi9lbnRpdGllcy9Nb2R1bGVCdWlsZGVyJyk7XHJcbnZhciBVdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XHJcbnZhciBDdWJlR3JvdXAgPSByZXF1aXJlKCcuLi9lbnRpdGllcy9jdWJlX2dyb3VwJyk7XHJcblxyXG52YXIgbW91c2VCb2R5OyAvLyBwaHlzaWNzIGJvZHkgZm9yIG1vdXNlXHJcblxyXG52YXIgR2FtZSA9IGZ1bmN0aW9uICgpIHtcclxuICB0aGlzLnRlc3RlbnRpdHkgPSBudWxsO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHYW1lO1xyXG5cclxuR2FtZS5wcm90b3R5cGUgPSB7XHJcblx0XHJcbiAgY3JlYXRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLmdhbWUucGh5c2ljcy5zdGFydFN5c3RlbShQaGFzZXIuUGh5c2ljcy5QMkpTKTtcclxuICAgIHRoaXMuZ2FtZS5waHlzaWNzLnAyLnNldEltcGFjdEV2ZW50cyh0cnVlKTtcclxuICAgIG1vdXNlQm9keSA9IG5ldyBwMi5Cb2R5KCk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxyXG4gICAgdGhpcy5nYW1lLnBoeXNpY3MucDIud29ybGQuYWRkQm9keShtb3VzZUJvZHkpO1xyXG4gICAgXHJcblx0Ly9jcmVhdGUgTW9kdWxlQnVpbGRlciBhbmQgc3RvcmUgaXQgaW4gdGhpcyBnYW1lIHN0YXRlIG9iamVjdFxyXG5cdHRoaXMubW9kdWxlQnVpbGRlciA9IG5ldyBNb2R1bGVCdWlsZGVyKHRoaXMpO1xyXG5cdC8vY3JlYXRlIGFuZCBzdG9yZSB0aGUgY29yZSBtb2R1bGVcclxuXHR0aGlzLmNvcmVNb2R1bGUgPSB0aGlzLm1vZHVsZUJ1aWxkZXIuYnVpbGQoJ2NvcmUnLCAyMDAsIDIwMCk7XHJcbiAgIHRoaXMucGxheWVyID0gbmV3IEN1YmVHcm91cCh0aGlzLCB0aGlzLmNvcmVNb2R1bGUuY3ViZSk7XHJcbiAgIFxyXG5cdFxyXG5cdC8vREVCVUdHSU5HIExJU1RFTkVSUy0gYWxsb3cgeW91IHRvIGNyZWF0ZSBtb2R1bGVzIGJ5IHByZXNzaW5nIGtleXNcclxuXHQvL2NvcmVcclxuXHR0aGlzLnBsYWNlQ29yZUtleSA9IHRoaXMuZ2FtZS5pbnB1dC5rZXlib2FyZC5hZGRLZXkoUGhhc2VyLktleWJvYXJkLlApO1xyXG4gICB0aGlzLnBsYWNlQ29yZUtleS5vbkRvd24uYWRkKHRoaXMuYWRkQ29yZSwgdGhpcyk7XHJcblx0Ly9zaGllbGRcclxuXHR0aGlzLnBsYWNlU2hpZWxkS2V5ID0gdGhpcy5nYW1lLmlucHV0LmtleWJvYXJkLmFkZEtleShQaGFzZXIuS2V5Ym9hcmQuTyk7XHJcbiAgICB0aGlzLnBsYWNlU2hpZWxkS2V5Lm9uRG93bi5hZGQodGhpcy5hZGRTaGllbGQsIHRoaXMpO1xyXG5cdC8vdGhydXN0ZXJcclxuXHR0aGlzLnBsYWNlVGhydXN0ZXJLZXkgPSB0aGlzLmdhbWUuaW5wdXQua2V5Ym9hcmQuYWRkS2V5KFBoYXNlci5LZXlib2FyZC5JKTtcclxuICAgIHRoaXMucGxhY2VUaHJ1c3RlcktleS5vbkRvd24uYWRkKHRoaXMuYWRkVGhydXN0ZXIsIHRoaXMpO1xyXG5cdC8vc29sYXJQYW5uZWxcclxuXHR0aGlzLnBsYWNlU1BLZXkgPSB0aGlzLmdhbWUuaW5wdXQua2V5Ym9hcmQuYWRkS2V5KFBoYXNlci5LZXlib2FyZC5VKTtcclxuICAgIHRoaXMucGxhY2VTUEtleS5vbkRvd24uYWRkKHRoaXMuYWRkU1AsIHRoaXMpO1xyXG5cdC8vRU5EXHJcbiAgICBcclxuICAgIHRoaXMubW91c2VYID0gMDtcclxuICAgIHRoaXMubW91c2VZID0gMDtcclxuICAgIFxyXG4gICAgdGhpcy5pbnB1dC5vbkRvd24uYWRkKHRoaXMuY2xpY2ssIHRoaXMpO1xyXG4gICAgdGhpcy5pbnB1dC5vblVwLmFkZCh0aGlzLnJlbGVhc2UsIHRoaXMpO1xyXG4gICAgdGhpcy5pbnB1dC5hZGRNb3ZlQ2FsbGJhY2sodGhpcy5tb3ZlLCB0aGlzKTtcclxuICAgIHRoaXMuZ3JhYmJlZCA9IHVuZGVmaW5lZDtcclxuICAgIHRoaXMubGluZSA9IG5ldyBQaGFzZXIuTGluZSgwLCAwLCAwLCAwKTtcclxuICAgIFxyXG4gICAgdGhpcy5yb290U3Bhd25lZCA9IGZhbHNlO1xyXG4gICAgXHJcbiAgICB0aGlzLmRlYnVnTnVtID0gMDtcclxuICAgIHRoaXMubXlSb290ID0gdW5kZWZpbmVkO1xyXG4gIH0sXHJcblxyXG4gIHVwZGF0ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKHRoaXMuZ3JhYmJlZCkge1xyXG4gICAgICB2YXIgYW5nbGUgPSBNYXRoLmF0YW4yKHRoaXMuZ3JhYmJlZC5zcHJpdGUueSAtIHRoaXMuaW5wdXQucG9zaXRpb24ueSwgdGhpcy5ncmFiYmVkLnNwcml0ZS54IC0gdGhpcy5pbnB1dC5wb3NpdGlvbi54KSArIE1hdGguUEk7XHJcbiAgICAgIHZhciBkaXN0ID0gVXRpbHMuZGlzdGFuY2UodGhpcy5ncmFiYmVkLnNwcml0ZS54LCB0aGlzLmdyYWJiZWQuc3ByaXRlLnksIHRoaXMuaW5wdXQucG9zaXRpb24ueCwgdGhpcy5pbnB1dC5wb3NpdGlvbi55KTtcclxuICAgICAgdmFyIHdlaWdodCA9IDEwO1xyXG4gICAgICB0aGlzLmdyYWJiZWQuZm9yY2UueCA9IE1hdGguY29zKGFuZ2xlKSAqIGRpc3QgKiB3ZWlnaHQ7XHJcbiAgICAgIHRoaXMuZ3JhYmJlZC5mb3JjZS55ID0gTWF0aC5zaW4oYW5nbGUpICogZGlzdCAqIHdlaWdodDtcclxuICAgICAgdGhpcy5saW5lLnNldFRvKHRoaXMuZ3JhYmJlZC5zcHJpdGUueCwgdGhpcy5ncmFiYmVkLnNwcml0ZS55LCB0aGlzLmlucHV0LnBvc2l0aW9uLngsIHRoaXMuaW5wdXQucG9zaXRpb24ueSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgdGhpcy5saW5lLnNldFRvKDAsIDAsIDAsIDApO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgXHJcbiAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLmdhbWUuZGVidWcuZ2VvbSh0aGlzLmxpbmUpO1xyXG4gIH0sXHJcblxyXG4gIGNsaWNrOiBmdW5jdGlvbiAocG9pbnRlcikge1xyXG4gICAgdmFyIGJvZGllcyA9IHRoaXMuZ2FtZS5waHlzaWNzLnAyLmhpdFRlc3QocG9pbnRlci5wb3NpdGlvbik7XHJcbiAgICBpZiAoYm9kaWVzLmxlbmd0aClcclxuICAgIHtcclxuICAgICAgICB0aGlzLmdyYWJiZWQgPSBib2RpZXNbMF0ucGFyZW50O1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgXHJcbiAgcmVsZWFzZTogZnVuY3Rpb24gKCkge1xyXG4gICAgIGlmICh0aGlzLmdyYWJiZWQpIHtcclxuICAgICAgICB0aGlzLmdyYWJiZWQgPSB1bmRlZmluZWQ7XHJcbiAgICAgfVxyXG4gIH0sXHJcbiAgXHJcbiAgbW92ZTogZnVuY3Rpb24gKHBvaW50ZXIpIHtcclxuICAgIC8vIHAyIHVzZXMgZGlmZmVyZW50IGNvb3JkaW5hdGUgc3lzdGVtLCBzbyBjb252ZXJ0IHRoZSBwb2ludGVyIHBvc2l0aW9uIHRvIHAyJ3MgY29vcmRpbmF0ZSBzeXN0ZW1cclxuICAgIG1vdXNlQm9keS5wb3NpdGlvblswXSA9IHRoaXMuZ2FtZS5waHlzaWNzLnAyLnB4bWkocG9pbnRlci5wb3NpdGlvbi54KTtcclxuICAgIG1vdXNlQm9keS5wb3NpdGlvblsxXSA9IHRoaXMuZ2FtZS5waHlzaWNzLnAyLnB4bWkocG9pbnRlci5wb3NpdGlvbi55KTtcclxuICAgIHRoaXMubW91c2VYID0gcG9pbnRlci5wb3NpdGlvbi54O1xyXG4gICAgdGhpcy5tb3VzZVkgPSBwb2ludGVyLnBvc2l0aW9uLnk7XHJcbiAgfSxcclxuICBcclxuICAvL0RFQlVHIEZVTkNUSU9OUy0gZXZlbnQgZnVuY3Rpb25zIGNhbGxlZCBmcm9tIGxpc3RlbmVycyB0aGF0IGFsbG93IHlvdSB0byBjcmVhdGUgbW9kdWxlcyB3aXRoIGtleSBwcmVzc2VzXHJcbiAgYWRkQ29yZTogZnVuY3Rpb24gKCkge1xyXG5cdC8vQXR0ZW1wdHMgdG8gY3JlYXRlIG1vcmUgY29yZSBtb2R1bGVzIGhlcmUgd2lsbCBvbmx5IHJldHVybiB0aGUgZXhpc3RpbmcgY29yZVxyXG5cdHRoaXMubW9kdWxlQnVpbGRlci5idWlsZCgnY29yZScsIHRoaXMubW91c2VYLCB0aGlzLm1vdXNlWSk7XHJcbiAgfSxcclxuICBhZGRTaGllbGQ6IGZ1bmN0aW9uICgpIHtcclxuXHR0aGlzLm1vZHVsZUJ1aWxkZXIuYnVpbGQoJ3NoaWVsZCcsIHRoaXMubW91c2VYLCB0aGlzLm1vdXNlWSk7XHJcbiAgfSxcclxuICBhZGRUaHJ1c3RlcjogZnVuY3Rpb24gKCkge1xyXG5cdHRoaXMubW9kdWxlQnVpbGRlci5idWlsZCgndGhydXN0ZXInLCB0aGlzLm1vdXNlWCwgdGhpcy5tb3VzZVkpO1xyXG4gIH0sXHJcbiAgYWRkU1A6IGZ1bmN0aW9uICgpIHtcclxuXHR0aGlzLm1vZHVsZUJ1aWxkZXIuYnVpbGQoJ3NvbGFyUGFubmVsJywgdGhpcy5tb3VzZVgsIHRoaXMubW91c2VZKTtcclxuICB9LFxyXG4gIHBsYWNlQ3ViZTogZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGVudGl0eSA9IG5ldyBDdWJlKHRoaXMuZ2FtZSwgdGhpcy5tb3VzZVgsIHRoaXMubW91c2VZKTtcclxuICAgIHZhciBzY2FsZSA9IDAuNTtcclxuICAgIGVudGl0eS5uYW1lID0gdGhpcy5kZWJ1Z051bSsrO1xyXG4gICAgZW50aXR5LnNjYWxlLnggPSBzY2FsZTtcclxuICAgIGVudGl0eS5zY2FsZS55ID0gc2NhbGU7XHJcbiAgICBlbnRpdHkuYW5jaG9yLnNldFRvKDAuNSwgMC41KTtcclxuICAgIHRoaXMuZ2FtZS5waHlzaWNzLnAyLmVuYWJsZShlbnRpdHkpO1xyXG4gICAgZW50aXR5LmJvZHkub25CZWdpbkNvbnRhY3QuYWRkKGVudGl0eS5jdWJlQ29sbGlkZSwgZW50aXR5KTtcclxuICAgIGVudGl0eS5ib2R5LmRhbXBpbmcgPSAwLjk7XHJcbiAgICBlbnRpdHkuYm9keS5hbmd1bGFyRGFtcGluZyA9IDAuOTtcclxuICAgIGlmICghdGhpcy5yb290U3Bhd25lZCkge1xyXG4gICAgICAgZW50aXR5LnJvb3QgPSB0cnVlO1xyXG4gICAgICAgdGhpcy5yb290U3Bhd25lZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG4iLCJ2YXIgTWVudSA9IGZ1bmN0aW9uICgpIHtcclxuICB0aGlzLnRleHQgPSBudWxsO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBNZW51O1xyXG5cclxuTWVudS5wcm90b3R5cGUgPSB7XHJcblxyXG4gIGNyZWF0ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHggPSB0aGlzLmdhbWUud2lkdGggLyAyO1xyXG4gICAgdmFyIHkgPSB0aGlzLmdhbWUuaGVpZ2h0IC8gMjtcclxuXHJcbiAgICB2YXIgc3R5bGUgPSB7IGZvbnQ6ICc2NXB4IEFyaWFsJywgZmlsbDogJyNmZmZmZmYnLCBhbGlnbjogJ2NlbnRlcicgfTtcclxuXHJcbiAgICB0aGlzLnRleHQgPSB0aGlzLmFkZC50ZXh0KHggLSAzMDAsIHkgLSAyMDAsICdQcmVzcyB0byBTdGFydCcsIHN0eWxlKTtcclxuXHJcbiAgICB0aGlzLmlucHV0Lm9uRG93bi5hZGQodGhpcy5vbkRvd24sIHRoaXMpO1xyXG4gIH0sXHJcblxyXG4gIHVwZGF0ZTogZnVuY3Rpb24gKCkge1xyXG4gIH0sXHJcblxyXG4gIG9uRG93bjogZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy5nYW1lLnN0YXRlLnN0YXJ0KHBsYXllclN0YXRlLmN1cnJlbnRMZXZlbCk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxyXG4gIH1cclxufTtcclxuIiwidmFyIFByZWxvYWRlciA9IGZ1bmN0aW9uIChnYW1lKSB7XHJcbiAgZ2FtZSA9IG51bGw7XHJcbiAgdGhpcy5hc3NldCA9IG51bGw7XHJcbiAgdGhpcy5yZWFkeSA9IGZhbHNlO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQcmVsb2FkZXI7XHJcblxyXG5QcmVsb2FkZXIucHJvdG90eXBlID0ge1xyXG5cclxuICBwcmVsb2FkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLmFzc2V0ID0gdGhpcy5hZGQuc3ByaXRlKDMyMCwgMjQwLCAncHJlbG9hZGVyJyk7XHJcbiAgICB0aGlzLmFzc2V0LmFuY2hvci5zZXRUbygwLjUsIDAuNSk7XHJcblxyXG4gICAgdGhpcy5sb2FkLm9uTG9hZENvbXBsZXRlLmFkZE9uY2UodGhpcy5vbkxvYWRDb21wbGV0ZSwgdGhpcyk7XHJcbiAgICB0aGlzLmxvYWQuc2V0UHJlbG9hZFNwcml0ZSh0aGlzLmFzc2V0KTtcclxuICAgIHRoaXMubG9hZC5pbWFnZSgndGVzdHNwcml0ZScsICdhc3NldHMvdGVzdDIucG5nJyk7XHJcblx0dGhpcy5sb2FkLmltYWdlKCdjb3JlJywgJ2Fzc2V0cy9jb3JlLnBuZycpO1xyXG5cdHRoaXMubG9hZC5pbWFnZSgndGhydXN0ZXInLCAnYXNzZXRzL3RocnVzdGVyLnBuZycpO1xyXG5cdHRoaXMubG9hZC5pbWFnZSgnc2hpZWxkJywgJ2Fzc2V0cy9zaGllbGQucG5nJyk7XHJcblx0dGhpcy5sb2FkLmltYWdlKCdzb2xhclBhbm5lbCcsICdhc3NldHMvc29sYXJQYW5uZWwucG5nJyk7XHJcblx0XHJcbiAgICB0aGlzLmxvYWQucGh5c2ljcygnbW9kdWxlX3BoeXNpY3MnLCAnYXNzZXRzL21vZHVsZV9waHlzaWNzLmpzb24nKTtcclxuICB9LFxyXG5cclxuICBjcmVhdGU6IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMuYXNzZXQuY3JvcEVuYWJsZWQgPSBmYWxzZTtcclxuICB9LFxyXG5cclxuICB1cGRhdGU6IGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICghIXRoaXMucmVhZHkpIHtcclxuICAgICAgLy8gdGhpcy5nYW1lLnN0YXRlLnN0YXJ0KCdNZW51Jyk7XHJcbiAgICAgIHRoaXMuZ2FtZS5zdGF0ZS5zdGFydChwbGF5ZXJTdGF0ZS5jdXJyZW50TGV2ZWwpOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcclxuICAgIH1cclxuICB9LFxyXG5cclxuICBvbkxvYWRDb21wbGV0ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy5yZWFkeSA9IHRydWU7XHJcbiAgfVxyXG59O1xyXG4iLCJ2YXIgU3BsYXNoID0gZnVuY3Rpb24gKCkge1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTcGxhc2g7XHJcblxyXG5TcGxhc2gucHJvdG90eXBlID0ge1xyXG4gIGNyZWF0ZTogZnVuY3Rpb24gKCkge1xyXG4gIH1cclxufTsiLCIvKlxyXG5Db2xsZWN0aW9uIG9mIHV0aWxpdHkgZnVuY3Rpb25zLlxyXG4qL1xyXG5cclxudmFyIFV0aWxzID0ge1xyXG4gICAgY29udGFpbnNPYmplY3Q6IGZ1bmN0aW9uKG9iaiwgbGlzdCkge1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChsaXN0W2ldID09PSBvYmopIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9LFxyXG4gICAgZGlzdGFuY2U6IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyKSB7XHJcbiAgICAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHgxIC0geDIsIDIpICsgTWF0aC5wb3coeTEgLSB5MiwgMikpO1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBVdGlsczsiXX0=
