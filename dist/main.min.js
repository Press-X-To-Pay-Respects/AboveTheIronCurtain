(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"./src/js/main.js":[function(require,module,exports){
'use strict';

var game = new Phaser.Game(1280, 720, Phaser.AUTO, 'atic-game');

window.playerState = {
    currentLevel: 'Game'
};

game.state.add('Boot', require('./states/boot'));
game.state.add('Splash', require('./states/splash'));
game.state.add('Preloader', require('./states/preloader'));
game.state.add('Menu', require('./states/menu'));
game.state.add('Game', require('./states/game'));

game.state.start('Boot');
},{"./states/boot":"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\states\\boot.js","./states/game":"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\states\\game.js","./states/menu":"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\states\\menu.js","./states/preloader":"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\states\\preloader.js","./states/splash":"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\states\\splash.js"}],"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\effects\\BinaryParticle.js":[function(require,module,exports){
var BinaryParticle = function(game, targetObj, x, y, tarOffsetX, tarOffsetY) {
	var style = {font: '20px Avant Garde', fill: '#EEEE33', align: 'center'};
	var byteSymbol = Math.random() >= 0.5 ? '1' : '0';
	Phaser.Text.call(this, game, x, y, byteSymbol, style);
	game.add.existing(this);
	this.targetObj = targetObj;
	this.speed = 3.6;
	this.tarOffsetX = tarOffsetX;
	this.tarOffsetY = tarOffsetY;
	console.log('ran');
};

BinaryParticle.prototype = Object.create(Phaser.Text.prototype);
BinaryParticle.prototype.constructor = BinaryParticle;

BinaryParticle.prototype.update = function() {
	//Get delta vector to target object
	var delta = [this.targetObj.x + this.tarOffsetX - this.x, this.targetObj.y + this.tarOffsetY - this.y];
	//Get distance and check if we've reached target distance
	var dist = Math.sqrt(Math.pow(delta[0], 2) + Math.pow(delta[1], 2));
	if(dist <= this.speed) {
		this.destroy();
		return;
	}
	//Normalize delta vector
	delta = [delta[0]/dist, delta[1]/dist];
	//Update position
	this.x = this.x + this.speed*delta[0];
	this.y = this.y + this.speed*delta[1];
};

module.exports = BinaryParticle;
},{}],"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\effects\\Emitter.js":[function(require,module,exports){
var BinaryParticle = require('./BinaryParticle');

var Emitter = function(gameState) {
	this.gameState = gameState;
};

Emitter.prototype.constructor = Emitter;

Emitter.prototype.emitBinary = function (targetObj, x, y, spacing) {
	var offsetX = (Math.random()-0.5)*spacing;
	var offsetY = (Math.random()-0.5)*spacing;
	var newParticle = new BinaryParticle(this.gameState.game, targetObj, x, y, offsetX, offsetY);
};

module.exports = Emitter;
},{"./BinaryParticle":"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\effects\\BinaryParticle.js"}],"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\entities\\Hackable.js":[function(require,module,exports){
/*
Defines a hackable object.
*/

var Hackable = function (gameState, x, y, sprite, hackDistance) {
   Phaser.Sprite.call(this, gameState.game, x, y, sprite);
   gameState.game.add.existing(this);
	//store gameState
	this.gameState = gameState;
	//set isHacked to false
	this.isHacked = false;
	//add hackBar
	this.hackBar = gameState.uiBuilder.buildProgressBar('growing', 1500, 1200, 100, 10,  200);
	this.hackBar.hackable = this;
	this.hackBar.onEvent = function() {
		this.hackable.frame = 1;
		this.hackable.isHacked = true;
		this.destroy();
	};
	this.tag = 'neutralObj';	//Tag is used to identify object type during collision checking
	this.hackDistance = hackDistance;
	var scale = 0.5;
   this.scale.x = scale;
   this.scale.y = scale;
   this.anchor.setTo(0.5, 0.5);
   gameState.game.physics.p2.enable(this);
   this.body.onBeginContact.add(this.cubeCollide, this);
   this.body.damping = 0.9;
   this.body.angularDamping = 0.9;
};

Hackable.prototype = Object.create(Phaser.Sprite.prototype);
Hackable.prototype.constructor = Hackable;

/**
 * Automatically called by World.update
 */
Hackable.prototype.update = function() {
	this.hackBar.setLocation(this.x, this.y - 70);
	//check if getting hacked
	if(!this.isHacked) {
		if(this.gameState.player.hackerModules.length > 0) {
			var dist;
			var hacker;
			//Loop through all hacker modules on the player's cubsat
			for(var i = 0; i < this.gameState.player.hackerModules.length; i++) {
				hacker = this.gameState.player.hackerModules[i];
				dist = Math.sqrt( Math.pow(this.x - hacker.cube.x, 2) + Math.pow(this.y - hacker.cube.y, 2) );
				if(dist < this.hackDistance) {
					//If hacker is in range, increase hack value and try to emit binary particle
					this.hackBar.addValue(0.05);
					hacker.count++;
					if(hacker.count >= hacker.cycle) {
						hacker.count = 0;
						this.gameState.BinaryEmitter.emitBinary(this, hacker.cube.x, hacker.cube.y, 60);
					}
				}
			}
		}
	}
};


Hackable.prototype.cubeCollide = function(other) {
/*   if (this.group === undefined) {
      return;
   }
   this.group.handleCollision(this, other.sprite);*/
};

module.exports = Hackable;
},{}],"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\entities\\Module.js":[function(require,module,exports){
//Don't use this function to create modules, instead use moduleBuilder()
var Module = function(setType, setCube) {
	this.type = setType;
	this.cube = setCube;
   setCube.module = this;
};

Module.prototype.constructor = Module;

module.exports = Module;
},{}],"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\entities\\ModuleBuilder.js":[function(require,module,exports){
var Cube = require('./cube');
var Module = require('./Module');

var thrustAmt = 5000;

//Use this to create a moduleBuilder- only need to create one instance of it
var ModuleBuilder = function(setGameState, setColGroup) {
	//Ensure that cannot create multiple instances of this class
	if(ModuleBuilder.prototype.exists) {
		return ModuleBuilder.prototype.existingReference;
	}
		
	this.gameState = setGameState;
   this.colGroup = setColGroup;
	// this.coreExists = false;	//records if core has been created
	this.core = null;			//stores core when it is created
	//var space = this.gameState.input.keyboard.addKey(Phaser.Keyboard.SPACEBAR);
	ModuleBuilder.prototype.exists = true;
	ModuleBuilder.prototype.existingReference = this;
};

ModuleBuilder.prototype.constructor = ModuleBuilder;

//These var's help create the singleton functionality
ModuleBuilder.prototype.exists = false;
ModuleBuilder.prototype.existingReference = null;

/** Module functions **/
function solarPanelGiveTarget(target) {
   if (this.cube.group && target.cube.group && this.cube.group !== target.cube.group || this === target) {
      return;
   }
   var ourGroup = this.cube.group;
   var newConnection = {start: this.cube, end: target.cube};
   this.cube.myConnection = newConnection;
   target.cube.myConnection = newConnection;
   ourGroup.displayConnection(this.cube.myConnection);
}

function solarPanelMouseOver() {
   if (!this.cube.myConnection || !this.cube.group) {
      return;
   }
   this.cube.group.displayConnection(this.cube.myConnection);
}

function solarPanelOnRemove() {
   console.log('remove');
   if(this.cube.myConnection !== undefined) {
	this.cube.myConnection.end.myConnection = undefined;
	this.cube.myConnection = undefined;
   }
}

function beginThrust() {
   this.thrust = true;
   this.cube.frame = 1;
}

function endThrust() {
   this.thrust = false;
   this.cube.frame = 0;
}

function thrusterUpdate() {
   // console.log(this.thrust);
   if (this.thrust && this.cube.myConnection) {
      this.cube.body.force.x = thrustAmt * Math.cos(this.cube.rotation - Math.PI / 2);
      this.cube.body.force.y = thrustAmt * Math.sin(this.cube.rotation - Math.PI / 2);
	  if(this.cube.frame === 1) {
		this.cube.frame = 2;
	  }
	  else {
		this.cube.frame = 1;
	  }
   }
}

/** End module functions **/

//call this function from ModuleBuilder to construct modules
//TYPES: 'core' 'shield' 'thruster' 'solarPannel' 'hacker'
ModuleBuilder.prototype.build = function(type, x, y, forPlayer) {
	//Check if core has been created
	if(type === 'core' && this.coreExists) {
		//if so, return existing core b/c is singleton
		//b/c of this, can call ModuleBuilder.build('core') to access reference to existing core
		return this.core;
	}
	
	//Create cube object to be stored within module
	//Sprite names for modules are directly mapped to module names, so just pass 'type' as sprite name
	var newCube = new Cube(this.gameState.game, x, y, type);
    var scale = 0.5;
    newCube.name = this.gameState.debugNum++;
    newCube.scale.setTo(scale, scale);
    newCube.anchor.setTo(0.5, 0.5);
    this.gameState.game.physics.p2.enable(newCube);
    newCube.body.onBeginContact.add(newCube.cubeCollide, newCube);
	newCube.body.collideWorldBounds = false;
    newCube.body.damping = 0.9;
    newCube.body.angularDamping = 0.9;
    if (!this.gameState.rootSpawned) {
       newCube.root = true;
       this.gameState.rootSpawned = true;
    }

   var cIndicator = this.gameState.add.sprite(0, 0, 'connections', 'connection_line.png');
   cIndicator.anchor.setTo(0.5, 0.5);
   cIndicator.animations.add('end', ['connection_end.png'], 60, true);
   cIndicator.animations.add('line', ['connection_line.png'], 60, true);
   cIndicator.animations.add('right', ['connection_right.png'], 60, true);
   newCube.addChild(cIndicator);
   newCube.cIndicator = cIndicator;
   cIndicator.alpha = 0;
	
	//Create module to wrap around cube class
	var newModule = new Module(type, newCube);
		
	//TODO: edit special module atributes based on 'type'
	if(type === 'hacker') {
		newModule.cycle = 6;
		newModule.count = 0;
	}
	
	//Store module if it is core
	if(type === 'core')
	{
		newModule.cube.animations.add('core', [0,1,2], 20, true);
		newModule.cube.animations.play('core');
		this.core = newModule;
		this.coreExists = true;
	}
   // solar panel testing
   if (type === 'solarPanel') {
      newModule.giveTarget = solarPanelGiveTarget;
      newModule.mouseOver = solarPanelMouseOver;
      newModule.onRemove = solarPanelOnRemove;
   }
   
   //Thruster module events
	if(type === 'thruster') {
      if (forPlayer) {
         var space = this.gameState.input.keyboard.addKey(Phaser.Keyboard.SPACEBAR); 
         this.gameState.input.keyboard.addKeyCapture([space]);
         // space.onDown.add(applyThrust, newModule);
         space.onDown.add(beginThrust, newModule);
         space.onUp.add(endThrust, newModule);
      } else {
         // newModule.thrust = false;
         newModule.beginThrust = beginThrust;
         newModule.endThrust = endThrust;
      }
      newModule.update = thrusterUpdate;
	}
	//Return the module object
	return newModule;
};

module.exports = ModuleBuilder;
















},{"./Module":"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\entities\\Module.js","./cube":"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\entities\\cube.js"}],"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\entities\\cube.js":[function(require,module,exports){
/*
Defines a cube.
*/

var Cube = function (game, x, y, sprite) {
    Phaser.Sprite.call(this, game, x, y, sprite);
	 this.tag = 'module';	//tag is used to detect object type during collision checking
    this.game = game;
    this.game.add.existing(this);
    this.group = undefined;
    this.module = undefined;
    this.indicatorFade = 0.02;
    this.health = 3;
    this.constraints = [];
   this.ramCooldown = 500;
   this.ramDelay = 0;
};

Cube.prototype = Object.create(Phaser.Sprite.prototype);
Cube.prototype.constructor = Cube;

/**
 * Automatically called by World.update
 */
Cube.prototype.update = function() {
   if (this.cIndicator && this.cIndicator.alpha > 0) {
      this.cIndicator.alpha -= this.indicatorFade;
   }
   if (this.module.update) {
      this.module.update();
   }
   if (this.ramDelay > 0) {
      this.ramDelay -= this.game.time.elapsed;
   }
};

Cube.prototype.resetRamDelay = function() {
  this.ramDelay = this.ramCooldown; 
};

Cube.prototype.cubeCollide = function(other) {
   if (!this.group || !other || !other.sprite || other.sprite.key === 'asteroid') {
      return;
   }
	this.group.handleCollision(this, other.sprite);
	this.group.countCubes();
};

Cube.prototype.toString = function() {
   var string = '';
   string += this.concat('name', this.name);
   return string;
};

Cube.prototype.concat = function(string, val) {
   return string + ': ' + val + '\n';
};
Cube.prototype.displayIndicator = function() {
  this.cIndicator.alpha = 1; 
};

Cube.prototype.takeDamage = function(amt) {
   this.health -= amt;
   if (this.health <= 0) {
      this.group.destroyCube(this);
	  // this.group.countCubes();
   }
};

Cube.prototype.remove = function() {
   if (!this.group) {
      return;
   }
   this.group.remove(this);
};

module.exports = Cube;















},{}],"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\entities\\cube_group.js":[function(require,module,exports){
var Astar = require('../libs/javascript-astar/astar');
var EnemyAI = require('./enemy_ai');

/*
Defines a cube group.
*/

var CubeGroup = function (game, root) {
   this.game = game;
   this.root = root;
   this.cubes = [];
   var col = [];
   col.push(this.root);
   this.cubes.push(col);
   if (this.root) {
      this.root.group = this;
   }
   this.DIR = {NORTH: 0, EAST: 1, SOUTH: 2, WEST: 3};
   this.offset = 2;
	this.hackerModules = [];	//list of hacker modules in this group

   this.numCubes = 1;
   /*
   this.spawning = false;
   this.spawnGrid = [];
   this.spawnDelay = 100;
   this.curSpawnDelay = 0;
   this.spawnRow = 0;
   this.spawnCol = 0;
   */
};

CubeGroup.prototype.constructor = CubeGroup;

/**
 * Automatically called by World.update
 */
CubeGroup.prototype.update = function() {
   /*
   if (this.spawning) {
      if (this.spawnRow >= this.spawnGrid.length) {
         this.spawning = false;
      } else {
         if (this.spawnCol >= this.spawnGrid[this.spawnRow].length) {
            this.spawnRow++;
            this.spawnCol = 0;
         }
         if (this.curSpawnDelay > 0) {
            
         }
      }
   } else if (this.AI) {
      this.AI.update();
   }
   */
   if (this.AI) {
      this.AI.update();
   }
};

CubeGroup.prototype.call = function(fun) {
   for (var row = 0; row < this.cubesWidth(); row++) {
      for (var col = 0; col < this.cubesHeight(); col++) {
         var cube = this.cubes[row][col];
         if (cube && cube.hasOwnProperty(fun)) {
            // if cubes need functions called
         } else if (cube && cube.module && cube.module.hasOwnProperty(fun)) {
            var fn = cube.module[fun];
            if (typeof fn === 'function') {
               fn.call(cube.module);
            }
         }
      }
   }
};

CubeGroup.prototype.giveAI = function(type, player) {
   this.AI = new EnemyAI(this.game, this, type, player);
};

CubeGroup.prototype.add = function(cube, point) {
  if (!this.root && cube.module.type === 'core') {
     this.root = cube;
  }
  cube.group = this;
  this.set(cube, point);
  this.createConstraints(cube, point);
  // this.displayCubes();
};

/*
CubeGroup.prototype.addOverTime = function(grid) {
   this.spawning = true;
   this.spawnGrid = grid;
   this.spawnRow = 0;
   this.spawnCol = 0;
};
*/

CubeGroup.prototype.handleCollision = function(origin, other) {
   // stop if other does not exist, either is not a cube, both are in same group
	if (other === null || origin.prototype !== other.prototype || origin.group === other.group || other.tag != 'module') {
		return;
	}
   if (other.group && other.group !== this && origin.ramDelay <= 0) {
      // console.log(origin.name, 'ramming damage!');
      other.takeDamage(1);
      origin.resetRamDelay();
   } else if (!other.group && this.isPlayer) {		
		//Check if one of these two is a hacker module, if so add it to the other's hackerModules list
	   if(!origin.group) {
			if(origin.module.type == 'hacker') {
				other.group.hackerModules.push(origin.module);
			}
		}
		if(!other.group) {
			if(other.module.type == 'hacker') {
				origin.group.hackerModules.push(other.module);
			}
		}
		var relSide = this.relativeSide(origin.body, other.body);
		var originLoc = this.find(origin);
		var otherLoc = this.adjust(originLoc, relSide);
		this.set(other, otherLoc);
		otherLoc = this.find(other); // update position since set can shift grid
		if (!otherLoc) {
			// console.log('handle collision failed to find position for good applicant');
			return;
      }
      this.createConstraints(other, otherLoc);
      // console.log(other.body.collidesWith);
      // this.displayCubes();
   }
};

CubeGroup.prototype.createConstraints = function(me, point) {
   // this.displayCubes();
   var myNorth = this.get(this.adjust(point, this.DIR.NORTH));
   var myEast = this.get(this.adjust(point, this.DIR.EAST));
   var mySouth = this.get(this.adjust(point, this.DIR.SOUTH));
   var myWest = this.get(this.adjust(point, this.DIR.WEST));
   var constraint;
   if (myNorth) {
      constraint = this.game.physics.p2.createLockConstraint(me.body, myNorth.body, [0, me.width + this.offset]); // me - north
      me.constraints.push(constraint);
      myNorth.constraints.push(constraint);
   }
   if (myEast) {
      constraint = this.game.physics.p2.createLockConstraint(me.body, myEast.body, [-me.width - this.offset, 0]); // me - east
      me.constraints.push(constraint);
      myEast.constraints.push(constraint);
   }
   if (mySouth) {
      constraint = this.game.physics.p2.createLockConstraint(mySouth.body, me.body, [0, me.width + this.offset]); // south - me
      me.constraints.push(constraint);
      mySouth.constraints.push(constraint);
   }
   if (myWest) {
      constraint = this.game.physics.p2.createLockConstraint(myWest.body, me.body, [-me.width - this.offset, 0]); // west - me
      me.constraints.push(constraint);
      myWest.constraints.push(constraint);
   }
};

CubeGroup.prototype.relativeSide = function(thisBody, otherBody) {
  var thisPoint = new Phaser.Point(thisBody.x, thisBody.y);
  var otherPoint = new Phaser.Point(otherBody.x, otherBody.y);
  var angleToOther = Phaser.Point.angle(thisPoint, otherPoint);
  if (angleToOther < 0) { // fix dumb part of Phaser.Point.angle()
     angleToOther = 2 * Math.PI + angleToOther;
  }
  angleToOther = (angleToOther + 3/2 * Math.PI) % (2 * Math.PI); // rotate 90 d clockwise
  var diffAngle = Math.abs(Math.abs(angleToOther) - Math.abs(thisBody.rotation));
   if (diffAngle < 1 / 4 * Math.PI || diffAngle > 7 / 4 * Math.PI) { // north
     return this.DIR.NORTH;
  } else if (diffAngle >= 1 / 4 * Math.PI && diffAngle < 3 / 4 * Math.PI) { // east
     return this.DIR.EAST;
  } else if (diffAngle >= 3 / 4 * Math.PI && diffAngle < 5 / 4 * Math.PI) { // south
     return this.DIR.SOUTH;
  } else if (diffAngle >= 5 / 4 * Math.PI && diffAngle < 7 / 4 * Math.PI) { // west
     return this.DIR.WEST;
  }
};

/*
CubeGroup.prototype.setRotation = function(rotation) {
   for (var row = 0; row < this.cubesWidth(); row++) {
      for (var col = 0; col < this.cubesHeight(); col++) {
         this.cubes[row][col].body.rotation = rotation;
      }
   }
   this.root.body.rotation = rotation;
};
*/

CubeGroup.prototype.find = function(cube) {
   for (var row = 0; row < this.cubesWidth(); row++) {
      for (var col = 0; col < this.cubesHeight(); col++) {
         if (this.cubes[row][col] === cube) {
            return new Phaser.Point(row, col);
         }
      }
   }
   return undefined;
};

CubeGroup.prototype.get = function(point) {
  if (!point || this.outOfBounds(point)) {
      return;
  }
  return this.cubes[point.x][point.y];
};

CubeGroup.prototype.cubesWidth = function() {
   return this.cubes.length;
};

CubeGroup.prototype.cubesHeight = function() {
   return this.cubes[0].length;
};

CubeGroup.prototype.addTopRow = function() {
   for (var row = 0; row < this.cubesWidth(); row++) {
      this.cubes[row].push(undefined);
   }
};

CubeGroup.prototype.addRightCol = function() {
   var newCol = [];
   for (var i = 0; i < this.cubesHeight(); i++) {
      newCol.push(undefined);
   }
   this.cubes.push(newCol);
};

CubeGroup.prototype.addBotRow = function() {
   for (var row = 0; row < this.cubesWidth(); row++) {
      this.cubes[row].unshift(undefined);
   }
};

CubeGroup.prototype.addLeftCol = function() {
   var newCol = new Array(this.cubesHeight());
   this.cubes.unshift(newCol);
};

CubeGroup.prototype.getCube = function(point) {
   if (!point || this.outOfBounds(point)) {
      return undefined;
   }
   return this.cubes[point.x][point.y];
};

CubeGroup.prototype.adjust = function(point, dir) {
  if (!point) {
     return;
  }
  var newPoint = new Phaser.Point(point.x, point.y);
  switch (dir) {
      case this.DIR.NORTH:
      newPoint.y++;
      break;
      case this.DIR.EAST:
      newPoint.x++;
      break;
      case this.DIR.SOUTH:
      newPoint.y--;
      break;
      case this.DIR.WEST:
      newPoint.x--;
      break;
   }
   return newPoint;
};

CubeGroup.prototype.set = function(cube, point) {
   if (!point) {
      console.log('set given undefined point');
      return;
   }
   if (point.x < 0) {
      this.addLeftCol();
      point.x = 0;
   } else if (point.x >= this.cubesWidth()) {
      this.addRightCol();
      point.x = this.cubesWidth() - 1;
   } else if (point.y < 0) {
      this.addBotRow();
      point.y = 0;
   } else if (point.y >= this.cubesHeight()) {
      this.addTopRow();
      point.y = this.cubesHeight() - 1;
   }
   if (this.get(point)) {
      // console.log('tried to set to filled position');
      return;
   }
   this.cubes[point.x][point.y] = cube;
   cube.group = this;
};

CubeGroup.prototype.outOfBounds = function(point) {
   if (!point) {
      console.log('out of bounds given undefined point');
      return;
   }
   if (point.x < 0 || point.x >= this.cubesWidth() || point.y < 0 || point.y >= this.cubesHeight()) {
      return true;
   }
   return false;
};

CubeGroup.prototype.displayCubes = function() {
   console.log('================');
   var output = 'Display Cubes\n';
   var row = 0;
   var col = this.cubesHeight() - 1;
   while (col >= 0) {
      while (row < this.cubesWidth()) {
         var cube = this.cubes[row][col];
         if (cube) {
            output += '# ';
         } else {
            output += '_ ';
         }
         row++;
      }
      row = 0;
      col--;
      output += '\n';
   }
   console.log(output);
   console.log('---------------');
};

CubeGroup.prototype.displayConnection = function(connection) {
   var graph = new Astar.Graph(this.cubesToGraph());
   var startPoint = this.find(connection.start);
   var endPoint = this.find(connection.end);
   if (!startPoint || !endPoint) {
      console.log('displayConnection failed to get points');
      return;
   }
   var start = graph.grid[startPoint.x][startPoint.y];
   var end = graph.grid[endPoint.x][endPoint.y];
   var result = Astar.astar.search(graph, start, end);
   result.unshift(start);
   var previous;
   for(var i = 0; i < result.length; i++) {
      var curPoint = new Phaser.Point(result[i].x, result[i].y);
      var cur = this.get(curPoint);
      var indicator = cur.cIndicator;
      var dir;
      var prevPoint;
      var nextPoint;
      if (!previous) {
         indicator.animations.play('end');
         nextPoint = new Phaser.Point(result[i+1].x, result[i+1].y);
         dir = this.dirBetween(curPoint, nextPoint);
         indicator.rotation = this.dirToAngle(dir);
      } else if (i === result.length - 1) {
         indicator.animations.play('end');
         prevPoint = new Phaser.Point(previous.x, previous.y);
         dir = this.dirBetween(curPoint, prevPoint);
         indicator.rotation = this.dirToAngle(dir);
      } else {
         indicator.animations.play('line');
         prevPoint = new Phaser.Point(previous.x, previous.y);
         var prevDir = this.dirBetween(curPoint, prevPoint);
         nextPoint = new Phaser.Point(result[i+1].x, result[i+1].y);
         var nextDir = this.dirBetween(curPoint, nextPoint);
         this.manageIndicator(indicator, prevDir, nextDir);
      }
      previous = result[i];
      cur.displayIndicator();
    }
};

CubeGroup.prototype.manageIndicator = function(indicator, prevDir, nextDir) {
  indicator.scale.setTo(Math.abs(indicator.scale.x), indicator.scale.y);
  if (prevDir === this.DIR.NORTH && nextDir === this.DIR.SOUTH) { // 2
      indicator.rotation = Math.PI;
   } else if (prevDir === this.DIR.SOUTH && nextDir === this.DIR.NORTH) { // 1
      indicator.rotation = 0;
   } else if (prevDir === this.DIR.EAST && nextDir === this.DIR.WEST) { // 4
      indicator.rotation = 1 / 2 * Math.PI;
   } else if (prevDir === this.DIR.WEST && nextDir === this.DIR.EAST) { // 3
      indicator.rotation = 3 / 2  * Math.PI;
   } else {
      indicator.animations.play('right');
      if (prevDir === this.DIR.SOUTH && nextDir === this.DIR.EAST) { // 5
         indicator.rotation = 0;
      } else if (prevDir === this.DIR.WEST && nextDir === this.DIR.SOUTH) { // 6
         indicator.rotation = 1 / 2 * Math.PI;
      } else if (prevDir === this.DIR.NORTH && nextDir === this.DIR.WEST) { // 7
         indicator.rotation = Math.PI;
      } else if (prevDir === this.DIR.EAST && nextDir === this.DIR.NORTH) { // 8
         indicator.rotation = 3 / 2 * Math.PI;
      } else {
         indicator.scale.setTo(-Math.abs(indicator.scale.x), indicator.scale.y);
         if (prevDir === this.DIR.SOUTH && nextDir === this.DIR.WEST) { // 9
            indicator.rotation = 0;
         } else if (prevDir === this.DIR.WEST && nextDir === this.DIR.NORTH) { // 10
            indicator.rotation = 1 / 2 * Math.PI;
         } else if (prevDir === this.DIR.NORTH && nextDir === this.DIR.EAST) { // 11
            indicator.rotation = Math.PI;
         } else if (prevDir === this.DIR.EAST && nextDir === this.DIR.SOUTH) { // 12
            indicator.rotation = 3 / 2 * Math.PI;
         }
      }
   } 
};

CubeGroup.prototype.cubesToGraph = function() {
  var graph = [];
  for (var row = 0; row < this.cubesWidth(); row++) {
     var newCol = [];
      for (var col = 0; col < this.cubesHeight(); col++) {
         if (this.cubes[row][col]) {
            newCol.push(1);
         } else {
            newCol.push(0);
         }
      }
      graph.push(newCol);
   }
   return graph;
};

CubeGroup.prototype.dirBetween = function(a, b) {
   var deltaX = a.x - b.x;
   var deltaY = a.y - b.y;
   if (deltaX > 0) {
      return this.DIR.WEST;
   }
   if (deltaX < 0) {
      return this.DIR.EAST;
   }
   if (deltaY > 0) {
      return this.DIR.SOUTH;
   }
   if (deltaY < 0) {
      return this.DIR.NORTH;
   }
   return this.DIR.NORTH;
};

CubeGroup.prototype.dirToAngle = function(dir) {
  switch (dir) {
   case this.DIR.NORTH:
   return Math.PI;
   case this.DIR.EAST:
   return 3 / 2 * Math.PI;
   case this.DIR.SOUTH:
   return 0;
   case this.DIR.WEST:
   return 1 / 2 * Math.PI;
  }  
};

CubeGroup.prototype.destroyCube = function(cube) {
  // console.log('destroyCube');
  var loc = this.find(cube);
  if (!loc) {
     console.log('attempt to destroy cube not in group');
     return;
  }
  // remove cube from group
  this.remove(cube);
  // destroy cube
  cube.kill(true);
};

CubeGroup.prototype.remove = function(cube) {
   // console.log('remove');
   if (this.root === cube) {
      return;
   }
   // remove cube from array
   var row, col;
   for (row = 0; row < this.cubesWidth(); row++) {
      for (col = 0; col < this.cubesHeight(); col++) {
         if (this.cubes[row][col] === cube) {
            // this.cubes[row][col].group = undefined;
            this.cubes[row][col] = undefined;
            break;
         }
      }
   }
   // remove constraints from cube
   this.removeConstraints(cube);
   cube.group = undefined;
   if (cube.module && cube.module.hasOwnProperty('onRemove')) {
      cube.module.onRemove();
   }
   // test for exiles
   for (row = 0; row < this.cubesWidth(); row++) {
      for (col = 0; col < this.cubesHeight(); col++) {
         var exile = this.cubes[row][col];
         if (exile && this.isExile(exile)) {
            this.remove(exile);
         }
      }
   }
   // this.displayCubes();
};

CubeGroup.prototype.removeNeighborsConstraint = function(constraint, cube) {
   // console.log('removeNeighborsConstraint');
   var neighbors = this.getNeighbors(cube);
   for (var i = 0; i < neighbors.length; i++) {
      var neighbor = neighbors[i];
      for (var j = 0; j < neighbor.constraints.length; j++) {
         if (neighbor.constraints[j] === constraint) {
            neighbor.constraints.splice(j, 1);
         }
      }
   }
};

CubeGroup.prototype.getNeighbors = function(cube) {
   var loc = this.find(cube);
   var north = this.get(this.adjust(loc, this.DIR.NORTH));
   var east = this.get(this.adjust(loc, this.DIR.EAST));
   var south = this.get(this.adjust(loc, this.DIR.SOUTH));
   var west = this.get(this.adjust(loc, this.DIR.WEST));
   var neighbors = [];
   if (north) {
      neighbors.push(north);
   }
   if (east) {
      neighbors.push(east);
   }
   if (south) {
      neighbors.push(south);
   }
   if (west) {
      neighbors.push(west);
   }
   return neighbors;
};

CubeGroup.prototype.removeConstraints = function(cube) {
   // console.log('removeConstraints');
   while (cube.constraints.length > 0) {
      this.removeNeighborsConstraint(cube.constraints[0], cube);
      this.game.physics.p2.removeConstraint(cube.constraints[0]);
      cube.constraints.splice(0, 1);
   }
};

// only used to test Astar
CubeGroup.prototype.testPath = function() {
  var graph = new Astar.Graph([
        [1,1,1,1],
        [0,1,1,0],
        [0,0,0,1]
    ]);
   var start = graph.grid[0][0];
   var end = graph.grid[2][3];
   var result = Astar.astar.search(graph, start, end);
   result.unshift(start);
   for(var i = 0; i < result.length; i++) {
      console.log(result[i].x, result[i].y);
    } 
};

CubeGroup.prototype.isExile = function(cube) {
   if (cube === this.root) {
      return;
   }
   var graph = new Astar.Graph(this.cubesToGraph());
   var startPoint = this.find(this.root);
   var endPoint = this.find(cube);
   var start = graph.grid[startPoint.x][startPoint.y];
   var end = graph.grid[endPoint.x][endPoint.y];
   var result = Astar.astar.search(graph, start, end);
   // if no path is found, the cube is an exile
   if (result.length === 0) {
      return true;
   }
   return false;
};

CubeGroup.prototype.countCubes = function() {
	var row, col;
	var num  = 0;
	for (row = 0; row < this.cubesWidth(); row++) {
		for (col = 0; col < this.cubesHeight(); col++) {
			if (this.cubes[row][col] !== undefined) {
				num++;
			}
		}
	}
	//console.log(num);
	this.numCubes = num;
};

module.exports = CubeGroup;

















},{"../libs/javascript-astar/astar":"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\libs\\javascript-astar\\astar.js","./enemy_ai":"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\entities\\enemy_ai.js"}],"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\entities\\enemy_ai.js":[function(require,module,exports){
var Utils = require('../utils.js');

var EnemyAI = function(game, group, type, playerGroup) {
   this.game = game;
   this.group = group;
   this.type = type;
   this.playerGroup = playerGroup;
   this.player = this.playerGroup.root;
   this.ramDist = 500;
   this.rotationForce = 50;
   this.facingAllowance = Math.PI / 20;
   this.thrustersFiring = false;
   switch (this.type) {
      case 'ram':
      this.allocateToThrusters();
      break;
   }
};

EnemyAI.prototype.constructor = EnemyAI;

EnemyAI.prototype.update = function() {
   switch (this.type) {
      case 'ram':
      this.ramUpdate();
      break;
   }
};

EnemyAI.prototype.ramUpdate = function() {
   if (!this.group.root) {
      return;
   }
   var root = this.group.root;
   var myPos = new Phaser.Point(root.x, root.y);
   var playerPos = new Phaser.Point(this.player.x, this.player.y);
   var dist = Utils.distance(myPos.x, myPos.y, playerPos.x, playerPos.y);
   if (dist <= this.ramDist) {
      var angleTo = this.angleTo(myPos, playerPos);
      var diffAngle = angleTo - root.body.rotation;
      if (diffAngle > 0) {
         root.body.angularForce = this.rotationForce;
      } else {
         root.body.angularForce = -this.rotationForce;
      }
      if (Math.abs(diffAngle) <= this.facingAllowance && !this.thrustersFiring) {
         this.group.call('beginThrust');
         this.thrustersFiring = true;
         this.allocateToThrusters();
      } else if (Math.abs(diffAngle) > this.facingAllowance && this.thrustersFiring){
         this.group.call('endThrust');
         this.thrustersFiring = false;
      }
   }
};

EnemyAI.prototype.allocateToThrusters = function() {
   var panels = [];
   var thrusters = [];
   for (var row = 0; row < this.group.cubesWidth(); row++) {
      for (var col = 0; col < this.group.cubesHeight(); col++) {
         var cube = this.group.cubes[row][col];
         if (cube && cube.module) {
            if (cube.module.type === 'solarPanel' && !cube.myConnection) {
               panels.push(cube.module);
            } else if (cube.module.type === 'thruster' && !cube.myConnection) {
               thrusters.push(cube.module);
            }
         }
      }
   }
   var i = 0;
   while (i < thrusters.length && i < panels.length) {
      var tarPanel = panels[i];
      var tarThruster = thrusters[i];
      var newConnection = {start: tarPanel.cube, end: tarThruster.cube};
      tarPanel.cube.myConnection = newConnection;
      tarThruster.cube.myConnection = newConnection;
      this.group.displayConnection(tarPanel.cube.myConnection);
      i++;
   }
};

EnemyAI.prototype.angleTo = function(from, to) {
  var angleToOther = Phaser.Point.angle(from, to);
  if (angleToOther < 0) { // fix dumb part of Phaser.Point.angle()
     angleToOther = 2 * Math.PI + angleToOther;
  }
  angleToOther = (angleToOther + 3/2 * Math.PI) % (2 * Math.PI); // rotate 90 d clockwise
  return angleToOther;
};

module.exports = EnemyAI;











},{"../utils.js":"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\utils.js"}],"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\entities\\mouse.js":[function(require,module,exports){
var Utils = require('../utils.js');

var Mouse = function(game, input) {
   this.game = game;
   this.input = input;
	this.body = new p2.Body(); // jshint ignore:line
   this.game.physics.p2.world.addBody(this.body);
   // this.game.physics.p2.enable(this);
   
   this.input.onDown.add(this.click, this);
   this.input.onUp.add(this.release, this);
   this.input.addMoveCallback(this.move, this);
   this.x = 0;
   this.y = 0;
   
   this.grabbed = undefined;
   this.lastClicked = undefined;
   this.line = new Phaser.Line(0, 0, 0, 0);
   
   this.removeThreshold = 400; // time in milliseconds
   this.removeTime = 0; // time till threshold
};

Mouse.prototype.constructor = Mouse;

Mouse.prototype.update = function() {
   if (this.grabbed) {
      var angle = Math.atan2(this.grabbed.sprite.y - (this.input.position.y + this.game.camera.y), this.grabbed.sprite.x - (this.input.position.x+ this.game.camera.x)) + Math.PI;
      var dist = Utils.distance(this.grabbed.sprite.x, this.grabbed.sprite.y, (this.input.position.x+ this.game.camera.x), (this.input.position.y + this.game.camera.y));
      var weight = 10;
      this.grabbed.force.x = Math.cos(angle) * dist * weight;
      this.grabbed.force.y = Math.sin(angle) * dist * weight;
      this.line.setTo(this.grabbed.sprite.x, this.grabbed.sprite.y, (this.input.position.x+ this.game.camera.x), (this.input.position.y + this.game.camera.y));
      this.removeTime += this.game.time.elapsed;
      if(this.grabbed.sprite.tag === 'module') {
		  if (this.removeTime >= this.removeThreshold && this.grabbed.sprite.key !== 'asteroid') {
			 this.grabbed.sprite.remove();
			 this.removeTime = 0;
		  }
	  }
    } else {
       this.line.setTo(0, 0, 0, 0);
    }
    var point = new Phaser.Point(this.x, this.y);
    var bodies = this.game.physics.p2.hitTest(point);
    if (bodies.length)
    {
        var hover = bodies[0].parent;
        if (hover.sprite.module && hover.sprite.module.mouseOver) {
           hover.sprite.module.mouseOver();
        }
    }
};

Mouse.prototype.click = function(pointer) {
   var point = new Phaser.Point(pointer.x + this.game.camera.x, pointer.y + this.game.camera.y);
   var bodies = this.game.physics.p2.hitTest(point);
   if (bodies.length)
   {
     this.removeTime = 0;
     this.grabbed = bodies[0].parent;
     // console.log(this.grabbed.sprite.name);
     if (this.grabbed.sprite.module && this.grabbed.sprite.module.hasOwnProperty('mouseDown')) {
        this.grabbed.sprite.module.mouseDown();
     }
     if (this.lastClicked && this.lastClicked.sprite && this.lastClicked.sprite.module &&
     this.lastClicked.sprite.module.giveTarget) {
        this.lastClicked.sprite.module.giveTarget(this.grabbed.sprite.module);
     }
     this.lastClicked = bodies[0].parent;
   }
};
  
 Mouse.prototype.release = function() {
   if (this.grabbed) {
     this.grabbed = undefined;
   }
};
  
Mouse.prototype.move = function(pointer) {
   // p2 uses different coordinate system, so convert the pointer position to p2's coordinate system
   this.body.position[0] = this.game.physics.p2.pxmi(pointer.position.x);
   this.body.position[1] = this.game.physics.p2.pxmi(pointer.position.y);
   this.x = pointer.position.x + this.game.camera.x;
   this.y = pointer.position.y + this.game.camera.y;
};

Mouse.prototype.render = function() {
   this.game.debug.geom(this.line);
};

module.exports = Mouse;















},{"../utils.js":"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\utils.js"}],"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\functionAccess\\Renderables.js":[function(require,module,exports){
var Renderables = function() {
	if(Renderables.prototype.exists) {
		return Renderables.prototype.existingReference;
	}
	
	this.list = [];
	Renderables.prototype.exists = true;
	Renderables.prototype.existingReference = this;
};

Renderables.prototype.constructor = Renderables;
//These var's help create the singleton functionality
Renderables.prototype.exists = false;
Renderables.prototype.existingReference = null;

Renderables.prototype.subscribe = function(subscriber) {
	this.list.push(subscriber);
};

Renderables.prototype.unsubscribe = function(unsubscriber) {
	for(var i = 0; i < this.list.length; i++) {
		if(this.list[i] === unsubscriber) {
			this.list[i] = false;
		}
	}
};

Renderables.prototype.renderAll = function() {
	for(var i = 0; i < this.list.length; i++) {
		if(this.list[i] === false) {
			continue;
		}
		this.list[i].render();
	}
};

module.exports = Renderables;
},{}],"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\libs\\javascript-astar\\astar.js":[function(require,module,exports){
// javascript-astar 0.4.0
// http://github.com/bgrins/javascript-astar
// Freely distributable under the MIT License.
// Implements the astar search algorithm in javascript using a Binary Heap.
// Includes Binary Heap (with modifications) from Marijn Haverbeke.
// http://eloquentjavascript.net/appendix2.html

(function(definition) {
    /* global module, define */
    if(typeof module === 'object' && typeof module.exports === 'object') {
        module.exports = definition();
    } else if(typeof define === 'function' && define.amd) {
        define([], definition);
    } else {
        var exports = definition();
        window.astar = exports.astar;
        window.Graph = exports.Graph;
    }
})(function() {

function pathTo(node){
    var curr = node,
        path = [];
    while(curr.parent) {
        path.push(curr);
        curr = curr.parent;
    }
    return path.reverse();
}

function getHeap() {
    return new BinaryHeap(function(node) {
        return node.f;
    });
}

var astar = {
    /**
    * Perform an A* Search on a graph given a start and end node.
    * @param {Graph} graph
    * @param {GridNode} start
    * @param {GridNode} end
    * @param {Object} [options]
    * @param {bool} [options.closest] Specifies whether to return the
               path to the closest node if the target is unreachable.
    * @param {Function} [options.heuristic] Heuristic function (see
    *          astar.heuristics).
    */
    search: function(graph, start, end, options) {
        graph.cleanDirty();
        options = options || {};
        var heuristic = options.heuristic || astar.heuristics.manhattan,
            closest = options.closest || false;

        var openHeap = getHeap(),
            closestNode = start; // set the start node to be the closest if required

        start.h = heuristic(start, end);

        openHeap.push(start);

        while(openHeap.size() > 0) {

            // Grab the lowest f(x) to process next.  Heap keeps this sorted for us.
            var currentNode = openHeap.pop();

            // End case -- result has been found, return the traced path.
            if(currentNode === end) {
                return pathTo(currentNode);
            }

            // Normal case -- move currentNode from open to closed, process each of its neighbors.
            currentNode.closed = true;

            // Find all neighbors for the current node.
            var neighbors = graph.neighbors(currentNode);

            for (var i = 0, il = neighbors.length; i < il; ++i) {
                var neighbor = neighbors[i];

                if (neighbor.closed || neighbor.isWall()) {
                    // Not a valid node to process, skip to next neighbor.
                    continue;
                }

                // The g score is the shortest distance from start to current node.
                // We need to check if the path we have arrived at this neighbor is the shortest one we have seen yet.
                var gScore = currentNode.g + neighbor.getCost(currentNode),
                    beenVisited = neighbor.visited;

                if (!beenVisited || gScore < neighbor.g) {

                    // Found an optimal (so far) path to this node.  Take score for node to see how good it is.
                    neighbor.visited = true;
                    neighbor.parent = currentNode;
                    neighbor.h = neighbor.h || heuristic(neighbor, end);
                    neighbor.g = gScore;
                    neighbor.f = neighbor.g + neighbor.h;
                    graph.markDirty(neighbor);
                    if (closest) {
                        // If the neighbour is closer than the current closestNode or if it's equally close but has
                        // a cheaper path than the current closest node then it becomes the closest node
                        if (neighbor.h < closestNode.h || (neighbor.h === closestNode.h && neighbor.g < closestNode.g)) {
                            closestNode = neighbor;
                        }
                    }

                    if (!beenVisited) {
                        // Pushing to heap will put it in proper place based on the 'f' value.
                        openHeap.push(neighbor);
                    }
                    else {
                        // Already seen the node, but since it has been rescored we need to reorder it in the heap
                        openHeap.rescoreElement(neighbor);
                    }
                }
            }
        }

        if (closest) {
            return pathTo(closestNode);
        }

        // No result was found - empty array signifies failure to find path.
        return [];
    },
    // See list of heuristics: http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html
    heuristics: {
        manhattan: function(pos0, pos1) {
            var d1 = Math.abs(pos1.x - pos0.x);
            var d2 = Math.abs(pos1.y - pos0.y);
            return d1 + d2;
        },
        diagonal: function(pos0, pos1) {
            var D = 1;
            var D2 = Math.sqrt(2);
            var d1 = Math.abs(pos1.x - pos0.x);
            var d2 = Math.abs(pos1.y - pos0.y);
            return (D * (d1 + d2)) + ((D2 - (2 * D)) * Math.min(d1, d2));
        }
    },
    cleanNode:function(node){
        node.f = 0;
        node.g = 0;
        node.h = 0;
        node.visited = false;
        node.closed = false;
        node.parent = null;
    }
};

/**
* A graph memory structure
* @param {Array} gridIn 2D array of input weights
* @param {Object} [options]
* @param {bool} [options.diagonal] Specifies whether diagonal moves are allowed
*/
function Graph(gridIn, options) {
    options = options || {};
    this.nodes = [];
    this.diagonal = !!options.diagonal;
    this.grid = [];
    for (var x = 0; x < gridIn.length; x++) {
        this.grid[x] = [];

        for (var y = 0, row = gridIn[x]; y < row.length; y++) {
            var node = new GridNode(x, y, row[y]);
            this.grid[x][y] = node;
            this.nodes.push(node);
        }
    }
    this.init();
}

Graph.prototype.init = function() {
    this.dirtyNodes = [];
    for (var i = 0; i < this.nodes.length; i++) {
        astar.cleanNode(this.nodes[i]);
    }
};

Graph.prototype.cleanDirty = function() {
    for (var i = 0; i < this.dirtyNodes.length; i++) {
        astar.cleanNode(this.dirtyNodes[i]);
    }
    this.dirtyNodes = [];
};

Graph.prototype.markDirty = function(node) {
    this.dirtyNodes.push(node);
};

Graph.prototype.neighbors = function(node) {
    var ret = [],
        x = node.x,
        y = node.y,
        grid = this.grid;

    // West
    if(grid[x-1] && grid[x-1][y]) {
        ret.push(grid[x-1][y]);
    }

    // East
    if(grid[x+1] && grid[x+1][y]) {
        ret.push(grid[x+1][y]);
    }

    // South
    if(grid[x] && grid[x][y-1]) {
        ret.push(grid[x][y-1]);
    }

    // North
    if(grid[x] && grid[x][y+1]) {
        ret.push(grid[x][y+1]);
    }

    if (this.diagonal) {
        // Southwest
        if(grid[x-1] && grid[x-1][y-1]) {
            ret.push(grid[x-1][y-1]);
        }

        // Southeast
        if(grid[x+1] && grid[x+1][y-1]) {
            ret.push(grid[x+1][y-1]);
        }

        // Northwest
        if(grid[x-1] && grid[x-1][y+1]) {
            ret.push(grid[x-1][y+1]);
        }

        // Northeast
        if(grid[x+1] && grid[x+1][y+1]) {
            ret.push(grid[x+1][y+1]);
        }
    }

    return ret;
};

Graph.prototype.toString = function() {
    var graphString = [],
        nodes = this.grid, // when using grid
        rowDebug, row, y, l;
    for (var x = 0, len = nodes.length; x < len; x++) {
        rowDebug = [];
        row = nodes[x];
        for (y = 0, l = row.length; y < l; y++) {
            rowDebug.push(row[y].weight);
        }
        graphString.push(rowDebug.join(' '));
    }
    return graphString.join('\n');
};

function GridNode(x, y, weight) {
    this.x = x;
    this.y = y;
    this.weight = weight;
}

GridNode.prototype.toString = function() {
    return '[' + this.x + ' ' + this.y + ']';
};

GridNode.prototype.getCost = function(fromNeighbor) {
    // Take diagonal weight into consideration.
    if (fromNeighbor && fromNeighbor.x !== this.x && fromNeighbor.y !== this.y) {
        return this.weight * 1.41421;
    }
    return this.weight;
};

GridNode.prototype.isWall = function() {
    return this.weight === 0;
};

function BinaryHeap(scoreFunction){
    this.content = [];
    this.scoreFunction = scoreFunction;
}

BinaryHeap.prototype = {
    push: function(element) {
        // Add the new element to the end of the array.
        this.content.push(element);

        // Allow it to sink down.
        this.sinkDown(this.content.length - 1);
    },
    pop: function() {
        // Store the first element so we can return it later.
        var result = this.content[0];
        // Get the element at the end of the array.
        var end = this.content.pop();
        // If there are any elements left, put the end element at the
        // start, and let it bubble up.
        if (this.content.length > 0) {
            this.content[0] = end;
            this.bubbleUp(0);
        }
        return result;
    },
    remove: function(node) {
        var i = this.content.indexOf(node);

        // When it is found, the process seen in 'pop' is repeated
        // to fill up the hole.
        var end = this.content.pop();

        if (i !== this.content.length - 1) {
            this.content[i] = end;

            if (this.scoreFunction(end) < this.scoreFunction(node)) {
                this.sinkDown(i);
            }
            else {
                this.bubbleUp(i);
            }
        }
    },
    size: function() {
        return this.content.length;
    },
    rescoreElement: function(node) {
        this.sinkDown(this.content.indexOf(node));
    },
    sinkDown: function(n) {
        // Fetch the element that has to be sunk.
        var element = this.content[n];

        // When at 0, an element can not sink any further.
        while (n > 0) {

            // Compute the parent element's index, and fetch it.
            var parentN = ((n + 1) >> 1) - 1, parent = this.content[parentN]; // jshint ignore:line
            // Swap the elements if the parent is greater.
            if (this.scoreFunction(element) < this.scoreFunction(parent)) {
                this.content[parentN] = element;
                this.content[n] = parent;
                // Update 'n' to continue at the new position.
                n = parentN;
            }
            // Found a parent that is less, no need to sink any further.
            else {
                break;
            }
        }
    },
    bubbleUp: function(n) {
        // Look up the target element and its score.
        var length = this.content.length,
            element = this.content[n],
            elemScore = this.scoreFunction(element);

        while(true) {
            // Compute the indices of the child elements.
            var child2N = (n + 1) << 1, child1N = child2N - 1; // jshint ignore:line
            // This is used to store the new position of the element, if any.
            var swap = null,
                child1Score;
            // If the first child exists (is inside the array)...
            if (child1N < length) {
                // Look it up and compute its score.
                var child1 = this.content[child1N];
                child1Score = this.scoreFunction(child1);

                // If the score is less than our element's, we need to swap.
                if (child1Score < elemScore){
                    swap = child1N;
                }
            }

            // Do the same checks for the other child.
            if (child2N < length) {
                var child2 = this.content[child2N],
                    child2Score = this.scoreFunction(child2);
                if (child2Score < (swap === null ? elemScore : child1Score)) {
                    swap = child2N;
                }
            }

            // If the element needs to be moved, swap it, and continue.
            if (swap !== null) {
                this.content[n] = this.content[swap];
                this.content[swap] = element;
                n = swap;
            }
            // Otherwise, we are done.
            else {
                break;
            }
        }
    }
};

return {
    astar: astar,
    Graph: Graph
};

});

},{}],"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\plugins\\Juicy.js":[function(require,module,exports){
'use strict';

/**
* @author       Jeremy Dowell <jeremy@codevinsky.com>
* @license      {@link http://www.wtfpl.net/txt/copying/|WTFPL}
*/

/**
* Creates a new `Juicy` object.
*
* @class Phaser.Plugin.Juicy
* @constructor
*
* @param {Phaser.Game} game Current game instance.
*/
Phaser.Plugin.Juicy = function (game) {

  Phaser.Plugin.call(this, game);

  /**
  * @property {Phaser.Rectangle} _boundsCache - A reference to the current world bounds.
  * @private
  */
  this._boundsCache = Phaser.Utils.extend(false, {}, this.game.world.bounds);

  /**
  * @property {number} _shakeWorldMax - The maximum world shake radius
  * @private
  */
  this._shakeWorldMax = 20;

  /**
  * @property {number} _shakeWorldTime - The maximum world shake time
  * @private
  */
  this._shakeWorldTime = 0;

  /**
  * @property {number} _trailCounter - A count of how many trails we're tracking
  * @private
  */  
  this._trailCounter = 0;

  /**
  * @property {object} _overScales - An object containing overscaling configurations
  * @private
  */  
  this._overScales = {};

  /**
  * @property {number} _overScalesCounter - A count of how many overScales we're tracking
  * @private
  */  
  this._overScalesCounter = 0;
};

if(typeof module === 'object' && module.exports) {
  module.exports = Phaser.Plugin.Juicy;
}

Phaser.Plugin.Juicy.prototype = Object.create(Phaser.Plugin.prototype);
Phaser.Plugin.Juicy.prototype.constructor = Phaser.Plugin.Juicy;

/**
* Creates a new `Juicy.ScreenFlash` object.
*
* @class Phaser.Plugin.Juicy.ScreenFlash
* @constructor
*
* @param {Phaser.Game} game -  Current game instance.
* @param {string} color='white' - The color to flash the screen.
* @memberof Phaser.Plugin.Juicy
*/
Phaser.Plugin.Juicy.ScreenFlash = function(game, color) {
  color = color || 'white';
  var bmd = game.add.bitmapData(game.width, game.height);
  bmd.ctx.fillStyle = color;
  bmd.ctx.fillRect(0,0, game.width, game.height);

  Phaser.Sprite.call(this, game, 0,0, bmd);
  this.alpha = 0;
};

Phaser.Plugin.Juicy.ScreenFlash.prototype = Object.create(Phaser.Sprite.prototype);
Phaser.Plugin.Juicy.ScreenFlash.prototype.constructor = Phaser.Plugin.Juicy.ScreenFlash;


/*
* Flashes the screen
*
* @param {number} [maxAlpha=1] - The maximum alpha to flash the screen to
* @param {number} [duration=100] - The duration of the flash in milliseconds
* @method Phaser.Plugin.Juicy.ScreenFlash.prototype.flash
* @memberof Phaser.Plugin.Juicy.ScreenFlash
*/
Phaser.Plugin.Juicy.ScreenFlash.prototype.flash = function(maxAlpha, duration) {
  maxAlpha = maxAlpha || 1;
  duration = duration || 100;
  var flashTween = this.game.add.tween(this).to({alpha: maxAlpha}, 100, Phaser.Easing.Bounce.InOut, true,0, 0, true);
  flashTween.onComplete.add(function() {
    this.alpha = 0;
  }, this);
};

/**
* Creates a new `Juicy.Trail` object.
*
* @class Phaser.Plugin.Juicy.Trail
* @constructor
*
* @param {Phaser.Game} game -  Current game instance.
* @param {number} [trailLength=100] - The length of the trail
* @param {number} [color=0xFFFFFF] - The color of the trail
* @memberof Phaser.Plugin.Juicy
*/
Phaser.Plugin.Juicy.Trail = function(game, trailLength, color) {
  Phaser.Graphics.call(this, game, 0,0);
  
  /**
  * @property {Phaser.Sprite} target - The target sprite whose movement we want to create the trail from
  */
  this.target = null;
  /**
  * @property {number} trailLength - The number of segments to use to create the trail
  */
  this.trailLength = trailLength || 100;
  /**
  * @property {number} trailWidth - The width of the trail
  */
  this.trailWidth = 15.0;

  /**
  * @property {boolean} trailScale - Whether or not to taper the trail towards the end
  */
  this.trailScaling = false;

  /**
  * @property {Phaser.Sprite} trailColor - The color of the trail
  */
  this.trailColor = color || 0xFFFFFF;
  
  /**
  * @property {Array<Phaser.Point>} _segments - A historical collection of the previous position of the target
  * @private
  */
  this._segments = [];
  /**
  * @property {Array<number>} _verts - A collection of vertices created from _segments
  * @private
  */
  this._verts = [];
  /**
  * @property {Array<Phaser.Point>} _segments - A collection of indices created from _verts
  * @private
  */
  this._indices = [];

};

Phaser.Plugin.Juicy.Trail.prototype = Object.create(Phaser.Graphics.prototype);
Phaser.Plugin.Juicy.Trail.prototype.constructor = Phaser.Plugin.Juicy.Trail;

/**
* Updates the Trail if a target is set
*
* @method Phaser.Plugin.Juicy.Trail#update
* @memberof Phaser.Plugin.Juicy.Trail
*/

Phaser.Plugin.Juicy.Trail.prototype.update = function() {
  if(this.target) {
    this.x = this.target.x;
    this.y = this.target.y;
    this.addSegment(this.target.x, this.target.y);
    this.redrawSegments(this.target.x, this.target.y);
  }
};

/**
* Adds a segment to the segments list and culls the list if it is too long
* 
* @param {number} [x] - The x position of the point
* @param {number} [y] - The y position of the point
* 
* @method Phaser.Plugin.Juicy.Trail#addSegment
* @memberof Phaser.Plugin.Juicy.Trail
*/
Phaser.Plugin.Juicy.Trail.prototype.addSegment = function(x, y) {
  var segment;

  while(this._segments.length > this.trailLength) {
    segment = this._segments.shift();
  }
  if(!segment) {
    segment = new Phaser.Point();
  }

  segment.x = x;
  segment.y = y;

  this._segments.push(segment);
};


/**
* Creates and draws the triangle trail from segments
* 
* @param {number} [offsetX] - The x position of the object
* @param {number} [offsetY] - The y position of the object
* 
* @method Phaser.Plugin.Juicy.Trail#redrawSegment
* @memberof Phaser.Plugin.Juicy.Trail
*/
Phaser.Plugin.Juicy.Trail.prototype.redrawSegments = function(offsetX, offsetY) {
  this.clear();
  var s1, // current segment
      s2, // previous segment
      vertIndex = 0, // keeps track of which vertex index we're at
      offset, // temporary storage for amount to extend line outwards, bigger = wider
      ang, //temporary storage of the inter-segment angles
      sin = 0, // as above
      cos = 0; // again as above

  // first we make sure that the vertice list is the same length as we we want
  // each segment (except the first) will create to vertices with two values each
  if (this._verts.length !== (this._segments.length -1) * 4) {
    // if it's not correct, we clear the entire list
    this._verts = [];
  }

  // now we loop over all the segments, the list has the "youngest" segment at the end
  var prevAng = 0; // jshint ignore:line
  
  for(var j = 0; j < this._segments.length; ++j) {
    // store the active segment for convenience
    s1 = this._segments[j];

    // if there's a previous segment, time to do some math
    if(s2) {
      // we calculate the angle between the two segments
      // the result will be in radians, so adding half of pi will "turn" the angle 90 degrees
      // that means we can use the sin and cos values to "expand" the line outwards
      ang = Math.atan2(s1.y - s2.y, s1.x - s2.x) + Math.PI / 2;
      sin = Math.sin(ang);
      cos = Math.cos(ang);

      // now it's time to creat ethe two vertices that will represent this pair of segments
      // using a loop here is probably a bit overkill since it's only two iterations
      for(var i = 0; i < 2; ++i) {
        // this makes the first segment stand out to the "left" of the line
        // annd the second to the right, changing that magic number at the end will alther the line width
        offset = ( -0.5 + i / 1) * this.trailWidth;

        // if trail scale effect is enabled, we scale down the offset as we move down the list
        if(this.trailScaling) {
          offset *= j / this._segments.length;
        }

        // finally we put to values in the vert list
        // using the segment coordinates as a base we add the "extended" point
        // offsetX and offsetY are used her to move the entire trail
        this._verts[vertIndex++] = s1.x + cos * offset - offsetX;
        this._verts[vertIndex++] = s1.y + sin * offset - offsetY;
      }
    }
    // finally store the current segment as the previous segment and go for another round
    s2 = s1.copyTo({});
  }
  // we need at least four vertices to draw something
  if(this._verts.length >= 8) {
    // now, we have a triangle "strip", but flash can't draw that without 
    // instructions for which vertices to connect, so it's time to make those
    
    // here, we loop over all the vertices and pair them together in triangles
    // each group of four vertices forms two triangles
    for(var k = 0; k < this._verts.length; k++) {
      this._indices[k * 6 + 0] = k * 2 + 0;
      this._indices[k * 6 + 1] = k * 2 + 1;
      this._indices[k * 6 + 2] = k * 2 + 2;
      this._indices[k * 6 + 3] = k * 2 + 1;
      this._indices[k * 6 + 4] = k * 2 + 2;
      this._indices[k * 6 + 5] = k * 2 + 3;
    }
    this.beginFill(this.trailColor);
    this.drawTriangles(this._verts, this._indices);
    this.endFill();
    
  }
};

Phaser.Plugin.Juicy.prototype.shake = function (duration, strength) {
  if (this.game.camera.target !== null) {
     this.cameraTarget = this.game.camera.target;
     this.game.camera.unfollow();
  }
  this._shakeWorldTime = duration || 20;
  this._shakeWorldMax = strength || 20;
};

Phaser.Plugin.Juicy.prototype.createScreenFlash = function(color) {
    return new Phaser.Plugin.Juicy.ScreenFlash(this.game, color);
};


Phaser.Plugin.Juicy.prototype.createTrail = function(length, color) {
  return new Phaser.Plugin.Juicy.Trail(this.game, length, color);
};

Phaser.Plugin.Juicy.prototype.overScale = function(object, scale, initialScale) {
  scale = scale || 1.5;
  var id = this._overScalesCounter++;
  initialScale = initialScale || new Phaser.Point(1,1);
  var scaleObj = this._overScales[id];
  if(!scaleObj) {
    scaleObj = {
      object: object,
      cache: initialScale.copyTo({})
    };
  } 
  scaleObj.scale = scale;
  
  this._overScales[id] = scaleObj;
};

Phaser.Plugin.Juicy.prototype.jelly = function(object, strength, delay, initialScale) {
  strength = strength || 0.2;
  delay = delay || 0;
  initialScale = initialScale ||  new Phaser.Point(1, 1);
  
  this.game.add.tween(object.scale).to({x: initialScale.x + (initialScale.x * strength)}, 50, Phaser.Easing.Quadratic.InOut, true, delay)
  .to({x: initialScale.x}, 600, Phaser.Easing.Elastic.Out, true);

  this.game.add.tween(object.scale).to({y: initialScale.y + (initialScale.y * strength)}, 50, Phaser.Easing.Quadratic.InOut, true, delay + 50)
  .to({y: initialScale.y}, 600, Phaser.Easing.Elastic.Out, true);
};

Phaser.Plugin.Juicy.prototype.mouseStretch = function(object, strength, initialScale) {
    strength = strength || 0.5;
    initialScale = initialScale || new Phaser.Point(1,1);
    object.scale.x = initialScale.x + (Math.abs(object.x - this.game.input.activePointer.x) / 100) * strength;
    object.scale.y = initialScale.y + (initialScale.y * strength) - (object.scale.x * strength);
};

Phaser.Plugin.Juicy.prototype.update = function () {
  var scaleObj;
  // Screen Shake
  if(this._shakeWorldTime > 0) { 
    var magnitude = (this._shakeWorldTime / this._shakeWorldMax) * this._shakeWorldMax;
    var x = this.game.rnd.integerInRange(-magnitude, magnitude) + this.cameraTarget.x - this.game.camera.width / 2;
    var y = this.game.rnd.integerInRange(-magnitude, magnitude) + this.cameraTarget.y - this.game.camera.height / 2;

    this.game.camera.x = x;
    this.game.camera.y = y;
    this._shakeWorldTime--;
    if(this._shakeWorldTime <= 0) {
       this.game.camera.follow(this.cameraTarget);
    }
  }

  // over scales
  for(var s in this._overScales) {
    if(this._overScales.hasOwnProperty(s)) {
      scaleObj = this._overScales[s];
      if(scaleObj.scale > 0.01) {
        scaleObj.object.scale.x = scaleObj.scale * scaleObj.cache.x;
        scaleObj.object.scale.y = scaleObj.scale * scaleObj.cache.y;
        scaleObj.scale -= this.game.time.elapsed * scaleObj.scale * 0.35;
      } else {
        scaleObj.object.scale.x = scaleObj.cache.x;
        scaleObj.object.scale.y = scaleObj.cache.y;
        delete this._overScales[s];
      }
    }
  }
};

// Draw Triangles Polyfill for back compatibility
if(!Phaser.Graphics.prototype.drawTriangle) {
  Phaser.Graphics.prototype.drawTriangle = function(points, cull) {
      var triangle = new Phaser.Polygon(points);
      if (cull) {
          var cameraToFace = new Phaser.Point(this.game.camera.x - points[0].x, this.game.camera.y - points[0].y);
          var ab = new Phaser.Point(points[1].x - points[0].x, points[1].y - points[0].y);
          var cb = new Phaser.Point(points[1].x - points[2].x, points[1].y - points[2].y);
          var faceNormal = cb.cross(ab);
          if (cameraToFace.dot(faceNormal) > 0) {
              this.drawPolygon(triangle);
          }
      } else {
          this.drawPolygon(triangle);
      }
      return;
  };
}
},{}],"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\states\\boot.js":[function(require,module,exports){
var Boot = function () {};

module.exports = Boot;

Boot.prototype = {

  preload: function () {
    this.load.image('preloader', 'assets/preloader.gif');
  },

  create: function () {
    this.game.input.maxPointers = 1;

    if (this.game.device.desktop) {
      this.game.stage.scale.pageAlignHorizontally = true;
    } else {
      this.game.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL;
      this.game.scale.minWidth =  480;
      this.game.scale.minHeight = 260;
      this.game.scale.maxWidth = 640;
      this.game.scale.maxHeight = 480;
      this.game.scale.forceLandscape = true;
      this.game.scale.pageAlignHorizontally = true;
      this.game.scale.setScreenSize(true);
    }

    this.game.state.start('Preloader');
  }
};

},{}],"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\states\\game.js":[function(require,module,exports){
/*
Main testing environment.
*/

var Renderables = require('../functionAccess/Renderables');
var UIBuilder = require('../ui/UIBuilder');
var Cube = require('../entities/cube');
var ModuleBuilder = require('../entities/ModuleBuilder');
var Utils = require('../utils');
var CubeGroup = require('../entities/cube_group');
var Hackable = require('../entities/Hackable');
var Emitter = require('../effects/Emitter');
var mouseBody; // physics body for mouse
var Mouse = require('../entities/mouse');
var Juicy = require('../plugins/Juicy'); // jshint ignore:line

var bg, bg2;
var numRoids = 0;
var maxRoids = 50;
var asteroids, asteroidList;
var leftKey, rightKey, cwKey, ccwKey;
var asteroidCG, cubeCG;

var Game = function () {
  this.testentity = null;
};

module.exports = Game;

Game.prototype = {
	
  create: function () {
	this.game.world.setBounds(0, 0, 8000, 4000);
	
	//Create the two background images
    bg = this.game.add.sprite(0, 0, 'earthNight');
	bg2 = this.game.add.sprite(-8000, 0, 'earthNight');
	
	this.game.physics.startSystem(Phaser.Physics.P2JS);
   this.game.physics.p2.setImpactEvents(true);
    
	cubeCG = this.game.physics.p2.createCollisionGroup();
	asteroidCG = this.game.physics.p2.createCollisionGroup();
	
   this.mouse = new Mouse(this.game, this.input);
   
   this.updateDependents = [];

	//create Renderables class
	this.renderables = new Renderables();
	//create the UIBuilder
	this.uiBuilder = new UIBuilder(this, this.renderables);   
	//create ModuleBuilder and store it in this game state object
	this.moduleBuilder = new ModuleBuilder(this);
	//create and store the core module
	this.coreModule = this.moduleBuilder.build('core', 1200, 1200, true);
	this.cubeWidth = this.coreModule.cube.width;
	this.coreModule.cube.body.setCollisionGroup(cubeCG);
	this.coreModule.cube.body.collides([cubeCG, asteroidCG]);
	this.cubeBuffer = 2;
	var playerGroup = new CubeGroup(this, this.coreModule.cube);
	this.updateDependents.push(playerGroup);
	this.player = playerGroup;
	this.player.isPlayer = true;

	//Create the emitter for the binary particle effects
	this.BinaryEmitter = new Emitter(this);
	
	//test hackable object
	this.testHack = new Hackable(this, 1600,1200, 'hackable1', 400);

	
	this.spaceKey = this.game.input.keyboard.addKey(Phaser.Keyboard.SPACEBAR);
	this.game.input.keyboard.addKeyCapture([this.spaceKey]);

	
	asteroids = this.game.add.group();
	asteroids.enableBody = true;
	asteroids.physicsBodyType = Phaser.Physics.P2JS;
	asteroidList = new Phaser.ArraySet();
	this.generateAsteroids();
	
	leftKey = this.game.input.keyboard.addKey(Phaser.Keyboard.A);
	rightKey = this.game.input.keyboard.addKey(Phaser.Keyboard.D);
	ccwKey = this.game.input.keyboard.addKey(Phaser.Keyboard.Q);
	cwKey = this.game.input.keyboard.addKey(Phaser.Keyboard.E);
	
	//DEBUGGING LISTENERS- allow you to create modules by pressing keys
	//core
	this.placeCoreKey = this.game.input.keyboard.addKey(Phaser.Keyboard.P);
	this.placeCoreKey.onDown.add(this.addCore, this);
	//shield
	this.placeShieldKey = this.game.input.keyboard.addKey(Phaser.Keyboard.O);
    this.placeShieldKey.onDown.add(this.addShield, this);
	//thruster
	this.placeThrusterKey = this.game.input.keyboard.addKey(Phaser.Keyboard.I);
    this.placeThrusterKey.onDown.add(this.addThruster, this);
	//solarPanel
	this.placeSPKey = this.game.input.keyboard.addKey(Phaser.Keyboard.U);
    this.placeSPKey.onDown.add(this.addSP, this);
	//hacker
	this.placeHackKey = this.game.input.keyboard.addKey(Phaser.Keyboard.Y);
	this.placeHackKey.onDown.add(this.addHack, this);
	//gun
	this.placeGunKey = this.game.input.keyboard.addKey(Phaser.Keyboard.T);
    this.placeGunKey.onDown.add(this.addGun, this);
	//END
    
    // Debug controller
    this.debugKey = this.game.input.keyboard.addKey(Phaser.Keyboard.H);
    this.debugKey.onDown.add(this.debug, this);
    this.rootSpawned = false;
    
    this.debugNum = 0;
    this.myRoot = undefined;

	 this.game.camera.setPosition(1000, 1000);
    
    this.levelData = JSON.parse(this.game.cache.getText('level_one'));
    //this.loadData();
    
    this.juicy = this.game.plugins.add(new Phaser.Plugin.Juicy(this));
    this.game.camera.follow(this.coreModule.cube);
  },
  
  loadData: function() {
      var myLevel = this.levelData['level_one'];
      for (var key in myLevel) {
         if (myLevel.hasOwnProperty(key)) {
            var element = myLevel[key];
            if (element.hasOwnProperty('blueprint')) { // enemy type
               var enemyX = element['x_pos'];
               var enemyY = element['y_pos'];
               var enemyGroup = new CubeGroup(this, undefined);
               this.updateDependents.push(enemyGroup);
               var blueprint = element['blueprint'];
               // var practical = [];
               for (var row = 0; row < blueprint.length; row++) {
                  // var newCol = [];
                  for (var col = 0; col < blueprint[row].length; col++) {
                     var type = blueprint[row][col];
                     var newModule = this.moduleBuilder.build(type, enemyX + row * (this.cubeWidth + this.cubeBuffer),
                     enemyY - col * (this.cubeWidth + this.cubeBuffer), false);
					 newModule.cube.body.setCollisionGroup(cubeCG);
					 newModule.cube.body.collides([cubeCG, asteroidCG]);
                     // newCol.push(newModule.cube);
                     var point = new Phaser.Point(row, col);
                     enemyGroup.add(newModule.cube, point);
                  }
                  // practical.push(newCol);
               }
               // TODO: give different types here
               enemyGroup.giveAI('ram', this.player);
            }
         }
      }
  },

  update: function () {    
	if(leftKey.isDown) {
		if(this.coreModule.cube.body.angularVelocity > -9) { 
			this.coreModule.cube.body.angularForce += -5 * Math.pow(this.player.numCubes, 1.65);
		}
	}
	
	if(rightKey.isDown) {
		if(this.coreModule.cube.body.angularVelocity < 9) {
			this.coreModule.cube.body.angularForce += 5 * Math.pow(this.player.numCubes, 1.65);
		}
	}
	
	if(ccwKey.isDown) {
		if(this.mouse.grabbed !== undefined && this.mouse.grabbed.sprite.group === undefined) {
			this.mouse.grabbed.angularForce += -5;
		}
	}
	
	if(cwKey.isDown) {
		if(this.mouse.grabbed !== undefined && this.mouse.grabbed.sprite.group === undefined) {
			this.mouse.grabbed.angularForce += 5;
		}
	}
	
	this.mouse.update();
	this.scrollBG();
   
	for (var i = 0; i < this.updateDependents.length; i++) {
		if (this.updateDependents[i].update) {
			this.updateDependents[i].update();
		}
	}
  },
  
  render: function () {
	this.mouse.render();
	this.renderables.renderAll();
  },
  
	scrollBG: function() {
		bg.x += 0.125;
		if(bg.x >= 8000) {
			bg.x += 0;
		}
		bg2.x += 0.125;
		if(bg2.x >= 8000) {
			bg2.x = 0;
		}
	},
	
	generateAsteroids: function() {
		for(;numRoids < maxRoids; numRoids++) {
			var coinA = this.game.rnd.integerInRange(0,1);
			var coinB = this.game.rnd.integerInRange(0,1);
			var asteroid;
			if(coinA === 1) {
				if(coinB === 1) { //Spawn asteroid above screen
					asteroid = asteroids.create(this.coreModule.cube.x + this.game.rnd.integerInRange(-this.game.camera.width/2, this.game.camera.width/2), this.coreModule.cube.y - this.game.camera.height/2 - this.game.rnd.integerInRange(32, 300), 'asteroid');
				}
				else { //Spawn asteroid below screen
					asteroid = asteroids.create(this.coreModule.cube.x + this.game.rnd.integerInRange(-this.game.camera.width/2, this.game.camera.width/2), this.coreModule.cube.y + this.game.camera.height/2 + this.game.rnd.integerInRange(32, 300), 'asteroid');
				}
			}
			else {
				if(coinB === 1) { //Spawn asteroid to left of screen
					asteroid = asteroids.create(this.coreModule.cube.x - this.game.camera.width/2 - this.game.rnd.integerInRange(32, 300), this.coreModule.cube.y + this.game.rnd.integerInRange(-this.game.camera.height/2, this.game.camera.height/2), 'asteroid');
				}
				else { //Spawn asteroid to right
					asteroid = asteroids.create(this.coreModule.cube.x + this.game.camera.width/2 + this.game.rnd.integerInRange(32, 300), this.coreModule.cube.y + this.game.rnd.integerInRange(-this.game.camera.height/2, this.game.camera.height/2), 'asteroid');
				}
			}
			
			asteroid.body.setCircle(16); //Change the collision detection from an AABB to a circle
			asteroid.body.angularDamping = 0;
			asteroid.body.damping = 0;
			asteroid.body.rotation = this.game.rnd.realInRange(0, 2 * 3.14);
			asteroid.body.force.x = this.game.rnd.integerInRange(-10, 10) * 750;
			asteroid.body.force.y = this.game.rnd.integerInRange(-10, 10) * 750;
			asteroid.body.setCollisionGroup(asteroidCG);
			asteroid.body.collides([asteroidCG, cubeCG]);
			asteroid.body.collideWorldBounds = false;
			asteroid.autoCull = true;
			asteroid.checkWorldBounds = true;
			asteroid.events.onOutOfBounds.add(this.resetAsteroid, asteroid);
			asteroidList.add(asteroid);
		}
	},
	
	resetAsteroid: function() { //Needs to be updated once collision groups are working
		//this.obj.x = 10;
		//this.obj.y = 10;
	},
	
  //DEBUG FUNCTIONS- event functions called from listeners that allow you to create modules with key presses
  addCore: function () { 
	//Attempts to create more core modules here will only return the existing core
	var newModule = this.moduleBuilder.build('core', this.mouse.x, this.mouse.y, true);
	newModule.cube.body.setCollisionGroup(cubeCG);
	newModule.cube.body.collides([cubeCG, asteroidCG]);
  },
  addShield: function () {
	var newModule = this.moduleBuilder.build('shield', this.mouse.x, this.mouse.y, true);
	newModule.cube.body.setCollisionGroup(cubeCG);
	newModule.cube.body.collides([cubeCG, asteroidCG]);
  },
  addThruster: function () {
	var newModule = this.moduleBuilder.build('thruster', this.mouse.x, this.mouse.y, true);
	newModule.cube.body.setCollisionGroup(cubeCG);
	newModule.cube.body.collides([cubeCG, asteroidCG]);
  },
  addSP: function () {
	var newModule = this.moduleBuilder.build('solarPanel', this.mouse.x, this.mouse.y, true);
	newModule.cube.body.setCollisionGroup(cubeCG);
	newModule.cube.body.collides([cubeCG, asteroidCG]);
  },
  addHack: function () {
	var newModule = this.moduleBuilder.build('hacker', this.mouse.x, this.mouse.y, true);
	newModule.cube.body.setCollisionGroup(cubeCG);
	newModule.cube.body.collides([cubeCG, asteroidCG]);
  },
  addGun: function () {
	var newModule = this.moduleBuilder.build('gun', this.mouse.x, this.mouse.y, true);
	newModule.cube.body.setCollisionGroup(cubeCG);
	newModule.cube.body.collides([cubeCG, asteroidCG]);
  },

  debug: function () {
    this.juicy.shake();
  }
};




























},{"../effects/Emitter":"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\effects\\Emitter.js","../entities/Hackable":"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\entities\\Hackable.js","../entities/ModuleBuilder":"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\entities\\ModuleBuilder.js","../entities/cube":"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\entities\\cube.js","../entities/cube_group":"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\entities\\cube_group.js","../entities/mouse":"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\entities\\mouse.js","../functionAccess/Renderables":"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\functionAccess\\Renderables.js","../plugins/Juicy":"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\plugins\\Juicy.js","../ui/UIBuilder":"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\ui\\UIBuilder.js","../utils":"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\utils.js"}],"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\states\\menu.js":[function(require,module,exports){
var Menu = function () {
  this.text = null;
};

module.exports = Menu;

Menu.prototype = {

  create: function () {
    var x = this.game.width / 2;
    var y = this.game.height / 2;

    var style = { font: '65px Arial', fill: '#ffffff', align: 'center' };
    this.title = this.game.add.text(this.game.world.centerX, this.game.world.centerY - 250, 'Above The Iron Curtain', style);
    this.newGame = this.game.add.text(this.game.world.centerX, this.game.world.centerY - 150, 'New Simulation', style);
    this.level = this.game.add.text(this.game.world.centerX, this.game.world.centerY - 50, 'Mission Select', style);
    this.controls = this.game.add.text(this.game.world.centerX, this.game.world.centerY + 50, 'Manual', style);
    this.credits = this.game.add.text(this.game.world.centerX, this.game.world.centerY + 150, 'Credits', style);

    this.input.onDown.add(this.onDown, this);
  },

  update: function () {
  },

  onDown: function () {
    this.game.state.start(playerState.currentLevel); // jshint ignore:line
  }
};

},{}],"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\states\\preloader.js":[function(require,module,exports){
var Preloader = function (game) {
  game = null;
  this.asset = null;
  this.ready = false;
};

module.exports = Preloader;

Preloader.prototype = {

  preload: function () {
    this.asset = this.add.sprite(640, 360, 'preloader');
    this.asset.anchor.setTo(0.5, 0.5);

    this.load.onLoadComplete.addOnce(this.onLoadComplete, this);
    this.load.setPreloadSprite(this.asset);
    this.load.image('testsprite', 'assets/test2.png');
	this.load.spritesheet('core', 'assets/coreSheet.png', 64, 64); 
	this.load.spritesheet('thruster', 'assets/thrusterSheet.png', 64, 64);
	this.load.spritesheet('gun', 'assets/gunSheet.png', 64, 64);
	this.load.image('shield', 'assets/shield.png');
	this.load.image('solarPanel', 'assets/solarPanel.png');
	this.load.image('hacker', 'assets/hacker.png');
	this.load.spritesheet('hackable1', 'assets/hackable1.png', 256, 256);
    this.load.atlasJSONHash('connections', 'assets/connections.png', 'assets/connections.json');
	this.load.image('asteroid', 'assets/asteroid.png');
    this.load.atlasJSONHash('connections', 'assets/connections.png', 'assets/connections.json');
	this.load.image('earthNight', 'assets/bg_earthNightSmall.jpg');
    this.load.physics('module_physics', 'assets/module_physics.json');
    this.load.text('level_one', 'assets/level_one.json');
  },

  create: function () {
    this.asset.cropEnabled = false;
  },

  update: function () {
    if (!!this.ready) {
      //this.game.state.start('Menu');
      this.game.state.start(playerState.currentLevel); // jshint ignore:line
    }
  },

  onLoadComplete: function () {
    this.ready = true;
  }
};

},{}],"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\states\\splash.js":[function(require,module,exports){
var Splash = function () {
};

module.exports = Splash;

Splash.prototype = {
  create: function () {
  }
};
},{}],"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\ui\\ProgressBar.js":[function(require,module,exports){
//NOTE: DON'T USE this code to create a ProgressBar. Instead, use the UIBuilder object and call buildProgressBar

var ProgressBar = function(setType, setMaxValue, setGraphics, setRenderables) {
	this.type = setType; //Two types, "growing" (starts at 0, triggers event when full) 
						 //and "shrinking" (starts full, triggers at 0)
	this.x = null;
	this.y = null;
	this.width = null;
	this.height = null;
	this.maxValue = setMaxValue;
	this.graphics = setGraphics; //store graphics class (used to draw bar)
	this.renderables = setRenderables;
	
	this.onEvent = function() {}; //overwrite this function to make whatever you want happen when progressBar reaches limit
	
	//switch(this.type) {
	//case 'growing' : 
	if(setType == 'growing') {
		this.value = 0;
		//tryTrigger is called automatically when you add/subtract value, and will trigger the onEvent() function
		this.tryTrigger = function() {
			if(this.value >= this.maxValue) {
				this.onEvent();
			}
		};
		//break;
	}
	else if(setType == 'shrinking') {
	//case 'shrinking' :
		this.value = this.maxValue;
		this.tryTrigger = function() {
			if(this.value <= 0) {
				this.onEvent();
			}
		};
	//}
	}
};

ProgressBar.prototype.constructor = ProgressBar;

ProgressBar.prototype.destroy = function() {
	this.graphics.clear();
	this.renderables.unsubscribe(this);
};

//To subtract value, just use negative numbers as argument i.e. foo.addValue(-5);
ProgressBar.prototype.addValue = function (addThis) {
	this.value += addThis;
	if(this.value > this.maxValue) {
		this.value = this.maxValue;
	}
	if(this.value < 0) {
		this.value = 0;
	}
	this.tryTrigger();
};

//Sets the location where progress bar is rendered
ProgressBar.prototype.setLocation = function(setX, setY) {
	this.x = setX;
	this.y = setY;
};

//Sets the size of the progress bar
ProgressBar.prototype.setSize = function(setWidth, setHeight) {
	this.width = setWidth;
	this.height = setHeight;
};

//Renders progressBar
ProgressBar.prototype.render = function() {
	this.graphics.clear();
	//Draw background of bar
	this.graphics.lineStyle(2, 0xAAAAAA, 1);
	this.graphics.beginFill(0x888888);
	this.graphics.drawRect(this.x-this.width/2, this.y-this.height/2, this.width, this.height);
	this.graphics.endFill();
	//Draw value of bar
	var percentage = this.value / this.maxValue;
	var barWidth = this.width - 5;
	var barHeight = this.height - 5;
	this.graphics.lineStyle(1, 0x8888FF, 1);
	this.graphics.beginFill(0x000099);
	this.graphics.drawRect(this.x-(barWidth/2), this.y-(barHeight/2), barWidth*percentage, barHeight);
	this.graphics.endFill();
};

module.exports = ProgressBar;
},{}],"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\ui\\UIBuilder.js":[function(require,module,exports){
var ProgressBar = require('./ProgressBar');

var UIBuilder = function(setGameState, setRenderables) {
	//Ensure that cannot create multiple instances of this class
	if(UIBuilder.prototype.exists) {
		return UIBuilder.prototype.existingReference;
	}
	
	this.gameState = setGameState;
	this.renderables = setRenderables;
	//Create and store a graphics object (used for stuff like drawing rectangles)
	UIBuilder.prototype.exists = true;
	UIBuilder.prototype.existingReference = this;
};

UIBuilder.prototype.constructor = UIBuilder;
//These var's help create the singleton functionality
UIBuilder.prototype.exists = false;
UIBuilder.prototype.existingReference = null;

//Use this function to create a progress bar
//Usage: type: can be "growing" or "shrinking", this will effect if bar starts at 0 and goes up or vis versa
//		 maxValue: sets the max value of the progress bar, i.e. using 100 creates a bar from 0 to 100
//		 x,y: sets location
//		 DON'T FORGET to overwrite the onEvent() function for the progress bar after creating it
//			-onEvent() is automatically called when bar fills/shrinks past limit (depending on bar type)
UIBuilder.prototype.buildProgressBar = function(type, x, y, width, height, maxValue) {
	//create and format new prog bar
	var graphics = this.gameState.game.add.graphics(0,0);
	var newProgBar = new ProgressBar(type, maxValue, graphics, this.renderables);
	newProgBar.setLocation(x,y);
	newProgBar.setSize(width, height);
	//subscribe to 'renderables' so that render() is called automatically
	this.renderables.subscribe(newProgBar);
	return newProgBar;
};

module.exports = UIBuilder;
},{"./ProgressBar":"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\ui\\ProgressBar.js"}],"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\utils.js":[function(require,module,exports){
/*
Collection of utility functions.
*/

var Utils = {
    containsObject: function(obj, list) {
        var i;
        for (i = 0; i < list.length; i++) {
            if (list[i] === obj) {
                return true;
            }
        }

        return false;
    },
    distance: function(x1, y1, x2, y2) {
       return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
    }
};

module.exports = Utils;
},{}]},{},["./src/js/main.js"])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlc1xcYnJvd3NlcmlmeVxcbm9kZV9tb2R1bGVzXFxicm93c2VyLXBhY2tcXF9wcmVsdWRlLmpzIiwic3JjL2pzL21haW4uanMiLCJzcmMvanMvZWZmZWN0cy9CaW5hcnlQYXJ0aWNsZS5qcyIsInNyYy9qcy9lZmZlY3RzL0VtaXR0ZXIuanMiLCJzcmMvanMvZW50aXRpZXMvSGFja2FibGUuanMiLCJzcmMvanMvZW50aXRpZXMvTW9kdWxlLmpzIiwic3JjL2pzL2VudGl0aWVzL01vZHVsZUJ1aWxkZXIuanMiLCJzcmMvanMvZW50aXRpZXMvY3ViZS5qcyIsInNyYy9qcy9lbnRpdGllcy9jdWJlX2dyb3VwLmpzIiwic3JjL2pzL2VudGl0aWVzL2VuZW15X2FpLmpzIiwic3JjL2pzL2VudGl0aWVzL21vdXNlLmpzIiwic3JjL2pzL2Z1bmN0aW9uQWNjZXNzL1JlbmRlcmFibGVzLmpzIiwic3JjL2pzL2xpYnMvamF2YXNjcmlwdC1hc3Rhci9hc3Rhci5qcyIsInNyYy9qcy9wbHVnaW5zL0p1aWN5LmpzIiwic3JjL2pzL3N0YXRlcy9ib290LmpzIiwic3JjL2pzL3N0YXRlcy9nYW1lLmpzIiwic3JjL2pzL3N0YXRlcy9tZW51LmpzIiwic3JjL2pzL3N0YXRlcy9wcmVsb2FkZXIuanMiLCJzcmMvanMvc3RhdGVzL3NwbGFzaC5qcyIsInNyYy9qcy91aS9Qcm9ncmVzc0Jhci5qcyIsInNyYy9qcy91aS9VSUJ1aWxkZXIuanMiLCJzcmMvanMvdXRpbHMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0tBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZtQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6WUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgZ2FtZSA9IG5ldyBQaGFzZXIuR2FtZSgxMjgwLCA3MjAsIFBoYXNlci5BVVRPLCAnYXRpYy1nYW1lJyk7XHJcblxyXG53aW5kb3cucGxheWVyU3RhdGUgPSB7XHJcbiAgICBjdXJyZW50TGV2ZWw6ICdHYW1lJ1xyXG59O1xyXG5cclxuZ2FtZS5zdGF0ZS5hZGQoJ0Jvb3QnLCByZXF1aXJlKCcuL3N0YXRlcy9ib290JykpO1xyXG5nYW1lLnN0YXRlLmFkZCgnU3BsYXNoJywgcmVxdWlyZSgnLi9zdGF0ZXMvc3BsYXNoJykpO1xyXG5nYW1lLnN0YXRlLmFkZCgnUHJlbG9hZGVyJywgcmVxdWlyZSgnLi9zdGF0ZXMvcHJlbG9hZGVyJykpO1xyXG5nYW1lLnN0YXRlLmFkZCgnTWVudScsIHJlcXVpcmUoJy4vc3RhdGVzL21lbnUnKSk7XHJcbmdhbWUuc3RhdGUuYWRkKCdHYW1lJywgcmVxdWlyZSgnLi9zdGF0ZXMvZ2FtZScpKTtcclxuXHJcbmdhbWUuc3RhdGUuc3RhcnQoJ0Jvb3QnKTsiLCJ2YXIgQmluYXJ5UGFydGljbGUgPSBmdW5jdGlvbihnYW1lLCB0YXJnZXRPYmosIHgsIHksIHRhck9mZnNldFgsIHRhck9mZnNldFkpIHtcclxuXHR2YXIgc3R5bGUgPSB7Zm9udDogJzIwcHggQXZhbnQgR2FyZGUnLCBmaWxsOiAnI0VFRUUzMycsIGFsaWduOiAnY2VudGVyJ307XHJcblx0dmFyIGJ5dGVTeW1ib2wgPSBNYXRoLnJhbmRvbSgpID49IDAuNSA/ICcxJyA6ICcwJztcclxuXHRQaGFzZXIuVGV4dC5jYWxsKHRoaXMsIGdhbWUsIHgsIHksIGJ5dGVTeW1ib2wsIHN0eWxlKTtcclxuXHRnYW1lLmFkZC5leGlzdGluZyh0aGlzKTtcclxuXHR0aGlzLnRhcmdldE9iaiA9IHRhcmdldE9iajtcclxuXHR0aGlzLnNwZWVkID0gMy42O1xyXG5cdHRoaXMudGFyT2Zmc2V0WCA9IHRhck9mZnNldFg7XHJcblx0dGhpcy50YXJPZmZzZXRZID0gdGFyT2Zmc2V0WTtcclxuXHRjb25zb2xlLmxvZygncmFuJyk7XHJcbn07XHJcblxyXG5CaW5hcnlQYXJ0aWNsZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFBoYXNlci5UZXh0LnByb3RvdHlwZSk7XHJcbkJpbmFyeVBhcnRpY2xlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEJpbmFyeVBhcnRpY2xlO1xyXG5cclxuQmluYXJ5UGFydGljbGUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdC8vR2V0IGRlbHRhIHZlY3RvciB0byB0YXJnZXQgb2JqZWN0XHJcblx0dmFyIGRlbHRhID0gW3RoaXMudGFyZ2V0T2JqLnggKyB0aGlzLnRhck9mZnNldFggLSB0aGlzLngsIHRoaXMudGFyZ2V0T2JqLnkgKyB0aGlzLnRhck9mZnNldFkgLSB0aGlzLnldO1xyXG5cdC8vR2V0IGRpc3RhbmNlIGFuZCBjaGVjayBpZiB3ZSd2ZSByZWFjaGVkIHRhcmdldCBkaXN0YW5jZVxyXG5cdHZhciBkaXN0ID0gTWF0aC5zcXJ0KE1hdGgucG93KGRlbHRhWzBdLCAyKSArIE1hdGgucG93KGRlbHRhWzFdLCAyKSk7XHJcblx0aWYoZGlzdCA8PSB0aGlzLnNwZWVkKSB7XHJcblx0XHR0aGlzLmRlc3Ryb3koKTtcclxuXHRcdHJldHVybjtcclxuXHR9XHJcblx0Ly9Ob3JtYWxpemUgZGVsdGEgdmVjdG9yXHJcblx0ZGVsdGEgPSBbZGVsdGFbMF0vZGlzdCwgZGVsdGFbMV0vZGlzdF07XHJcblx0Ly9VcGRhdGUgcG9zaXRpb25cclxuXHR0aGlzLnggPSB0aGlzLnggKyB0aGlzLnNwZWVkKmRlbHRhWzBdO1xyXG5cdHRoaXMueSA9IHRoaXMueSArIHRoaXMuc3BlZWQqZGVsdGFbMV07XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEJpbmFyeVBhcnRpY2xlOyIsInZhciBCaW5hcnlQYXJ0aWNsZSA9IHJlcXVpcmUoJy4vQmluYXJ5UGFydGljbGUnKTtcclxuXHJcbnZhciBFbWl0dGVyID0gZnVuY3Rpb24oZ2FtZVN0YXRlKSB7XHJcblx0dGhpcy5nYW1lU3RhdGUgPSBnYW1lU3RhdGU7XHJcbn07XHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEVtaXR0ZXI7XHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5lbWl0QmluYXJ5ID0gZnVuY3Rpb24gKHRhcmdldE9iaiwgeCwgeSwgc3BhY2luZykge1xyXG5cdHZhciBvZmZzZXRYID0gKE1hdGgucmFuZG9tKCktMC41KSpzcGFjaW5nO1xyXG5cdHZhciBvZmZzZXRZID0gKE1hdGgucmFuZG9tKCktMC41KSpzcGFjaW5nO1xyXG5cdHZhciBuZXdQYXJ0aWNsZSA9IG5ldyBCaW5hcnlQYXJ0aWNsZSh0aGlzLmdhbWVTdGF0ZS5nYW1lLCB0YXJnZXRPYmosIHgsIHksIG9mZnNldFgsIG9mZnNldFkpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBFbWl0dGVyOyIsIi8qXHJcbkRlZmluZXMgYSBoYWNrYWJsZSBvYmplY3QuXHJcbiovXHJcblxyXG52YXIgSGFja2FibGUgPSBmdW5jdGlvbiAoZ2FtZVN0YXRlLCB4LCB5LCBzcHJpdGUsIGhhY2tEaXN0YW5jZSkge1xyXG4gICBQaGFzZXIuU3ByaXRlLmNhbGwodGhpcywgZ2FtZVN0YXRlLmdhbWUsIHgsIHksIHNwcml0ZSk7XHJcbiAgIGdhbWVTdGF0ZS5nYW1lLmFkZC5leGlzdGluZyh0aGlzKTtcclxuXHQvL3N0b3JlIGdhbWVTdGF0ZVxyXG5cdHRoaXMuZ2FtZVN0YXRlID0gZ2FtZVN0YXRlO1xyXG5cdC8vc2V0IGlzSGFja2VkIHRvIGZhbHNlXHJcblx0dGhpcy5pc0hhY2tlZCA9IGZhbHNlO1xyXG5cdC8vYWRkIGhhY2tCYXJcclxuXHR0aGlzLmhhY2tCYXIgPSBnYW1lU3RhdGUudWlCdWlsZGVyLmJ1aWxkUHJvZ3Jlc3NCYXIoJ2dyb3dpbmcnLCAxNTAwLCAxMjAwLCAxMDAsIDEwLCAgMjAwKTtcclxuXHR0aGlzLmhhY2tCYXIuaGFja2FibGUgPSB0aGlzO1xyXG5cdHRoaXMuaGFja0Jhci5vbkV2ZW50ID0gZnVuY3Rpb24oKSB7XHJcblx0XHR0aGlzLmhhY2thYmxlLmZyYW1lID0gMTtcclxuXHRcdHRoaXMuaGFja2FibGUuaXNIYWNrZWQgPSB0cnVlO1xyXG5cdFx0dGhpcy5kZXN0cm95KCk7XHJcblx0fTtcclxuXHR0aGlzLnRhZyA9ICduZXV0cmFsT2JqJztcdC8vVGFnIGlzIHVzZWQgdG8gaWRlbnRpZnkgb2JqZWN0IHR5cGUgZHVyaW5nIGNvbGxpc2lvbiBjaGVja2luZ1xyXG5cdHRoaXMuaGFja0Rpc3RhbmNlID0gaGFja0Rpc3RhbmNlO1xyXG5cdHZhciBzY2FsZSA9IDAuNTtcclxuICAgdGhpcy5zY2FsZS54ID0gc2NhbGU7XHJcbiAgIHRoaXMuc2NhbGUueSA9IHNjYWxlO1xyXG4gICB0aGlzLmFuY2hvci5zZXRUbygwLjUsIDAuNSk7XHJcbiAgIGdhbWVTdGF0ZS5nYW1lLnBoeXNpY3MucDIuZW5hYmxlKHRoaXMpO1xyXG4gICB0aGlzLmJvZHkub25CZWdpbkNvbnRhY3QuYWRkKHRoaXMuY3ViZUNvbGxpZGUsIHRoaXMpO1xyXG4gICB0aGlzLmJvZHkuZGFtcGluZyA9IDAuOTtcclxuICAgdGhpcy5ib2R5LmFuZ3VsYXJEYW1waW5nID0gMC45O1xyXG59O1xyXG5cclxuSGFja2FibGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShQaGFzZXIuU3ByaXRlLnByb3RvdHlwZSk7XHJcbkhhY2thYmxlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEhhY2thYmxlO1xyXG5cclxuLyoqXHJcbiAqIEF1dG9tYXRpY2FsbHkgY2FsbGVkIGJ5IFdvcmxkLnVwZGF0ZVxyXG4gKi9cclxuSGFja2FibGUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdHRoaXMuaGFja0Jhci5zZXRMb2NhdGlvbih0aGlzLngsIHRoaXMueSAtIDcwKTtcclxuXHQvL2NoZWNrIGlmIGdldHRpbmcgaGFja2VkXHJcblx0aWYoIXRoaXMuaXNIYWNrZWQpIHtcclxuXHRcdGlmKHRoaXMuZ2FtZVN0YXRlLnBsYXllci5oYWNrZXJNb2R1bGVzLmxlbmd0aCA+IDApIHtcclxuXHRcdFx0dmFyIGRpc3Q7XHJcblx0XHRcdHZhciBoYWNrZXI7XHJcblx0XHRcdC8vTG9vcCB0aHJvdWdoIGFsbCBoYWNrZXIgbW9kdWxlcyBvbiB0aGUgcGxheWVyJ3MgY3Vic2F0XHJcblx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmdhbWVTdGF0ZS5wbGF5ZXIuaGFja2VyTW9kdWxlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdGhhY2tlciA9IHRoaXMuZ2FtZVN0YXRlLnBsYXllci5oYWNrZXJNb2R1bGVzW2ldO1xyXG5cdFx0XHRcdGRpc3QgPSBNYXRoLnNxcnQoIE1hdGgucG93KHRoaXMueCAtIGhhY2tlci5jdWJlLngsIDIpICsgTWF0aC5wb3codGhpcy55IC0gaGFja2VyLmN1YmUueSwgMikgKTtcclxuXHRcdFx0XHRpZihkaXN0IDwgdGhpcy5oYWNrRGlzdGFuY2UpIHtcclxuXHRcdFx0XHRcdC8vSWYgaGFja2VyIGlzIGluIHJhbmdlLCBpbmNyZWFzZSBoYWNrIHZhbHVlIGFuZCB0cnkgdG8gZW1pdCBiaW5hcnkgcGFydGljbGVcclxuXHRcdFx0XHRcdHRoaXMuaGFja0Jhci5hZGRWYWx1ZSgwLjA1KTtcclxuXHRcdFx0XHRcdGhhY2tlci5jb3VudCsrO1xyXG5cdFx0XHRcdFx0aWYoaGFja2VyLmNvdW50ID49IGhhY2tlci5jeWNsZSkge1xyXG5cdFx0XHRcdFx0XHRoYWNrZXIuY291bnQgPSAwO1xyXG5cdFx0XHRcdFx0XHR0aGlzLmdhbWVTdGF0ZS5CaW5hcnlFbWl0dGVyLmVtaXRCaW5hcnkodGhpcywgaGFja2VyLmN1YmUueCwgaGFja2VyLmN1YmUueSwgNjApO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxufTtcclxuXHJcblxyXG5IYWNrYWJsZS5wcm90b3R5cGUuY3ViZUNvbGxpZGUgPSBmdW5jdGlvbihvdGhlcikge1xyXG4vKiAgIGlmICh0aGlzLmdyb3VwID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICB9XHJcbiAgIHRoaXMuZ3JvdXAuaGFuZGxlQ29sbGlzaW9uKHRoaXMsIG90aGVyLnNwcml0ZSk7Ki9cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSGFja2FibGU7IiwiLy9Eb24ndCB1c2UgdGhpcyBmdW5jdGlvbiB0byBjcmVhdGUgbW9kdWxlcywgaW5zdGVhZCB1c2UgbW9kdWxlQnVpbGRlcigpXHJcbnZhciBNb2R1bGUgPSBmdW5jdGlvbihzZXRUeXBlLCBzZXRDdWJlKSB7XHJcblx0dGhpcy50eXBlID0gc2V0VHlwZTtcclxuXHR0aGlzLmN1YmUgPSBzZXRDdWJlO1xyXG4gICBzZXRDdWJlLm1vZHVsZSA9IHRoaXM7XHJcbn07XHJcblxyXG5Nb2R1bGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTW9kdWxlO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBNb2R1bGU7IiwidmFyIEN1YmUgPSByZXF1aXJlKCcuL2N1YmUnKTtcclxudmFyIE1vZHVsZSA9IHJlcXVpcmUoJy4vTW9kdWxlJyk7XHJcblxyXG52YXIgdGhydXN0QW10ID0gNTAwMDtcclxuXHJcbi8vVXNlIHRoaXMgdG8gY3JlYXRlIGEgbW9kdWxlQnVpbGRlci0gb25seSBuZWVkIHRvIGNyZWF0ZSBvbmUgaW5zdGFuY2Ugb2YgaXRcclxudmFyIE1vZHVsZUJ1aWxkZXIgPSBmdW5jdGlvbihzZXRHYW1lU3RhdGUsIHNldENvbEdyb3VwKSB7XHJcblx0Ly9FbnN1cmUgdGhhdCBjYW5ub3QgY3JlYXRlIG11bHRpcGxlIGluc3RhbmNlcyBvZiB0aGlzIGNsYXNzXHJcblx0aWYoTW9kdWxlQnVpbGRlci5wcm90b3R5cGUuZXhpc3RzKSB7XHJcblx0XHRyZXR1cm4gTW9kdWxlQnVpbGRlci5wcm90b3R5cGUuZXhpc3RpbmdSZWZlcmVuY2U7XHJcblx0fVxyXG5cdFx0XHJcblx0dGhpcy5nYW1lU3RhdGUgPSBzZXRHYW1lU3RhdGU7XHJcbiAgIHRoaXMuY29sR3JvdXAgPSBzZXRDb2xHcm91cDtcclxuXHQvLyB0aGlzLmNvcmVFeGlzdHMgPSBmYWxzZTtcdC8vcmVjb3JkcyBpZiBjb3JlIGhhcyBiZWVuIGNyZWF0ZWRcclxuXHR0aGlzLmNvcmUgPSBudWxsO1x0XHRcdC8vc3RvcmVzIGNvcmUgd2hlbiBpdCBpcyBjcmVhdGVkXHJcblx0Ly92YXIgc3BhY2UgPSB0aGlzLmdhbWVTdGF0ZS5pbnB1dC5rZXlib2FyZC5hZGRLZXkoUGhhc2VyLktleWJvYXJkLlNQQUNFQkFSKTtcclxuXHRNb2R1bGVCdWlsZGVyLnByb3RvdHlwZS5leGlzdHMgPSB0cnVlO1xyXG5cdE1vZHVsZUJ1aWxkZXIucHJvdG90eXBlLmV4aXN0aW5nUmVmZXJlbmNlID0gdGhpcztcclxufTtcclxuXHJcbk1vZHVsZUJ1aWxkZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTW9kdWxlQnVpbGRlcjtcclxuXHJcbi8vVGhlc2UgdmFyJ3MgaGVscCBjcmVhdGUgdGhlIHNpbmdsZXRvbiBmdW5jdGlvbmFsaXR5XHJcbk1vZHVsZUJ1aWxkZXIucHJvdG90eXBlLmV4aXN0cyA9IGZhbHNlO1xyXG5Nb2R1bGVCdWlsZGVyLnByb3RvdHlwZS5leGlzdGluZ1JlZmVyZW5jZSA9IG51bGw7XHJcblxyXG4vKiogTW9kdWxlIGZ1bmN0aW9ucyAqKi9cclxuZnVuY3Rpb24gc29sYXJQYW5lbEdpdmVUYXJnZXQodGFyZ2V0KSB7XHJcbiAgIGlmICh0aGlzLmN1YmUuZ3JvdXAgJiYgdGFyZ2V0LmN1YmUuZ3JvdXAgJiYgdGhpcy5jdWJlLmdyb3VwICE9PSB0YXJnZXQuY3ViZS5ncm91cCB8fCB0aGlzID09PSB0YXJnZXQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICB9XHJcbiAgIHZhciBvdXJHcm91cCA9IHRoaXMuY3ViZS5ncm91cDtcclxuICAgdmFyIG5ld0Nvbm5lY3Rpb24gPSB7c3RhcnQ6IHRoaXMuY3ViZSwgZW5kOiB0YXJnZXQuY3ViZX07XHJcbiAgIHRoaXMuY3ViZS5teUNvbm5lY3Rpb24gPSBuZXdDb25uZWN0aW9uO1xyXG4gICB0YXJnZXQuY3ViZS5teUNvbm5lY3Rpb24gPSBuZXdDb25uZWN0aW9uO1xyXG4gICBvdXJHcm91cC5kaXNwbGF5Q29ubmVjdGlvbih0aGlzLmN1YmUubXlDb25uZWN0aW9uKTtcclxufVxyXG5cclxuZnVuY3Rpb24gc29sYXJQYW5lbE1vdXNlT3ZlcigpIHtcclxuICAgaWYgKCF0aGlzLmN1YmUubXlDb25uZWN0aW9uIHx8ICF0aGlzLmN1YmUuZ3JvdXApIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICB9XHJcbiAgIHRoaXMuY3ViZS5ncm91cC5kaXNwbGF5Q29ubmVjdGlvbih0aGlzLmN1YmUubXlDb25uZWN0aW9uKTtcclxufVxyXG5cclxuZnVuY3Rpb24gc29sYXJQYW5lbE9uUmVtb3ZlKCkge1xyXG4gICBjb25zb2xlLmxvZygncmVtb3ZlJyk7XHJcbiAgIGlmKHRoaXMuY3ViZS5teUNvbm5lY3Rpb24gIT09IHVuZGVmaW5lZCkge1xyXG5cdHRoaXMuY3ViZS5teUNvbm5lY3Rpb24uZW5kLm15Q29ubmVjdGlvbiA9IHVuZGVmaW5lZDtcclxuXHR0aGlzLmN1YmUubXlDb25uZWN0aW9uID0gdW5kZWZpbmVkO1xyXG4gICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGJlZ2luVGhydXN0KCkge1xyXG4gICB0aGlzLnRocnVzdCA9IHRydWU7XHJcbiAgIHRoaXMuY3ViZS5mcmFtZSA9IDE7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGVuZFRocnVzdCgpIHtcclxuICAgdGhpcy50aHJ1c3QgPSBmYWxzZTtcclxuICAgdGhpcy5jdWJlLmZyYW1lID0gMDtcclxufVxyXG5cclxuZnVuY3Rpb24gdGhydXN0ZXJVcGRhdGUoKSB7XHJcbiAgIC8vIGNvbnNvbGUubG9nKHRoaXMudGhydXN0KTtcclxuICAgaWYgKHRoaXMudGhydXN0ICYmIHRoaXMuY3ViZS5teUNvbm5lY3Rpb24pIHtcclxuICAgICAgdGhpcy5jdWJlLmJvZHkuZm9yY2UueCA9IHRocnVzdEFtdCAqIE1hdGguY29zKHRoaXMuY3ViZS5yb3RhdGlvbiAtIE1hdGguUEkgLyAyKTtcclxuICAgICAgdGhpcy5jdWJlLmJvZHkuZm9yY2UueSA9IHRocnVzdEFtdCAqIE1hdGguc2luKHRoaXMuY3ViZS5yb3RhdGlvbiAtIE1hdGguUEkgLyAyKTtcclxuXHQgIGlmKHRoaXMuY3ViZS5mcmFtZSA9PT0gMSkge1xyXG5cdFx0dGhpcy5jdWJlLmZyYW1lID0gMjtcclxuXHQgIH1cclxuXHQgIGVsc2Uge1xyXG5cdFx0dGhpcy5jdWJlLmZyYW1lID0gMTtcclxuXHQgIH1cclxuICAgfVxyXG59XHJcblxyXG4vKiogRW5kIG1vZHVsZSBmdW5jdGlvbnMgKiovXHJcblxyXG4vL2NhbGwgdGhpcyBmdW5jdGlvbiBmcm9tIE1vZHVsZUJ1aWxkZXIgdG8gY29uc3RydWN0IG1vZHVsZXNcclxuLy9UWVBFUzogJ2NvcmUnICdzaGllbGQnICd0aHJ1c3RlcicgJ3NvbGFyUGFubmVsJyAnaGFja2VyJ1xyXG5Nb2R1bGVCdWlsZGVyLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uKHR5cGUsIHgsIHksIGZvclBsYXllcikge1xyXG5cdC8vQ2hlY2sgaWYgY29yZSBoYXMgYmVlbiBjcmVhdGVkXHJcblx0aWYodHlwZSA9PT0gJ2NvcmUnICYmIHRoaXMuY29yZUV4aXN0cykge1xyXG5cdFx0Ly9pZiBzbywgcmV0dXJuIGV4aXN0aW5nIGNvcmUgYi9jIGlzIHNpbmdsZXRvblxyXG5cdFx0Ly9iL2Mgb2YgdGhpcywgY2FuIGNhbGwgTW9kdWxlQnVpbGRlci5idWlsZCgnY29yZScpIHRvIGFjY2VzcyByZWZlcmVuY2UgdG8gZXhpc3RpbmcgY29yZVxyXG5cdFx0cmV0dXJuIHRoaXMuY29yZTtcclxuXHR9XHJcblx0XHJcblx0Ly9DcmVhdGUgY3ViZSBvYmplY3QgdG8gYmUgc3RvcmVkIHdpdGhpbiBtb2R1bGVcclxuXHQvL1Nwcml0ZSBuYW1lcyBmb3IgbW9kdWxlcyBhcmUgZGlyZWN0bHkgbWFwcGVkIHRvIG1vZHVsZSBuYW1lcywgc28ganVzdCBwYXNzICd0eXBlJyBhcyBzcHJpdGUgbmFtZVxyXG5cdHZhciBuZXdDdWJlID0gbmV3IEN1YmUodGhpcy5nYW1lU3RhdGUuZ2FtZSwgeCwgeSwgdHlwZSk7XHJcbiAgICB2YXIgc2NhbGUgPSAwLjU7XHJcbiAgICBuZXdDdWJlLm5hbWUgPSB0aGlzLmdhbWVTdGF0ZS5kZWJ1Z051bSsrO1xyXG4gICAgbmV3Q3ViZS5zY2FsZS5zZXRUbyhzY2FsZSwgc2NhbGUpO1xyXG4gICAgbmV3Q3ViZS5hbmNob3Iuc2V0VG8oMC41LCAwLjUpO1xyXG4gICAgdGhpcy5nYW1lU3RhdGUuZ2FtZS5waHlzaWNzLnAyLmVuYWJsZShuZXdDdWJlKTtcclxuICAgIG5ld0N1YmUuYm9keS5vbkJlZ2luQ29udGFjdC5hZGQobmV3Q3ViZS5jdWJlQ29sbGlkZSwgbmV3Q3ViZSk7XHJcblx0bmV3Q3ViZS5ib2R5LmNvbGxpZGVXb3JsZEJvdW5kcyA9IGZhbHNlO1xyXG4gICAgbmV3Q3ViZS5ib2R5LmRhbXBpbmcgPSAwLjk7XHJcbiAgICBuZXdDdWJlLmJvZHkuYW5ndWxhckRhbXBpbmcgPSAwLjk7XHJcbiAgICBpZiAoIXRoaXMuZ2FtZVN0YXRlLnJvb3RTcGF3bmVkKSB7XHJcbiAgICAgICBuZXdDdWJlLnJvb3QgPSB0cnVlO1xyXG4gICAgICAgdGhpcy5nYW1lU3RhdGUucm9vdFNwYXduZWQgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgdmFyIGNJbmRpY2F0b3IgPSB0aGlzLmdhbWVTdGF0ZS5hZGQuc3ByaXRlKDAsIDAsICdjb25uZWN0aW9ucycsICdjb25uZWN0aW9uX2xpbmUucG5nJyk7XHJcbiAgIGNJbmRpY2F0b3IuYW5jaG9yLnNldFRvKDAuNSwgMC41KTtcclxuICAgY0luZGljYXRvci5hbmltYXRpb25zLmFkZCgnZW5kJywgWydjb25uZWN0aW9uX2VuZC5wbmcnXSwgNjAsIHRydWUpO1xyXG4gICBjSW5kaWNhdG9yLmFuaW1hdGlvbnMuYWRkKCdsaW5lJywgWydjb25uZWN0aW9uX2xpbmUucG5nJ10sIDYwLCB0cnVlKTtcclxuICAgY0luZGljYXRvci5hbmltYXRpb25zLmFkZCgncmlnaHQnLCBbJ2Nvbm5lY3Rpb25fcmlnaHQucG5nJ10sIDYwLCB0cnVlKTtcclxuICAgbmV3Q3ViZS5hZGRDaGlsZChjSW5kaWNhdG9yKTtcclxuICAgbmV3Q3ViZS5jSW5kaWNhdG9yID0gY0luZGljYXRvcjtcclxuICAgY0luZGljYXRvci5hbHBoYSA9IDA7XHJcblx0XHJcblx0Ly9DcmVhdGUgbW9kdWxlIHRvIHdyYXAgYXJvdW5kIGN1YmUgY2xhc3NcclxuXHR2YXIgbmV3TW9kdWxlID0gbmV3IE1vZHVsZSh0eXBlLCBuZXdDdWJlKTtcclxuXHRcdFxyXG5cdC8vVE9ETzogZWRpdCBzcGVjaWFsIG1vZHVsZSBhdHJpYnV0ZXMgYmFzZWQgb24gJ3R5cGUnXHJcblx0aWYodHlwZSA9PT0gJ2hhY2tlcicpIHtcclxuXHRcdG5ld01vZHVsZS5jeWNsZSA9IDY7XHJcblx0XHRuZXdNb2R1bGUuY291bnQgPSAwO1xyXG5cdH1cclxuXHRcclxuXHQvL1N0b3JlIG1vZHVsZSBpZiBpdCBpcyBjb3JlXHJcblx0aWYodHlwZSA9PT0gJ2NvcmUnKVxyXG5cdHtcclxuXHRcdG5ld01vZHVsZS5jdWJlLmFuaW1hdGlvbnMuYWRkKCdjb3JlJywgWzAsMSwyXSwgMjAsIHRydWUpO1xyXG5cdFx0bmV3TW9kdWxlLmN1YmUuYW5pbWF0aW9ucy5wbGF5KCdjb3JlJyk7XHJcblx0XHR0aGlzLmNvcmUgPSBuZXdNb2R1bGU7XHJcblx0XHR0aGlzLmNvcmVFeGlzdHMgPSB0cnVlO1xyXG5cdH1cclxuICAgLy8gc29sYXIgcGFuZWwgdGVzdGluZ1xyXG4gICBpZiAodHlwZSA9PT0gJ3NvbGFyUGFuZWwnKSB7XHJcbiAgICAgIG5ld01vZHVsZS5naXZlVGFyZ2V0ID0gc29sYXJQYW5lbEdpdmVUYXJnZXQ7XHJcbiAgICAgIG5ld01vZHVsZS5tb3VzZU92ZXIgPSBzb2xhclBhbmVsTW91c2VPdmVyO1xyXG4gICAgICBuZXdNb2R1bGUub25SZW1vdmUgPSBzb2xhclBhbmVsT25SZW1vdmU7XHJcbiAgIH1cclxuICAgXHJcbiAgIC8vVGhydXN0ZXIgbW9kdWxlIGV2ZW50c1xyXG5cdGlmKHR5cGUgPT09ICd0aHJ1c3RlcicpIHtcclxuICAgICAgaWYgKGZvclBsYXllcikge1xyXG4gICAgICAgICB2YXIgc3BhY2UgPSB0aGlzLmdhbWVTdGF0ZS5pbnB1dC5rZXlib2FyZC5hZGRLZXkoUGhhc2VyLktleWJvYXJkLlNQQUNFQkFSKTsgXHJcbiAgICAgICAgIHRoaXMuZ2FtZVN0YXRlLmlucHV0LmtleWJvYXJkLmFkZEtleUNhcHR1cmUoW3NwYWNlXSk7XHJcbiAgICAgICAgIC8vIHNwYWNlLm9uRG93bi5hZGQoYXBwbHlUaHJ1c3QsIG5ld01vZHVsZSk7XHJcbiAgICAgICAgIHNwYWNlLm9uRG93bi5hZGQoYmVnaW5UaHJ1c3QsIG5ld01vZHVsZSk7XHJcbiAgICAgICAgIHNwYWNlLm9uVXAuYWRkKGVuZFRocnVzdCwgbmV3TW9kdWxlKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgLy8gbmV3TW9kdWxlLnRocnVzdCA9IGZhbHNlO1xyXG4gICAgICAgICBuZXdNb2R1bGUuYmVnaW5UaHJ1c3QgPSBiZWdpblRocnVzdDtcclxuICAgICAgICAgbmV3TW9kdWxlLmVuZFRocnVzdCA9IGVuZFRocnVzdDtcclxuICAgICAgfVxyXG4gICAgICBuZXdNb2R1bGUudXBkYXRlID0gdGhydXN0ZXJVcGRhdGU7XHJcblx0fVxyXG5cdC8vUmV0dXJuIHRoZSBtb2R1bGUgb2JqZWN0XHJcblx0cmV0dXJuIG5ld01vZHVsZTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTW9kdWxlQnVpbGRlcjtcclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuIiwiLypcclxuRGVmaW5lcyBhIGN1YmUuXHJcbiovXHJcblxyXG52YXIgQ3ViZSA9IGZ1bmN0aW9uIChnYW1lLCB4LCB5LCBzcHJpdGUpIHtcclxuICAgIFBoYXNlci5TcHJpdGUuY2FsbCh0aGlzLCBnYW1lLCB4LCB5LCBzcHJpdGUpO1xyXG5cdCB0aGlzLnRhZyA9ICdtb2R1bGUnO1x0Ly90YWcgaXMgdXNlZCB0byBkZXRlY3Qgb2JqZWN0IHR5cGUgZHVyaW5nIGNvbGxpc2lvbiBjaGVja2luZ1xyXG4gICAgdGhpcy5nYW1lID0gZ2FtZTtcclxuICAgIHRoaXMuZ2FtZS5hZGQuZXhpc3RpbmcodGhpcyk7XHJcbiAgICB0aGlzLmdyb3VwID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5tb2R1bGUgPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLmluZGljYXRvckZhZGUgPSAwLjAyO1xyXG4gICAgdGhpcy5oZWFsdGggPSAzO1xyXG4gICAgdGhpcy5jb25zdHJhaW50cyA9IFtdO1xyXG4gICB0aGlzLnJhbUNvb2xkb3duID0gNTAwO1xyXG4gICB0aGlzLnJhbURlbGF5ID0gMDtcclxufTtcclxuXHJcbkN1YmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShQaGFzZXIuU3ByaXRlLnByb3RvdHlwZSk7XHJcbkN1YmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ3ViZTtcclxuXHJcbi8qKlxyXG4gKiBBdXRvbWF0aWNhbGx5IGNhbGxlZCBieSBXb3JsZC51cGRhdGVcclxuICovXHJcbkN1YmUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICBpZiAodGhpcy5jSW5kaWNhdG9yICYmIHRoaXMuY0luZGljYXRvci5hbHBoYSA+IDApIHtcclxuICAgICAgdGhpcy5jSW5kaWNhdG9yLmFscGhhIC09IHRoaXMuaW5kaWNhdG9yRmFkZTtcclxuICAgfVxyXG4gICBpZiAodGhpcy5tb2R1bGUudXBkYXRlKSB7XHJcbiAgICAgIHRoaXMubW9kdWxlLnVwZGF0ZSgpO1xyXG4gICB9XHJcbiAgIGlmICh0aGlzLnJhbURlbGF5ID4gMCkge1xyXG4gICAgICB0aGlzLnJhbURlbGF5IC09IHRoaXMuZ2FtZS50aW1lLmVsYXBzZWQ7XHJcbiAgIH1cclxufTtcclxuXHJcbkN1YmUucHJvdG90eXBlLnJlc2V0UmFtRGVsYXkgPSBmdW5jdGlvbigpIHtcclxuICB0aGlzLnJhbURlbGF5ID0gdGhpcy5yYW1Db29sZG93bjsgXHJcbn07XHJcblxyXG5DdWJlLnByb3RvdHlwZS5jdWJlQ29sbGlkZSA9IGZ1bmN0aW9uKG90aGVyKSB7XHJcbiAgIGlmICghdGhpcy5ncm91cCB8fCAhb3RoZXIgfHwgIW90aGVyLnNwcml0ZSB8fCBvdGhlci5zcHJpdGUua2V5ID09PSAnYXN0ZXJvaWQnKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgfVxyXG5cdHRoaXMuZ3JvdXAuaGFuZGxlQ29sbGlzaW9uKHRoaXMsIG90aGVyLnNwcml0ZSk7XHJcblx0dGhpcy5ncm91cC5jb3VudEN1YmVzKCk7XHJcbn07XHJcblxyXG5DdWJlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG4gICB2YXIgc3RyaW5nID0gJyc7XHJcbiAgIHN0cmluZyArPSB0aGlzLmNvbmNhdCgnbmFtZScsIHRoaXMubmFtZSk7XHJcbiAgIHJldHVybiBzdHJpbmc7XHJcbn07XHJcblxyXG5DdWJlLnByb3RvdHlwZS5jb25jYXQgPSBmdW5jdGlvbihzdHJpbmcsIHZhbCkge1xyXG4gICByZXR1cm4gc3RyaW5nICsgJzogJyArIHZhbCArICdcXG4nO1xyXG59O1xyXG5DdWJlLnByb3RvdHlwZS5kaXNwbGF5SW5kaWNhdG9yID0gZnVuY3Rpb24oKSB7XHJcbiAgdGhpcy5jSW5kaWNhdG9yLmFscGhhID0gMTsgXHJcbn07XHJcblxyXG5DdWJlLnByb3RvdHlwZS50YWtlRGFtYWdlID0gZnVuY3Rpb24oYW10KSB7XHJcbiAgIHRoaXMuaGVhbHRoIC09IGFtdDtcclxuICAgaWYgKHRoaXMuaGVhbHRoIDw9IDApIHtcclxuICAgICAgdGhpcy5ncm91cC5kZXN0cm95Q3ViZSh0aGlzKTtcclxuXHQgIC8vIHRoaXMuZ3JvdXAuY291bnRDdWJlcygpO1xyXG4gICB9XHJcbn07XHJcblxyXG5DdWJlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbigpIHtcclxuICAgaWYgKCF0aGlzLmdyb3VwKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgfVxyXG4gICB0aGlzLmdyb3VwLnJlbW92ZSh0aGlzKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ3ViZTtcclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG4iLCJ2YXIgQXN0YXIgPSByZXF1aXJlKCcuLi9saWJzL2phdmFzY3JpcHQtYXN0YXIvYXN0YXInKTtcclxudmFyIEVuZW15QUkgPSByZXF1aXJlKCcuL2VuZW15X2FpJyk7XHJcblxyXG4vKlxyXG5EZWZpbmVzIGEgY3ViZSBncm91cC5cclxuKi9cclxuXHJcbnZhciBDdWJlR3JvdXAgPSBmdW5jdGlvbiAoZ2FtZSwgcm9vdCkge1xyXG4gICB0aGlzLmdhbWUgPSBnYW1lO1xyXG4gICB0aGlzLnJvb3QgPSByb290O1xyXG4gICB0aGlzLmN1YmVzID0gW107XHJcbiAgIHZhciBjb2wgPSBbXTtcclxuICAgY29sLnB1c2godGhpcy5yb290KTtcclxuICAgdGhpcy5jdWJlcy5wdXNoKGNvbCk7XHJcbiAgIGlmICh0aGlzLnJvb3QpIHtcclxuICAgICAgdGhpcy5yb290Lmdyb3VwID0gdGhpcztcclxuICAgfVxyXG4gICB0aGlzLkRJUiA9IHtOT1JUSDogMCwgRUFTVDogMSwgU09VVEg6IDIsIFdFU1Q6IDN9O1xyXG4gICB0aGlzLm9mZnNldCA9IDI7XHJcblx0dGhpcy5oYWNrZXJNb2R1bGVzID0gW107XHQvL2xpc3Qgb2YgaGFja2VyIG1vZHVsZXMgaW4gdGhpcyBncm91cFxyXG5cclxuICAgdGhpcy5udW1DdWJlcyA9IDE7XHJcbiAgIC8qXHJcbiAgIHRoaXMuc3Bhd25pbmcgPSBmYWxzZTtcclxuICAgdGhpcy5zcGF3bkdyaWQgPSBbXTtcclxuICAgdGhpcy5zcGF3bkRlbGF5ID0gMTAwO1xyXG4gICB0aGlzLmN1clNwYXduRGVsYXkgPSAwO1xyXG4gICB0aGlzLnNwYXduUm93ID0gMDtcclxuICAgdGhpcy5zcGF3bkNvbCA9IDA7XHJcbiAgICovXHJcbn07XHJcblxyXG5DdWJlR3JvdXAucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ3ViZUdyb3VwO1xyXG5cclxuLyoqXHJcbiAqIEF1dG9tYXRpY2FsbHkgY2FsbGVkIGJ5IFdvcmxkLnVwZGF0ZVxyXG4gKi9cclxuQ3ViZUdyb3VwLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpIHtcclxuICAgLypcclxuICAgaWYgKHRoaXMuc3Bhd25pbmcpIHtcclxuICAgICAgaWYgKHRoaXMuc3Bhd25Sb3cgPj0gdGhpcy5zcGF3bkdyaWQubGVuZ3RoKSB7XHJcbiAgICAgICAgIHRoaXMuc3Bhd25pbmcgPSBmYWxzZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgaWYgKHRoaXMuc3Bhd25Db2wgPj0gdGhpcy5zcGF3bkdyaWRbdGhpcy5zcGF3blJvd10ubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3Bhd25Sb3crKztcclxuICAgICAgICAgICAgdGhpcy5zcGF3bkNvbCA9IDA7XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgaWYgKHRoaXMuY3VyU3Bhd25EZWxheSA+IDApIHtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgIH1cclxuICAgICAgfVxyXG4gICB9IGVsc2UgaWYgKHRoaXMuQUkpIHtcclxuICAgICAgdGhpcy5BSS51cGRhdGUoKTtcclxuICAgfVxyXG4gICAqL1xyXG4gICBpZiAodGhpcy5BSSkge1xyXG4gICAgICB0aGlzLkFJLnVwZGF0ZSgpO1xyXG4gICB9XHJcbn07XHJcblxyXG5DdWJlR3JvdXAucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbihmdW4pIHtcclxuICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgdGhpcy5jdWJlc1dpZHRoKCk7IHJvdysrKSB7XHJcbiAgICAgIGZvciAodmFyIGNvbCA9IDA7IGNvbCA8IHRoaXMuY3ViZXNIZWlnaHQoKTsgY29sKyspIHtcclxuICAgICAgICAgdmFyIGN1YmUgPSB0aGlzLmN1YmVzW3Jvd11bY29sXTtcclxuICAgICAgICAgaWYgKGN1YmUgJiYgY3ViZS5oYXNPd25Qcm9wZXJ0eShmdW4pKSB7XHJcbiAgICAgICAgICAgIC8vIGlmIGN1YmVzIG5lZWQgZnVuY3Rpb25zIGNhbGxlZFxyXG4gICAgICAgICB9IGVsc2UgaWYgKGN1YmUgJiYgY3ViZS5tb2R1bGUgJiYgY3ViZS5tb2R1bGUuaGFzT3duUHJvcGVydHkoZnVuKSkge1xyXG4gICAgICAgICAgICB2YXIgZm4gPSBjdWJlLm1vZHVsZVtmdW5dO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgIGZuLmNhbGwoY3ViZS5tb2R1bGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgIH1cclxuICAgICAgfVxyXG4gICB9XHJcbn07XHJcblxyXG5DdWJlR3JvdXAucHJvdG90eXBlLmdpdmVBSSA9IGZ1bmN0aW9uKHR5cGUsIHBsYXllcikge1xyXG4gICB0aGlzLkFJID0gbmV3IEVuZW15QUkodGhpcy5nYW1lLCB0aGlzLCB0eXBlLCBwbGF5ZXIpO1xyXG59O1xyXG5cclxuQ3ViZUdyb3VwLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihjdWJlLCBwb2ludCkge1xyXG4gIGlmICghdGhpcy5yb290ICYmIGN1YmUubW9kdWxlLnR5cGUgPT09ICdjb3JlJykge1xyXG4gICAgIHRoaXMucm9vdCA9IGN1YmU7XHJcbiAgfVxyXG4gIGN1YmUuZ3JvdXAgPSB0aGlzO1xyXG4gIHRoaXMuc2V0KGN1YmUsIHBvaW50KTtcclxuICB0aGlzLmNyZWF0ZUNvbnN0cmFpbnRzKGN1YmUsIHBvaW50KTtcclxuICAvLyB0aGlzLmRpc3BsYXlDdWJlcygpO1xyXG59O1xyXG5cclxuLypcclxuQ3ViZUdyb3VwLnByb3RvdHlwZS5hZGRPdmVyVGltZSA9IGZ1bmN0aW9uKGdyaWQpIHtcclxuICAgdGhpcy5zcGF3bmluZyA9IHRydWU7XHJcbiAgIHRoaXMuc3Bhd25HcmlkID0gZ3JpZDtcclxuICAgdGhpcy5zcGF3blJvdyA9IDA7XHJcbiAgIHRoaXMuc3Bhd25Db2wgPSAwO1xyXG59O1xyXG4qL1xyXG5cclxuQ3ViZUdyb3VwLnByb3RvdHlwZS5oYW5kbGVDb2xsaXNpb24gPSBmdW5jdGlvbihvcmlnaW4sIG90aGVyKSB7XHJcbiAgIC8vIHN0b3AgaWYgb3RoZXIgZG9lcyBub3QgZXhpc3QsIGVpdGhlciBpcyBub3QgYSBjdWJlLCBib3RoIGFyZSBpbiBzYW1lIGdyb3VwXHJcblx0aWYgKG90aGVyID09PSBudWxsIHx8IG9yaWdpbi5wcm90b3R5cGUgIT09IG90aGVyLnByb3RvdHlwZSB8fCBvcmlnaW4uZ3JvdXAgPT09IG90aGVyLmdyb3VwIHx8IG90aGVyLnRhZyAhPSAnbW9kdWxlJykge1xyXG5cdFx0cmV0dXJuO1xyXG5cdH1cclxuICAgaWYgKG90aGVyLmdyb3VwICYmIG90aGVyLmdyb3VwICE9PSB0aGlzICYmIG9yaWdpbi5yYW1EZWxheSA8PSAwKSB7XHJcbiAgICAgIC8vIGNvbnNvbGUubG9nKG9yaWdpbi5uYW1lLCAncmFtbWluZyBkYW1hZ2UhJyk7XHJcbiAgICAgIG90aGVyLnRha2VEYW1hZ2UoMSk7XHJcbiAgICAgIG9yaWdpbi5yZXNldFJhbURlbGF5KCk7XHJcbiAgIH0gZWxzZSBpZiAoIW90aGVyLmdyb3VwICYmIHRoaXMuaXNQbGF5ZXIpIHtcdFx0XHJcblx0XHQvL0NoZWNrIGlmIG9uZSBvZiB0aGVzZSB0d28gaXMgYSBoYWNrZXIgbW9kdWxlLCBpZiBzbyBhZGQgaXQgdG8gdGhlIG90aGVyJ3MgaGFja2VyTW9kdWxlcyBsaXN0XHJcblx0ICAgaWYoIW9yaWdpbi5ncm91cCkge1xyXG5cdFx0XHRpZihvcmlnaW4ubW9kdWxlLnR5cGUgPT0gJ2hhY2tlcicpIHtcclxuXHRcdFx0XHRvdGhlci5ncm91cC5oYWNrZXJNb2R1bGVzLnB1c2gob3JpZ2luLm1vZHVsZSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdGlmKCFvdGhlci5ncm91cCkge1xyXG5cdFx0XHRpZihvdGhlci5tb2R1bGUudHlwZSA9PSAnaGFja2VyJykge1xyXG5cdFx0XHRcdG9yaWdpbi5ncm91cC5oYWNrZXJNb2R1bGVzLnB1c2gob3RoZXIubW9kdWxlKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0dmFyIHJlbFNpZGUgPSB0aGlzLnJlbGF0aXZlU2lkZShvcmlnaW4uYm9keSwgb3RoZXIuYm9keSk7XHJcblx0XHR2YXIgb3JpZ2luTG9jID0gdGhpcy5maW5kKG9yaWdpbik7XHJcblx0XHR2YXIgb3RoZXJMb2MgPSB0aGlzLmFkanVzdChvcmlnaW5Mb2MsIHJlbFNpZGUpO1xyXG5cdFx0dGhpcy5zZXQob3RoZXIsIG90aGVyTG9jKTtcclxuXHRcdG90aGVyTG9jID0gdGhpcy5maW5kKG90aGVyKTsgLy8gdXBkYXRlIHBvc2l0aW9uIHNpbmNlIHNldCBjYW4gc2hpZnQgZ3JpZFxyXG5cdFx0aWYgKCFvdGhlckxvYykge1xyXG5cdFx0XHQvLyBjb25zb2xlLmxvZygnaGFuZGxlIGNvbGxpc2lvbiBmYWlsZWQgdG8gZmluZCBwb3NpdGlvbiBmb3IgZ29vZCBhcHBsaWNhbnQnKTtcclxuXHRcdFx0cmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuY3JlYXRlQ29uc3RyYWludHMob3RoZXIsIG90aGVyTG9jKTtcclxuICAgICAgLy8gY29uc29sZS5sb2cob3RoZXIuYm9keS5jb2xsaWRlc1dpdGgpO1xyXG4gICAgICAvLyB0aGlzLmRpc3BsYXlDdWJlcygpO1xyXG4gICB9XHJcbn07XHJcblxyXG5DdWJlR3JvdXAucHJvdG90eXBlLmNyZWF0ZUNvbnN0cmFpbnRzID0gZnVuY3Rpb24obWUsIHBvaW50KSB7XHJcbiAgIC8vIHRoaXMuZGlzcGxheUN1YmVzKCk7XHJcbiAgIHZhciBteU5vcnRoID0gdGhpcy5nZXQodGhpcy5hZGp1c3QocG9pbnQsIHRoaXMuRElSLk5PUlRIKSk7XHJcbiAgIHZhciBteUVhc3QgPSB0aGlzLmdldCh0aGlzLmFkanVzdChwb2ludCwgdGhpcy5ESVIuRUFTVCkpO1xyXG4gICB2YXIgbXlTb3V0aCA9IHRoaXMuZ2V0KHRoaXMuYWRqdXN0KHBvaW50LCB0aGlzLkRJUi5TT1VUSCkpO1xyXG4gICB2YXIgbXlXZXN0ID0gdGhpcy5nZXQodGhpcy5hZGp1c3QocG9pbnQsIHRoaXMuRElSLldFU1QpKTtcclxuICAgdmFyIGNvbnN0cmFpbnQ7XHJcbiAgIGlmIChteU5vcnRoKSB7XHJcbiAgICAgIGNvbnN0cmFpbnQgPSB0aGlzLmdhbWUucGh5c2ljcy5wMi5jcmVhdGVMb2NrQ29uc3RyYWludChtZS5ib2R5LCBteU5vcnRoLmJvZHksIFswLCBtZS53aWR0aCArIHRoaXMub2Zmc2V0XSk7IC8vIG1lIC0gbm9ydGhcclxuICAgICAgbWUuY29uc3RyYWludHMucHVzaChjb25zdHJhaW50KTtcclxuICAgICAgbXlOb3J0aC5jb25zdHJhaW50cy5wdXNoKGNvbnN0cmFpbnQpO1xyXG4gICB9XHJcbiAgIGlmIChteUVhc3QpIHtcclxuICAgICAgY29uc3RyYWludCA9IHRoaXMuZ2FtZS5waHlzaWNzLnAyLmNyZWF0ZUxvY2tDb25zdHJhaW50KG1lLmJvZHksIG15RWFzdC5ib2R5LCBbLW1lLndpZHRoIC0gdGhpcy5vZmZzZXQsIDBdKTsgLy8gbWUgLSBlYXN0XHJcbiAgICAgIG1lLmNvbnN0cmFpbnRzLnB1c2goY29uc3RyYWludCk7XHJcbiAgICAgIG15RWFzdC5jb25zdHJhaW50cy5wdXNoKGNvbnN0cmFpbnQpO1xyXG4gICB9XHJcbiAgIGlmIChteVNvdXRoKSB7XHJcbiAgICAgIGNvbnN0cmFpbnQgPSB0aGlzLmdhbWUucGh5c2ljcy5wMi5jcmVhdGVMb2NrQ29uc3RyYWludChteVNvdXRoLmJvZHksIG1lLmJvZHksIFswLCBtZS53aWR0aCArIHRoaXMub2Zmc2V0XSk7IC8vIHNvdXRoIC0gbWVcclxuICAgICAgbWUuY29uc3RyYWludHMucHVzaChjb25zdHJhaW50KTtcclxuICAgICAgbXlTb3V0aC5jb25zdHJhaW50cy5wdXNoKGNvbnN0cmFpbnQpO1xyXG4gICB9XHJcbiAgIGlmIChteVdlc3QpIHtcclxuICAgICAgY29uc3RyYWludCA9IHRoaXMuZ2FtZS5waHlzaWNzLnAyLmNyZWF0ZUxvY2tDb25zdHJhaW50KG15V2VzdC5ib2R5LCBtZS5ib2R5LCBbLW1lLndpZHRoIC0gdGhpcy5vZmZzZXQsIDBdKTsgLy8gd2VzdCAtIG1lXHJcbiAgICAgIG1lLmNvbnN0cmFpbnRzLnB1c2goY29uc3RyYWludCk7XHJcbiAgICAgIG15V2VzdC5jb25zdHJhaW50cy5wdXNoKGNvbnN0cmFpbnQpO1xyXG4gICB9XHJcbn07XHJcblxyXG5DdWJlR3JvdXAucHJvdG90eXBlLnJlbGF0aXZlU2lkZSA9IGZ1bmN0aW9uKHRoaXNCb2R5LCBvdGhlckJvZHkpIHtcclxuICB2YXIgdGhpc1BvaW50ID0gbmV3IFBoYXNlci5Qb2ludCh0aGlzQm9keS54LCB0aGlzQm9keS55KTtcclxuICB2YXIgb3RoZXJQb2ludCA9IG5ldyBQaGFzZXIuUG9pbnQob3RoZXJCb2R5LngsIG90aGVyQm9keS55KTtcclxuICB2YXIgYW5nbGVUb090aGVyID0gUGhhc2VyLlBvaW50LmFuZ2xlKHRoaXNQb2ludCwgb3RoZXJQb2ludCk7XHJcbiAgaWYgKGFuZ2xlVG9PdGhlciA8IDApIHsgLy8gZml4IGR1bWIgcGFydCBvZiBQaGFzZXIuUG9pbnQuYW5nbGUoKVxyXG4gICAgIGFuZ2xlVG9PdGhlciA9IDIgKiBNYXRoLlBJICsgYW5nbGVUb090aGVyO1xyXG4gIH1cclxuICBhbmdsZVRvT3RoZXIgPSAoYW5nbGVUb090aGVyICsgMy8yICogTWF0aC5QSSkgJSAoMiAqIE1hdGguUEkpOyAvLyByb3RhdGUgOTAgZCBjbG9ja3dpc2VcclxuICB2YXIgZGlmZkFuZ2xlID0gTWF0aC5hYnMoTWF0aC5hYnMoYW5nbGVUb090aGVyKSAtIE1hdGguYWJzKHRoaXNCb2R5LnJvdGF0aW9uKSk7XHJcbiAgIGlmIChkaWZmQW5nbGUgPCAxIC8gNCAqIE1hdGguUEkgfHwgZGlmZkFuZ2xlID4gNyAvIDQgKiBNYXRoLlBJKSB7IC8vIG5vcnRoXHJcbiAgICAgcmV0dXJuIHRoaXMuRElSLk5PUlRIO1xyXG4gIH0gZWxzZSBpZiAoZGlmZkFuZ2xlID49IDEgLyA0ICogTWF0aC5QSSAmJiBkaWZmQW5nbGUgPCAzIC8gNCAqIE1hdGguUEkpIHsgLy8gZWFzdFxyXG4gICAgIHJldHVybiB0aGlzLkRJUi5FQVNUO1xyXG4gIH0gZWxzZSBpZiAoZGlmZkFuZ2xlID49IDMgLyA0ICogTWF0aC5QSSAmJiBkaWZmQW5nbGUgPCA1IC8gNCAqIE1hdGguUEkpIHsgLy8gc291dGhcclxuICAgICByZXR1cm4gdGhpcy5ESVIuU09VVEg7XHJcbiAgfSBlbHNlIGlmIChkaWZmQW5nbGUgPj0gNSAvIDQgKiBNYXRoLlBJICYmIGRpZmZBbmdsZSA8IDcgLyA0ICogTWF0aC5QSSkgeyAvLyB3ZXN0XHJcbiAgICAgcmV0dXJuIHRoaXMuRElSLldFU1Q7XHJcbiAgfVxyXG59O1xyXG5cclxuLypcclxuQ3ViZUdyb3VwLnByb3RvdHlwZS5zZXRSb3RhdGlvbiA9IGZ1bmN0aW9uKHJvdGF0aW9uKSB7XHJcbiAgIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IHRoaXMuY3ViZXNXaWR0aCgpOyByb3crKykge1xyXG4gICAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCB0aGlzLmN1YmVzSGVpZ2h0KCk7IGNvbCsrKSB7XHJcbiAgICAgICAgIHRoaXMuY3ViZXNbcm93XVtjb2xdLmJvZHkucm90YXRpb24gPSByb3RhdGlvbjtcclxuICAgICAgfVxyXG4gICB9XHJcbiAgIHRoaXMucm9vdC5ib2R5LnJvdGF0aW9uID0gcm90YXRpb247XHJcbn07XHJcbiovXHJcblxyXG5DdWJlR3JvdXAucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbihjdWJlKSB7XHJcbiAgIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IHRoaXMuY3ViZXNXaWR0aCgpOyByb3crKykge1xyXG4gICAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCB0aGlzLmN1YmVzSGVpZ2h0KCk7IGNvbCsrKSB7XHJcbiAgICAgICAgIGlmICh0aGlzLmN1YmVzW3Jvd11bY29sXSA9PT0gY3ViZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBoYXNlci5Qb2ludChyb3csIGNvbCk7XHJcbiAgICAgICAgIH1cclxuICAgICAgfVxyXG4gICB9XHJcbiAgIHJldHVybiB1bmRlZmluZWQ7XHJcbn07XHJcblxyXG5DdWJlR3JvdXAucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKHBvaW50KSB7XHJcbiAgaWYgKCFwb2ludCB8fCB0aGlzLm91dE9mQm91bmRzKHBvaW50KSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgfVxyXG4gIHJldHVybiB0aGlzLmN1YmVzW3BvaW50LnhdW3BvaW50LnldO1xyXG59O1xyXG5cclxuQ3ViZUdyb3VwLnByb3RvdHlwZS5jdWJlc1dpZHRoID0gZnVuY3Rpb24oKSB7XHJcbiAgIHJldHVybiB0aGlzLmN1YmVzLmxlbmd0aDtcclxufTtcclxuXHJcbkN1YmVHcm91cC5wcm90b3R5cGUuY3ViZXNIZWlnaHQgPSBmdW5jdGlvbigpIHtcclxuICAgcmV0dXJuIHRoaXMuY3ViZXNbMF0ubGVuZ3RoO1xyXG59O1xyXG5cclxuQ3ViZUdyb3VwLnByb3RvdHlwZS5hZGRUb3BSb3cgPSBmdW5jdGlvbigpIHtcclxuICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgdGhpcy5jdWJlc1dpZHRoKCk7IHJvdysrKSB7XHJcbiAgICAgIHRoaXMuY3ViZXNbcm93XS5wdXNoKHVuZGVmaW5lZCk7XHJcbiAgIH1cclxufTtcclxuXHJcbkN1YmVHcm91cC5wcm90b3R5cGUuYWRkUmlnaHRDb2wgPSBmdW5jdGlvbigpIHtcclxuICAgdmFyIG5ld0NvbCA9IFtdO1xyXG4gICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY3ViZXNIZWlnaHQoKTsgaSsrKSB7XHJcbiAgICAgIG5ld0NvbC5wdXNoKHVuZGVmaW5lZCk7XHJcbiAgIH1cclxuICAgdGhpcy5jdWJlcy5wdXNoKG5ld0NvbCk7XHJcbn07XHJcblxyXG5DdWJlR3JvdXAucHJvdG90eXBlLmFkZEJvdFJvdyA9IGZ1bmN0aW9uKCkge1xyXG4gICBmb3IgKHZhciByb3cgPSAwOyByb3cgPCB0aGlzLmN1YmVzV2lkdGgoKTsgcm93KyspIHtcclxuICAgICAgdGhpcy5jdWJlc1tyb3ddLnVuc2hpZnQodW5kZWZpbmVkKTtcclxuICAgfVxyXG59O1xyXG5cclxuQ3ViZUdyb3VwLnByb3RvdHlwZS5hZGRMZWZ0Q29sID0gZnVuY3Rpb24oKSB7XHJcbiAgIHZhciBuZXdDb2wgPSBuZXcgQXJyYXkodGhpcy5jdWJlc0hlaWdodCgpKTtcclxuICAgdGhpcy5jdWJlcy51bnNoaWZ0KG5ld0NvbCk7XHJcbn07XHJcblxyXG5DdWJlR3JvdXAucHJvdG90eXBlLmdldEN1YmUgPSBmdW5jdGlvbihwb2ludCkge1xyXG4gICBpZiAoIXBvaW50IHx8IHRoaXMub3V0T2ZCb3VuZHMocG9pbnQpKSB7XHJcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgIH1cclxuICAgcmV0dXJuIHRoaXMuY3ViZXNbcG9pbnQueF1bcG9pbnQueV07XHJcbn07XHJcblxyXG5DdWJlR3JvdXAucHJvdG90eXBlLmFkanVzdCA9IGZ1bmN0aW9uKHBvaW50LCBkaXIpIHtcclxuICBpZiAoIXBvaW50KSB7XHJcbiAgICAgcmV0dXJuO1xyXG4gIH1cclxuICB2YXIgbmV3UG9pbnQgPSBuZXcgUGhhc2VyLlBvaW50KHBvaW50LngsIHBvaW50LnkpO1xyXG4gIHN3aXRjaCAoZGlyKSB7XHJcbiAgICAgIGNhc2UgdGhpcy5ESVIuTk9SVEg6XHJcbiAgICAgIG5ld1BvaW50LnkrKztcclxuICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgdGhpcy5ESVIuRUFTVDpcclxuICAgICAgbmV3UG9pbnQueCsrO1xyXG4gICAgICBicmVhaztcclxuICAgICAgY2FzZSB0aGlzLkRJUi5TT1VUSDpcclxuICAgICAgbmV3UG9pbnQueS0tO1xyXG4gICAgICBicmVhaztcclxuICAgICAgY2FzZSB0aGlzLkRJUi5XRVNUOlxyXG4gICAgICBuZXdQb2ludC54LS07XHJcbiAgICAgIGJyZWFrO1xyXG4gICB9XHJcbiAgIHJldHVybiBuZXdQb2ludDtcclxufTtcclxuXHJcbkN1YmVHcm91cC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oY3ViZSwgcG9pbnQpIHtcclxuICAgaWYgKCFwb2ludCkge1xyXG4gICAgICBjb25zb2xlLmxvZygnc2V0IGdpdmVuIHVuZGVmaW5lZCBwb2ludCcpO1xyXG4gICAgICByZXR1cm47XHJcbiAgIH1cclxuICAgaWYgKHBvaW50LnggPCAwKSB7XHJcbiAgICAgIHRoaXMuYWRkTGVmdENvbCgpO1xyXG4gICAgICBwb2ludC54ID0gMDtcclxuICAgfSBlbHNlIGlmIChwb2ludC54ID49IHRoaXMuY3ViZXNXaWR0aCgpKSB7XHJcbiAgICAgIHRoaXMuYWRkUmlnaHRDb2woKTtcclxuICAgICAgcG9pbnQueCA9IHRoaXMuY3ViZXNXaWR0aCgpIC0gMTtcclxuICAgfSBlbHNlIGlmIChwb2ludC55IDwgMCkge1xyXG4gICAgICB0aGlzLmFkZEJvdFJvdygpO1xyXG4gICAgICBwb2ludC55ID0gMDtcclxuICAgfSBlbHNlIGlmIChwb2ludC55ID49IHRoaXMuY3ViZXNIZWlnaHQoKSkge1xyXG4gICAgICB0aGlzLmFkZFRvcFJvdygpO1xyXG4gICAgICBwb2ludC55ID0gdGhpcy5jdWJlc0hlaWdodCgpIC0gMTtcclxuICAgfVxyXG4gICBpZiAodGhpcy5nZXQocG9pbnQpKSB7XHJcbiAgICAgIC8vIGNvbnNvbGUubG9nKCd0cmllZCB0byBzZXQgdG8gZmlsbGVkIHBvc2l0aW9uJyk7XHJcbiAgICAgIHJldHVybjtcclxuICAgfVxyXG4gICB0aGlzLmN1YmVzW3BvaW50LnhdW3BvaW50LnldID0gY3ViZTtcclxuICAgY3ViZS5ncm91cCA9IHRoaXM7XHJcbn07XHJcblxyXG5DdWJlR3JvdXAucHJvdG90eXBlLm91dE9mQm91bmRzID0gZnVuY3Rpb24ocG9pbnQpIHtcclxuICAgaWYgKCFwb2ludCkge1xyXG4gICAgICBjb25zb2xlLmxvZygnb3V0IG9mIGJvdW5kcyBnaXZlbiB1bmRlZmluZWQgcG9pbnQnKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICB9XHJcbiAgIGlmIChwb2ludC54IDwgMCB8fCBwb2ludC54ID49IHRoaXMuY3ViZXNXaWR0aCgpIHx8IHBvaW50LnkgPCAwIHx8IHBvaW50LnkgPj0gdGhpcy5jdWJlc0hlaWdodCgpKSB7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICB9XHJcbiAgIHJldHVybiBmYWxzZTtcclxufTtcclxuXHJcbkN1YmVHcm91cC5wcm90b3R5cGUuZGlzcGxheUN1YmVzID0gZnVuY3Rpb24oKSB7XHJcbiAgIGNvbnNvbGUubG9nKCc9PT09PT09PT09PT09PT09Jyk7XHJcbiAgIHZhciBvdXRwdXQgPSAnRGlzcGxheSBDdWJlc1xcbic7XHJcbiAgIHZhciByb3cgPSAwO1xyXG4gICB2YXIgY29sID0gdGhpcy5jdWJlc0hlaWdodCgpIC0gMTtcclxuICAgd2hpbGUgKGNvbCA+PSAwKSB7XHJcbiAgICAgIHdoaWxlIChyb3cgPCB0aGlzLmN1YmVzV2lkdGgoKSkge1xyXG4gICAgICAgICB2YXIgY3ViZSA9IHRoaXMuY3ViZXNbcm93XVtjb2xdO1xyXG4gICAgICAgICBpZiAoY3ViZSkge1xyXG4gICAgICAgICAgICBvdXRwdXQgKz0gJyMgJztcclxuICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgb3V0cHV0ICs9ICdfICc7XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgcm93Kys7XHJcbiAgICAgIH1cclxuICAgICAgcm93ID0gMDtcclxuICAgICAgY29sLS07XHJcbiAgICAgIG91dHB1dCArPSAnXFxuJztcclxuICAgfVxyXG4gICBjb25zb2xlLmxvZyhvdXRwdXQpO1xyXG4gICBjb25zb2xlLmxvZygnLS0tLS0tLS0tLS0tLS0tJyk7XHJcbn07XHJcblxyXG5DdWJlR3JvdXAucHJvdG90eXBlLmRpc3BsYXlDb25uZWN0aW9uID0gZnVuY3Rpb24oY29ubmVjdGlvbikge1xyXG4gICB2YXIgZ3JhcGggPSBuZXcgQXN0YXIuR3JhcGgodGhpcy5jdWJlc1RvR3JhcGgoKSk7XHJcbiAgIHZhciBzdGFydFBvaW50ID0gdGhpcy5maW5kKGNvbm5lY3Rpb24uc3RhcnQpO1xyXG4gICB2YXIgZW5kUG9pbnQgPSB0aGlzLmZpbmQoY29ubmVjdGlvbi5lbmQpO1xyXG4gICBpZiAoIXN0YXJ0UG9pbnQgfHwgIWVuZFBvaW50KSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdkaXNwbGF5Q29ubmVjdGlvbiBmYWlsZWQgdG8gZ2V0IHBvaW50cycpO1xyXG4gICAgICByZXR1cm47XHJcbiAgIH1cclxuICAgdmFyIHN0YXJ0ID0gZ3JhcGguZ3JpZFtzdGFydFBvaW50LnhdW3N0YXJ0UG9pbnQueV07XHJcbiAgIHZhciBlbmQgPSBncmFwaC5ncmlkW2VuZFBvaW50LnhdW2VuZFBvaW50LnldO1xyXG4gICB2YXIgcmVzdWx0ID0gQXN0YXIuYXN0YXIuc2VhcmNoKGdyYXBoLCBzdGFydCwgZW5kKTtcclxuICAgcmVzdWx0LnVuc2hpZnQoc3RhcnQpO1xyXG4gICB2YXIgcHJldmlvdXM7XHJcbiAgIGZvcih2YXIgaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgdmFyIGN1clBvaW50ID0gbmV3IFBoYXNlci5Qb2ludChyZXN1bHRbaV0ueCwgcmVzdWx0W2ldLnkpO1xyXG4gICAgICB2YXIgY3VyID0gdGhpcy5nZXQoY3VyUG9pbnQpO1xyXG4gICAgICB2YXIgaW5kaWNhdG9yID0gY3VyLmNJbmRpY2F0b3I7XHJcbiAgICAgIHZhciBkaXI7XHJcbiAgICAgIHZhciBwcmV2UG9pbnQ7XHJcbiAgICAgIHZhciBuZXh0UG9pbnQ7XHJcbiAgICAgIGlmICghcHJldmlvdXMpIHtcclxuICAgICAgICAgaW5kaWNhdG9yLmFuaW1hdGlvbnMucGxheSgnZW5kJyk7XHJcbiAgICAgICAgIG5leHRQb2ludCA9IG5ldyBQaGFzZXIuUG9pbnQocmVzdWx0W2krMV0ueCwgcmVzdWx0W2krMV0ueSk7XHJcbiAgICAgICAgIGRpciA9IHRoaXMuZGlyQmV0d2VlbihjdXJQb2ludCwgbmV4dFBvaW50KTtcclxuICAgICAgICAgaW5kaWNhdG9yLnJvdGF0aW9uID0gdGhpcy5kaXJUb0FuZ2xlKGRpcik7XHJcbiAgICAgIH0gZWxzZSBpZiAoaSA9PT0gcmVzdWx0Lmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgaW5kaWNhdG9yLmFuaW1hdGlvbnMucGxheSgnZW5kJyk7XHJcbiAgICAgICAgIHByZXZQb2ludCA9IG5ldyBQaGFzZXIuUG9pbnQocHJldmlvdXMueCwgcHJldmlvdXMueSk7XHJcbiAgICAgICAgIGRpciA9IHRoaXMuZGlyQmV0d2VlbihjdXJQb2ludCwgcHJldlBvaW50KTtcclxuICAgICAgICAgaW5kaWNhdG9yLnJvdGF0aW9uID0gdGhpcy5kaXJUb0FuZ2xlKGRpcik7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgIGluZGljYXRvci5hbmltYXRpb25zLnBsYXkoJ2xpbmUnKTtcclxuICAgICAgICAgcHJldlBvaW50ID0gbmV3IFBoYXNlci5Qb2ludChwcmV2aW91cy54LCBwcmV2aW91cy55KTtcclxuICAgICAgICAgdmFyIHByZXZEaXIgPSB0aGlzLmRpckJldHdlZW4oY3VyUG9pbnQsIHByZXZQb2ludCk7XHJcbiAgICAgICAgIG5leHRQb2ludCA9IG5ldyBQaGFzZXIuUG9pbnQocmVzdWx0W2krMV0ueCwgcmVzdWx0W2krMV0ueSk7XHJcbiAgICAgICAgIHZhciBuZXh0RGlyID0gdGhpcy5kaXJCZXR3ZWVuKGN1clBvaW50LCBuZXh0UG9pbnQpO1xyXG4gICAgICAgICB0aGlzLm1hbmFnZUluZGljYXRvcihpbmRpY2F0b3IsIHByZXZEaXIsIG5leHREaXIpO1xyXG4gICAgICB9XHJcbiAgICAgIHByZXZpb3VzID0gcmVzdWx0W2ldO1xyXG4gICAgICBjdXIuZGlzcGxheUluZGljYXRvcigpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuQ3ViZUdyb3VwLnByb3RvdHlwZS5tYW5hZ2VJbmRpY2F0b3IgPSBmdW5jdGlvbihpbmRpY2F0b3IsIHByZXZEaXIsIG5leHREaXIpIHtcclxuICBpbmRpY2F0b3Iuc2NhbGUuc2V0VG8oTWF0aC5hYnMoaW5kaWNhdG9yLnNjYWxlLngpLCBpbmRpY2F0b3Iuc2NhbGUueSk7XHJcbiAgaWYgKHByZXZEaXIgPT09IHRoaXMuRElSLk5PUlRIICYmIG5leHREaXIgPT09IHRoaXMuRElSLlNPVVRIKSB7IC8vIDJcclxuICAgICAgaW5kaWNhdG9yLnJvdGF0aW9uID0gTWF0aC5QSTtcclxuICAgfSBlbHNlIGlmIChwcmV2RGlyID09PSB0aGlzLkRJUi5TT1VUSCAmJiBuZXh0RGlyID09PSB0aGlzLkRJUi5OT1JUSCkgeyAvLyAxXHJcbiAgICAgIGluZGljYXRvci5yb3RhdGlvbiA9IDA7XHJcbiAgIH0gZWxzZSBpZiAocHJldkRpciA9PT0gdGhpcy5ESVIuRUFTVCAmJiBuZXh0RGlyID09PSB0aGlzLkRJUi5XRVNUKSB7IC8vIDRcclxuICAgICAgaW5kaWNhdG9yLnJvdGF0aW9uID0gMSAvIDIgKiBNYXRoLlBJO1xyXG4gICB9IGVsc2UgaWYgKHByZXZEaXIgPT09IHRoaXMuRElSLldFU1QgJiYgbmV4dERpciA9PT0gdGhpcy5ESVIuRUFTVCkgeyAvLyAzXHJcbiAgICAgIGluZGljYXRvci5yb3RhdGlvbiA9IDMgLyAyICAqIE1hdGguUEk7XHJcbiAgIH0gZWxzZSB7XHJcbiAgICAgIGluZGljYXRvci5hbmltYXRpb25zLnBsYXkoJ3JpZ2h0Jyk7XHJcbiAgICAgIGlmIChwcmV2RGlyID09PSB0aGlzLkRJUi5TT1VUSCAmJiBuZXh0RGlyID09PSB0aGlzLkRJUi5FQVNUKSB7IC8vIDVcclxuICAgICAgICAgaW5kaWNhdG9yLnJvdGF0aW9uID0gMDtcclxuICAgICAgfSBlbHNlIGlmIChwcmV2RGlyID09PSB0aGlzLkRJUi5XRVNUICYmIG5leHREaXIgPT09IHRoaXMuRElSLlNPVVRIKSB7IC8vIDZcclxuICAgICAgICAgaW5kaWNhdG9yLnJvdGF0aW9uID0gMSAvIDIgKiBNYXRoLlBJO1xyXG4gICAgICB9IGVsc2UgaWYgKHByZXZEaXIgPT09IHRoaXMuRElSLk5PUlRIICYmIG5leHREaXIgPT09IHRoaXMuRElSLldFU1QpIHsgLy8gN1xyXG4gICAgICAgICBpbmRpY2F0b3Iucm90YXRpb24gPSBNYXRoLlBJO1xyXG4gICAgICB9IGVsc2UgaWYgKHByZXZEaXIgPT09IHRoaXMuRElSLkVBU1QgJiYgbmV4dERpciA9PT0gdGhpcy5ESVIuTk9SVEgpIHsgLy8gOFxyXG4gICAgICAgICBpbmRpY2F0b3Iucm90YXRpb24gPSAzIC8gMiAqIE1hdGguUEk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgIGluZGljYXRvci5zY2FsZS5zZXRUbygtTWF0aC5hYnMoaW5kaWNhdG9yLnNjYWxlLngpLCBpbmRpY2F0b3Iuc2NhbGUueSk7XHJcbiAgICAgICAgIGlmIChwcmV2RGlyID09PSB0aGlzLkRJUi5TT1VUSCAmJiBuZXh0RGlyID09PSB0aGlzLkRJUi5XRVNUKSB7IC8vIDlcclxuICAgICAgICAgICAgaW5kaWNhdG9yLnJvdGF0aW9uID0gMDtcclxuICAgICAgICAgfSBlbHNlIGlmIChwcmV2RGlyID09PSB0aGlzLkRJUi5XRVNUICYmIG5leHREaXIgPT09IHRoaXMuRElSLk5PUlRIKSB7IC8vIDEwXHJcbiAgICAgICAgICAgIGluZGljYXRvci5yb3RhdGlvbiA9IDEgLyAyICogTWF0aC5QSTtcclxuICAgICAgICAgfSBlbHNlIGlmIChwcmV2RGlyID09PSB0aGlzLkRJUi5OT1JUSCAmJiBuZXh0RGlyID09PSB0aGlzLkRJUi5FQVNUKSB7IC8vIDExXHJcbiAgICAgICAgICAgIGluZGljYXRvci5yb3RhdGlvbiA9IE1hdGguUEk7XHJcbiAgICAgICAgIH0gZWxzZSBpZiAocHJldkRpciA9PT0gdGhpcy5ESVIuRUFTVCAmJiBuZXh0RGlyID09PSB0aGlzLkRJUi5TT1VUSCkgeyAvLyAxMlxyXG4gICAgICAgICAgICBpbmRpY2F0b3Iucm90YXRpb24gPSAzIC8gMiAqIE1hdGguUEk7XHJcbiAgICAgICAgIH1cclxuICAgICAgfVxyXG4gICB9IFxyXG59O1xyXG5cclxuQ3ViZUdyb3VwLnByb3RvdHlwZS5jdWJlc1RvR3JhcGggPSBmdW5jdGlvbigpIHtcclxuICB2YXIgZ3JhcGggPSBbXTtcclxuICBmb3IgKHZhciByb3cgPSAwOyByb3cgPCB0aGlzLmN1YmVzV2lkdGgoKTsgcm93KyspIHtcclxuICAgICB2YXIgbmV3Q29sID0gW107XHJcbiAgICAgIGZvciAodmFyIGNvbCA9IDA7IGNvbCA8IHRoaXMuY3ViZXNIZWlnaHQoKTsgY29sKyspIHtcclxuICAgICAgICAgaWYgKHRoaXMuY3ViZXNbcm93XVtjb2xdKSB7XHJcbiAgICAgICAgICAgIG5ld0NvbC5wdXNoKDEpO1xyXG4gICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBuZXdDb2wucHVzaCgwKTtcclxuICAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGdyYXBoLnB1c2gobmV3Q29sKTtcclxuICAgfVxyXG4gICByZXR1cm4gZ3JhcGg7XHJcbn07XHJcblxyXG5DdWJlR3JvdXAucHJvdG90eXBlLmRpckJldHdlZW4gPSBmdW5jdGlvbihhLCBiKSB7XHJcbiAgIHZhciBkZWx0YVggPSBhLnggLSBiLng7XHJcbiAgIHZhciBkZWx0YVkgPSBhLnkgLSBiLnk7XHJcbiAgIGlmIChkZWx0YVggPiAwKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLkRJUi5XRVNUO1xyXG4gICB9XHJcbiAgIGlmIChkZWx0YVggPCAwKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLkRJUi5FQVNUO1xyXG4gICB9XHJcbiAgIGlmIChkZWx0YVkgPiAwKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLkRJUi5TT1VUSDtcclxuICAgfVxyXG4gICBpZiAoZGVsdGFZIDwgMCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5ESVIuTk9SVEg7XHJcbiAgIH1cclxuICAgcmV0dXJuIHRoaXMuRElSLk5PUlRIO1xyXG59O1xyXG5cclxuQ3ViZUdyb3VwLnByb3RvdHlwZS5kaXJUb0FuZ2xlID0gZnVuY3Rpb24oZGlyKSB7XHJcbiAgc3dpdGNoIChkaXIpIHtcclxuICAgY2FzZSB0aGlzLkRJUi5OT1JUSDpcclxuICAgcmV0dXJuIE1hdGguUEk7XHJcbiAgIGNhc2UgdGhpcy5ESVIuRUFTVDpcclxuICAgcmV0dXJuIDMgLyAyICogTWF0aC5QSTtcclxuICAgY2FzZSB0aGlzLkRJUi5TT1VUSDpcclxuICAgcmV0dXJuIDA7XHJcbiAgIGNhc2UgdGhpcy5ESVIuV0VTVDpcclxuICAgcmV0dXJuIDEgLyAyICogTWF0aC5QSTtcclxuICB9ICBcclxufTtcclxuXHJcbkN1YmVHcm91cC5wcm90b3R5cGUuZGVzdHJveUN1YmUgPSBmdW5jdGlvbihjdWJlKSB7XHJcbiAgLy8gY29uc29sZS5sb2coJ2Rlc3Ryb3lDdWJlJyk7XHJcbiAgdmFyIGxvYyA9IHRoaXMuZmluZChjdWJlKTtcclxuICBpZiAoIWxvYykge1xyXG4gICAgIGNvbnNvbGUubG9nKCdhdHRlbXB0IHRvIGRlc3Ryb3kgY3ViZSBub3QgaW4gZ3JvdXAnKTtcclxuICAgICByZXR1cm47XHJcbiAgfVxyXG4gIC8vIHJlbW92ZSBjdWJlIGZyb20gZ3JvdXBcclxuICB0aGlzLnJlbW92ZShjdWJlKTtcclxuICAvLyBkZXN0cm95IGN1YmVcclxuICBjdWJlLmtpbGwodHJ1ZSk7XHJcbn07XHJcblxyXG5DdWJlR3JvdXAucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKGN1YmUpIHtcclxuICAgLy8gY29uc29sZS5sb2coJ3JlbW92ZScpO1xyXG4gICBpZiAodGhpcy5yb290ID09PSBjdWJlKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgfVxyXG4gICAvLyByZW1vdmUgY3ViZSBmcm9tIGFycmF5XHJcbiAgIHZhciByb3csIGNvbDtcclxuICAgZm9yIChyb3cgPSAwOyByb3cgPCB0aGlzLmN1YmVzV2lkdGgoKTsgcm93KyspIHtcclxuICAgICAgZm9yIChjb2wgPSAwOyBjb2wgPCB0aGlzLmN1YmVzSGVpZ2h0KCk7IGNvbCsrKSB7XHJcbiAgICAgICAgIGlmICh0aGlzLmN1YmVzW3Jvd11bY29sXSA9PT0gY3ViZSkge1xyXG4gICAgICAgICAgICAvLyB0aGlzLmN1YmVzW3Jvd11bY29sXS5ncm91cCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgdGhpcy5jdWJlc1tyb3ddW2NvbF0gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgfVxyXG4gICAvLyByZW1vdmUgY29uc3RyYWludHMgZnJvbSBjdWJlXHJcbiAgIHRoaXMucmVtb3ZlQ29uc3RyYWludHMoY3ViZSk7XHJcbiAgIGN1YmUuZ3JvdXAgPSB1bmRlZmluZWQ7XHJcbiAgIGlmIChjdWJlLm1vZHVsZSAmJiBjdWJlLm1vZHVsZS5oYXNPd25Qcm9wZXJ0eSgnb25SZW1vdmUnKSkge1xyXG4gICAgICBjdWJlLm1vZHVsZS5vblJlbW92ZSgpO1xyXG4gICB9XHJcbiAgIC8vIHRlc3QgZm9yIGV4aWxlc1xyXG4gICBmb3IgKHJvdyA9IDA7IHJvdyA8IHRoaXMuY3ViZXNXaWR0aCgpOyByb3crKykge1xyXG4gICAgICBmb3IgKGNvbCA9IDA7IGNvbCA8IHRoaXMuY3ViZXNIZWlnaHQoKTsgY29sKyspIHtcclxuICAgICAgICAgdmFyIGV4aWxlID0gdGhpcy5jdWJlc1tyb3ddW2NvbF07XHJcbiAgICAgICAgIGlmIChleGlsZSAmJiB0aGlzLmlzRXhpbGUoZXhpbGUpKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKGV4aWxlKTtcclxuICAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgIH1cclxuICAgLy8gdGhpcy5kaXNwbGF5Q3ViZXMoKTtcclxufTtcclxuXHJcbkN1YmVHcm91cC5wcm90b3R5cGUucmVtb3ZlTmVpZ2hib3JzQ29uc3RyYWludCA9IGZ1bmN0aW9uKGNvbnN0cmFpbnQsIGN1YmUpIHtcclxuICAgLy8gY29uc29sZS5sb2coJ3JlbW92ZU5laWdoYm9yc0NvbnN0cmFpbnQnKTtcclxuICAgdmFyIG5laWdoYm9ycyA9IHRoaXMuZ2V0TmVpZ2hib3JzKGN1YmUpO1xyXG4gICBmb3IgKHZhciBpID0gMDsgaSA8IG5laWdoYm9ycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICB2YXIgbmVpZ2hib3IgPSBuZWlnaGJvcnNbaV07XHJcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbmVpZ2hib3IuY29uc3RyYWludHMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgaWYgKG5laWdoYm9yLmNvbnN0cmFpbnRzW2pdID09PSBjb25zdHJhaW50KSB7XHJcbiAgICAgICAgICAgIG5laWdoYm9yLmNvbnN0cmFpbnRzLnNwbGljZShqLCAxKTtcclxuICAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgIH1cclxufTtcclxuXHJcbkN1YmVHcm91cC5wcm90b3R5cGUuZ2V0TmVpZ2hib3JzID0gZnVuY3Rpb24oY3ViZSkge1xyXG4gICB2YXIgbG9jID0gdGhpcy5maW5kKGN1YmUpO1xyXG4gICB2YXIgbm9ydGggPSB0aGlzLmdldCh0aGlzLmFkanVzdChsb2MsIHRoaXMuRElSLk5PUlRIKSk7XHJcbiAgIHZhciBlYXN0ID0gdGhpcy5nZXQodGhpcy5hZGp1c3QobG9jLCB0aGlzLkRJUi5FQVNUKSk7XHJcbiAgIHZhciBzb3V0aCA9IHRoaXMuZ2V0KHRoaXMuYWRqdXN0KGxvYywgdGhpcy5ESVIuU09VVEgpKTtcclxuICAgdmFyIHdlc3QgPSB0aGlzLmdldCh0aGlzLmFkanVzdChsb2MsIHRoaXMuRElSLldFU1QpKTtcclxuICAgdmFyIG5laWdoYm9ycyA9IFtdO1xyXG4gICBpZiAobm9ydGgpIHtcclxuICAgICAgbmVpZ2hib3JzLnB1c2gobm9ydGgpO1xyXG4gICB9XHJcbiAgIGlmIChlYXN0KSB7XHJcbiAgICAgIG5laWdoYm9ycy5wdXNoKGVhc3QpO1xyXG4gICB9XHJcbiAgIGlmIChzb3V0aCkge1xyXG4gICAgICBuZWlnaGJvcnMucHVzaChzb3V0aCk7XHJcbiAgIH1cclxuICAgaWYgKHdlc3QpIHtcclxuICAgICAgbmVpZ2hib3JzLnB1c2god2VzdCk7XHJcbiAgIH1cclxuICAgcmV0dXJuIG5laWdoYm9ycztcclxufTtcclxuXHJcbkN1YmVHcm91cC5wcm90b3R5cGUucmVtb3ZlQ29uc3RyYWludHMgPSBmdW5jdGlvbihjdWJlKSB7XHJcbiAgIC8vIGNvbnNvbGUubG9nKCdyZW1vdmVDb25zdHJhaW50cycpO1xyXG4gICB3aGlsZSAoY3ViZS5jb25zdHJhaW50cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgIHRoaXMucmVtb3ZlTmVpZ2hib3JzQ29uc3RyYWludChjdWJlLmNvbnN0cmFpbnRzWzBdLCBjdWJlKTtcclxuICAgICAgdGhpcy5nYW1lLnBoeXNpY3MucDIucmVtb3ZlQ29uc3RyYWludChjdWJlLmNvbnN0cmFpbnRzWzBdKTtcclxuICAgICAgY3ViZS5jb25zdHJhaW50cy5zcGxpY2UoMCwgMSk7XHJcbiAgIH1cclxufTtcclxuXHJcbi8vIG9ubHkgdXNlZCB0byB0ZXN0IEFzdGFyXHJcbkN1YmVHcm91cC5wcm90b3R5cGUudGVzdFBhdGggPSBmdW5jdGlvbigpIHtcclxuICB2YXIgZ3JhcGggPSBuZXcgQXN0YXIuR3JhcGgoW1xyXG4gICAgICAgIFsxLDEsMSwxXSxcclxuICAgICAgICBbMCwxLDEsMF0sXHJcbiAgICAgICAgWzAsMCwwLDFdXHJcbiAgICBdKTtcclxuICAgdmFyIHN0YXJ0ID0gZ3JhcGguZ3JpZFswXVswXTtcclxuICAgdmFyIGVuZCA9IGdyYXBoLmdyaWRbMl1bM107XHJcbiAgIHZhciByZXN1bHQgPSBBc3Rhci5hc3Rhci5zZWFyY2goZ3JhcGgsIHN0YXJ0LCBlbmQpO1xyXG4gICByZXN1bHQudW5zaGlmdChzdGFydCk7XHJcbiAgIGZvcih2YXIgaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgY29uc29sZS5sb2cocmVzdWx0W2ldLngsIHJlc3VsdFtpXS55KTtcclxuICAgIH0gXHJcbn07XHJcblxyXG5DdWJlR3JvdXAucHJvdG90eXBlLmlzRXhpbGUgPSBmdW5jdGlvbihjdWJlKSB7XHJcbiAgIGlmIChjdWJlID09PSB0aGlzLnJvb3QpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICB9XHJcbiAgIHZhciBncmFwaCA9IG5ldyBBc3Rhci5HcmFwaCh0aGlzLmN1YmVzVG9HcmFwaCgpKTtcclxuICAgdmFyIHN0YXJ0UG9pbnQgPSB0aGlzLmZpbmQodGhpcy5yb290KTtcclxuICAgdmFyIGVuZFBvaW50ID0gdGhpcy5maW5kKGN1YmUpO1xyXG4gICB2YXIgc3RhcnQgPSBncmFwaC5ncmlkW3N0YXJ0UG9pbnQueF1bc3RhcnRQb2ludC55XTtcclxuICAgdmFyIGVuZCA9IGdyYXBoLmdyaWRbZW5kUG9pbnQueF1bZW5kUG9pbnQueV07XHJcbiAgIHZhciByZXN1bHQgPSBBc3Rhci5hc3Rhci5zZWFyY2goZ3JhcGgsIHN0YXJ0LCBlbmQpO1xyXG4gICAvLyBpZiBubyBwYXRoIGlzIGZvdW5kLCB0aGUgY3ViZSBpcyBhbiBleGlsZVxyXG4gICBpZiAocmVzdWx0Lmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgfVxyXG4gICByZXR1cm4gZmFsc2U7XHJcbn07XHJcblxyXG5DdWJlR3JvdXAucHJvdG90eXBlLmNvdW50Q3ViZXMgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgcm93LCBjb2w7XHJcblx0dmFyIG51bSAgPSAwO1xyXG5cdGZvciAocm93ID0gMDsgcm93IDwgdGhpcy5jdWJlc1dpZHRoKCk7IHJvdysrKSB7XHJcblx0XHRmb3IgKGNvbCA9IDA7IGNvbCA8IHRoaXMuY3ViZXNIZWlnaHQoKTsgY29sKyspIHtcclxuXHRcdFx0aWYgKHRoaXMuY3ViZXNbcm93XVtjb2xdICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRudW0rKztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHQvL2NvbnNvbGUubG9nKG51bSk7XHJcblx0dGhpcy5udW1DdWJlcyA9IG51bTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ3ViZUdyb3VwO1xyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuIiwidmFyIFV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMuanMnKTtcclxuXHJcbnZhciBFbmVteUFJID0gZnVuY3Rpb24oZ2FtZSwgZ3JvdXAsIHR5cGUsIHBsYXllckdyb3VwKSB7XHJcbiAgIHRoaXMuZ2FtZSA9IGdhbWU7XHJcbiAgIHRoaXMuZ3JvdXAgPSBncm91cDtcclxuICAgdGhpcy50eXBlID0gdHlwZTtcclxuICAgdGhpcy5wbGF5ZXJHcm91cCA9IHBsYXllckdyb3VwO1xyXG4gICB0aGlzLnBsYXllciA9IHRoaXMucGxheWVyR3JvdXAucm9vdDtcclxuICAgdGhpcy5yYW1EaXN0ID0gNTAwO1xyXG4gICB0aGlzLnJvdGF0aW9uRm9yY2UgPSA1MDtcclxuICAgdGhpcy5mYWNpbmdBbGxvd2FuY2UgPSBNYXRoLlBJIC8gMjA7XHJcbiAgIHRoaXMudGhydXN0ZXJzRmlyaW5nID0gZmFsc2U7XHJcbiAgIHN3aXRjaCAodGhpcy50eXBlKSB7XHJcbiAgICAgIGNhc2UgJ3JhbSc6XHJcbiAgICAgIHRoaXMuYWxsb2NhdGVUb1RocnVzdGVycygpO1xyXG4gICAgICBicmVhaztcclxuICAgfVxyXG59O1xyXG5cclxuRW5lbXlBSS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBFbmVteUFJO1xyXG5cclxuRW5lbXlBSS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgIHN3aXRjaCAodGhpcy50eXBlKSB7XHJcbiAgICAgIGNhc2UgJ3JhbSc6XHJcbiAgICAgIHRoaXMucmFtVXBkYXRlKCk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICB9XHJcbn07XHJcblxyXG5FbmVteUFJLnByb3RvdHlwZS5yYW1VcGRhdGUgPSBmdW5jdGlvbigpIHtcclxuICAgaWYgKCF0aGlzLmdyb3VwLnJvb3QpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICB9XHJcbiAgIHZhciByb290ID0gdGhpcy5ncm91cC5yb290O1xyXG4gICB2YXIgbXlQb3MgPSBuZXcgUGhhc2VyLlBvaW50KHJvb3QueCwgcm9vdC55KTtcclxuICAgdmFyIHBsYXllclBvcyA9IG5ldyBQaGFzZXIuUG9pbnQodGhpcy5wbGF5ZXIueCwgdGhpcy5wbGF5ZXIueSk7XHJcbiAgIHZhciBkaXN0ID0gVXRpbHMuZGlzdGFuY2UobXlQb3MueCwgbXlQb3MueSwgcGxheWVyUG9zLngsIHBsYXllclBvcy55KTtcclxuICAgaWYgKGRpc3QgPD0gdGhpcy5yYW1EaXN0KSB7XHJcbiAgICAgIHZhciBhbmdsZVRvID0gdGhpcy5hbmdsZVRvKG15UG9zLCBwbGF5ZXJQb3MpO1xyXG4gICAgICB2YXIgZGlmZkFuZ2xlID0gYW5nbGVUbyAtIHJvb3QuYm9keS5yb3RhdGlvbjtcclxuICAgICAgaWYgKGRpZmZBbmdsZSA+IDApIHtcclxuICAgICAgICAgcm9vdC5ib2R5LmFuZ3VsYXJGb3JjZSA9IHRoaXMucm90YXRpb25Gb3JjZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgcm9vdC5ib2R5LmFuZ3VsYXJGb3JjZSA9IC10aGlzLnJvdGF0aW9uRm9yY2U7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKE1hdGguYWJzKGRpZmZBbmdsZSkgPD0gdGhpcy5mYWNpbmdBbGxvd2FuY2UgJiYgIXRoaXMudGhydXN0ZXJzRmlyaW5nKSB7XHJcbiAgICAgICAgIHRoaXMuZ3JvdXAuY2FsbCgnYmVnaW5UaHJ1c3QnKTtcclxuICAgICAgICAgdGhpcy50aHJ1c3RlcnNGaXJpbmcgPSB0cnVlO1xyXG4gICAgICAgICB0aGlzLmFsbG9jYXRlVG9UaHJ1c3RlcnMoKTtcclxuICAgICAgfSBlbHNlIGlmIChNYXRoLmFicyhkaWZmQW5nbGUpID4gdGhpcy5mYWNpbmdBbGxvd2FuY2UgJiYgdGhpcy50aHJ1c3RlcnNGaXJpbmcpe1xyXG4gICAgICAgICB0aGlzLmdyb3VwLmNhbGwoJ2VuZFRocnVzdCcpO1xyXG4gICAgICAgICB0aGlzLnRocnVzdGVyc0ZpcmluZyA9IGZhbHNlO1xyXG4gICAgICB9XHJcbiAgIH1cclxufTtcclxuXHJcbkVuZW15QUkucHJvdG90eXBlLmFsbG9jYXRlVG9UaHJ1c3RlcnMgPSBmdW5jdGlvbigpIHtcclxuICAgdmFyIHBhbmVscyA9IFtdO1xyXG4gICB2YXIgdGhydXN0ZXJzID0gW107XHJcbiAgIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IHRoaXMuZ3JvdXAuY3ViZXNXaWR0aCgpOyByb3crKykge1xyXG4gICAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCB0aGlzLmdyb3VwLmN1YmVzSGVpZ2h0KCk7IGNvbCsrKSB7XHJcbiAgICAgICAgIHZhciBjdWJlID0gdGhpcy5ncm91cC5jdWJlc1tyb3ddW2NvbF07XHJcbiAgICAgICAgIGlmIChjdWJlICYmIGN1YmUubW9kdWxlKSB7XHJcbiAgICAgICAgICAgIGlmIChjdWJlLm1vZHVsZS50eXBlID09PSAnc29sYXJQYW5lbCcgJiYgIWN1YmUubXlDb25uZWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgIHBhbmVscy5wdXNoKGN1YmUubW9kdWxlKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChjdWJlLm1vZHVsZS50eXBlID09PSAndGhydXN0ZXInICYmICFjdWJlLm15Q29ubmVjdGlvbikge1xyXG4gICAgICAgICAgICAgICB0aHJ1c3RlcnMucHVzaChjdWJlLm1vZHVsZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgIH1cclxuICAgdmFyIGkgPSAwO1xyXG4gICB3aGlsZSAoaSA8IHRocnVzdGVycy5sZW5ndGggJiYgaSA8IHBhbmVscy5sZW5ndGgpIHtcclxuICAgICAgdmFyIHRhclBhbmVsID0gcGFuZWxzW2ldO1xyXG4gICAgICB2YXIgdGFyVGhydXN0ZXIgPSB0aHJ1c3RlcnNbaV07XHJcbiAgICAgIHZhciBuZXdDb25uZWN0aW9uID0ge3N0YXJ0OiB0YXJQYW5lbC5jdWJlLCBlbmQ6IHRhclRocnVzdGVyLmN1YmV9O1xyXG4gICAgICB0YXJQYW5lbC5jdWJlLm15Q29ubmVjdGlvbiA9IG5ld0Nvbm5lY3Rpb247XHJcbiAgICAgIHRhclRocnVzdGVyLmN1YmUubXlDb25uZWN0aW9uID0gbmV3Q29ubmVjdGlvbjtcclxuICAgICAgdGhpcy5ncm91cC5kaXNwbGF5Q29ubmVjdGlvbih0YXJQYW5lbC5jdWJlLm15Q29ubmVjdGlvbik7XHJcbiAgICAgIGkrKztcclxuICAgfVxyXG59O1xyXG5cclxuRW5lbXlBSS5wcm90b3R5cGUuYW5nbGVUbyA9IGZ1bmN0aW9uKGZyb20sIHRvKSB7XHJcbiAgdmFyIGFuZ2xlVG9PdGhlciA9IFBoYXNlci5Qb2ludC5hbmdsZShmcm9tLCB0byk7XHJcbiAgaWYgKGFuZ2xlVG9PdGhlciA8IDApIHsgLy8gZml4IGR1bWIgcGFydCBvZiBQaGFzZXIuUG9pbnQuYW5nbGUoKVxyXG4gICAgIGFuZ2xlVG9PdGhlciA9IDIgKiBNYXRoLlBJICsgYW5nbGVUb090aGVyO1xyXG4gIH1cclxuICBhbmdsZVRvT3RoZXIgPSAoYW5nbGVUb090aGVyICsgMy8yICogTWF0aC5QSSkgJSAoMiAqIE1hdGguUEkpOyAvLyByb3RhdGUgOTAgZCBjbG9ja3dpc2VcclxuICByZXR1cm4gYW5nbGVUb090aGVyO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBFbmVteUFJO1xyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuIiwidmFyIFV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMuanMnKTtcclxuXHJcbnZhciBNb3VzZSA9IGZ1bmN0aW9uKGdhbWUsIGlucHV0KSB7XHJcbiAgIHRoaXMuZ2FtZSA9IGdhbWU7XHJcbiAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcclxuXHR0aGlzLmJvZHkgPSBuZXcgcDIuQm9keSgpOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcclxuICAgdGhpcy5nYW1lLnBoeXNpY3MucDIud29ybGQuYWRkQm9keSh0aGlzLmJvZHkpO1xyXG4gICAvLyB0aGlzLmdhbWUucGh5c2ljcy5wMi5lbmFibGUodGhpcyk7XHJcbiAgIFxyXG4gICB0aGlzLmlucHV0Lm9uRG93bi5hZGQodGhpcy5jbGljaywgdGhpcyk7XHJcbiAgIHRoaXMuaW5wdXQub25VcC5hZGQodGhpcy5yZWxlYXNlLCB0aGlzKTtcclxuICAgdGhpcy5pbnB1dC5hZGRNb3ZlQ2FsbGJhY2sodGhpcy5tb3ZlLCB0aGlzKTtcclxuICAgdGhpcy54ID0gMDtcclxuICAgdGhpcy55ID0gMDtcclxuICAgXHJcbiAgIHRoaXMuZ3JhYmJlZCA9IHVuZGVmaW5lZDtcclxuICAgdGhpcy5sYXN0Q2xpY2tlZCA9IHVuZGVmaW5lZDtcclxuICAgdGhpcy5saW5lID0gbmV3IFBoYXNlci5MaW5lKDAsIDAsIDAsIDApO1xyXG4gICBcclxuICAgdGhpcy5yZW1vdmVUaHJlc2hvbGQgPSA0MDA7IC8vIHRpbWUgaW4gbWlsbGlzZWNvbmRzXHJcbiAgIHRoaXMucmVtb3ZlVGltZSA9IDA7IC8vIHRpbWUgdGlsbCB0aHJlc2hvbGRcclxufTtcclxuXHJcbk1vdXNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1vdXNlO1xyXG5cclxuTW91c2UucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICBpZiAodGhpcy5ncmFiYmVkKSB7XHJcbiAgICAgIHZhciBhbmdsZSA9IE1hdGguYXRhbjIodGhpcy5ncmFiYmVkLnNwcml0ZS55IC0gKHRoaXMuaW5wdXQucG9zaXRpb24ueSArIHRoaXMuZ2FtZS5jYW1lcmEueSksIHRoaXMuZ3JhYmJlZC5zcHJpdGUueCAtICh0aGlzLmlucHV0LnBvc2l0aW9uLngrIHRoaXMuZ2FtZS5jYW1lcmEueCkpICsgTWF0aC5QSTtcclxuICAgICAgdmFyIGRpc3QgPSBVdGlscy5kaXN0YW5jZSh0aGlzLmdyYWJiZWQuc3ByaXRlLngsIHRoaXMuZ3JhYmJlZC5zcHJpdGUueSwgKHRoaXMuaW5wdXQucG9zaXRpb24ueCsgdGhpcy5nYW1lLmNhbWVyYS54KSwgKHRoaXMuaW5wdXQucG9zaXRpb24ueSArIHRoaXMuZ2FtZS5jYW1lcmEueSkpO1xyXG4gICAgICB2YXIgd2VpZ2h0ID0gMTA7XHJcbiAgICAgIHRoaXMuZ3JhYmJlZC5mb3JjZS54ID0gTWF0aC5jb3MoYW5nbGUpICogZGlzdCAqIHdlaWdodDtcclxuICAgICAgdGhpcy5ncmFiYmVkLmZvcmNlLnkgPSBNYXRoLnNpbihhbmdsZSkgKiBkaXN0ICogd2VpZ2h0O1xyXG4gICAgICB0aGlzLmxpbmUuc2V0VG8odGhpcy5ncmFiYmVkLnNwcml0ZS54LCB0aGlzLmdyYWJiZWQuc3ByaXRlLnksICh0aGlzLmlucHV0LnBvc2l0aW9uLngrIHRoaXMuZ2FtZS5jYW1lcmEueCksICh0aGlzLmlucHV0LnBvc2l0aW9uLnkgKyB0aGlzLmdhbWUuY2FtZXJhLnkpKTtcclxuICAgICAgdGhpcy5yZW1vdmVUaW1lICs9IHRoaXMuZ2FtZS50aW1lLmVsYXBzZWQ7XHJcbiAgICAgIGlmKHRoaXMuZ3JhYmJlZC5zcHJpdGUudGFnID09PSAnbW9kdWxlJykge1xyXG5cdFx0ICBpZiAodGhpcy5yZW1vdmVUaW1lID49IHRoaXMucmVtb3ZlVGhyZXNob2xkICYmIHRoaXMuZ3JhYmJlZC5zcHJpdGUua2V5ICE9PSAnYXN0ZXJvaWQnKSB7XHJcblx0XHRcdCB0aGlzLmdyYWJiZWQuc3ByaXRlLnJlbW92ZSgpO1xyXG5cdFx0XHQgdGhpcy5yZW1vdmVUaW1lID0gMDtcclxuXHRcdCAgfVxyXG5cdCAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgIHRoaXMubGluZS5zZXRUbygwLCAwLCAwLCAwKTtcclxuICAgIH1cclxuICAgIHZhciBwb2ludCA9IG5ldyBQaGFzZXIuUG9pbnQodGhpcy54LCB0aGlzLnkpO1xyXG4gICAgdmFyIGJvZGllcyA9IHRoaXMuZ2FtZS5waHlzaWNzLnAyLmhpdFRlc3QocG9pbnQpO1xyXG4gICAgaWYgKGJvZGllcy5sZW5ndGgpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGhvdmVyID0gYm9kaWVzWzBdLnBhcmVudDtcclxuICAgICAgICBpZiAoaG92ZXIuc3ByaXRlLm1vZHVsZSAmJiBob3Zlci5zcHJpdGUubW9kdWxlLm1vdXNlT3Zlcikge1xyXG4gICAgICAgICAgIGhvdmVyLnNwcml0ZS5tb2R1bGUubW91c2VPdmVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuTW91c2UucHJvdG90eXBlLmNsaWNrID0gZnVuY3Rpb24ocG9pbnRlcikge1xyXG4gICB2YXIgcG9pbnQgPSBuZXcgUGhhc2VyLlBvaW50KHBvaW50ZXIueCArIHRoaXMuZ2FtZS5jYW1lcmEueCwgcG9pbnRlci55ICsgdGhpcy5nYW1lLmNhbWVyYS55KTtcclxuICAgdmFyIGJvZGllcyA9IHRoaXMuZ2FtZS5waHlzaWNzLnAyLmhpdFRlc3QocG9pbnQpO1xyXG4gICBpZiAoYm9kaWVzLmxlbmd0aClcclxuICAge1xyXG4gICAgIHRoaXMucmVtb3ZlVGltZSA9IDA7XHJcbiAgICAgdGhpcy5ncmFiYmVkID0gYm9kaWVzWzBdLnBhcmVudDtcclxuICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLmdyYWJiZWQuc3ByaXRlLm5hbWUpO1xyXG4gICAgIGlmICh0aGlzLmdyYWJiZWQuc3ByaXRlLm1vZHVsZSAmJiB0aGlzLmdyYWJiZWQuc3ByaXRlLm1vZHVsZS5oYXNPd25Qcm9wZXJ0eSgnbW91c2VEb3duJykpIHtcclxuICAgICAgICB0aGlzLmdyYWJiZWQuc3ByaXRlLm1vZHVsZS5tb3VzZURvd24oKTtcclxuICAgICB9XHJcbiAgICAgaWYgKHRoaXMubGFzdENsaWNrZWQgJiYgdGhpcy5sYXN0Q2xpY2tlZC5zcHJpdGUgJiYgdGhpcy5sYXN0Q2xpY2tlZC5zcHJpdGUubW9kdWxlICYmXHJcbiAgICAgdGhpcy5sYXN0Q2xpY2tlZC5zcHJpdGUubW9kdWxlLmdpdmVUYXJnZXQpIHtcclxuICAgICAgICB0aGlzLmxhc3RDbGlja2VkLnNwcml0ZS5tb2R1bGUuZ2l2ZVRhcmdldCh0aGlzLmdyYWJiZWQuc3ByaXRlLm1vZHVsZSk7XHJcbiAgICAgfVxyXG4gICAgIHRoaXMubGFzdENsaWNrZWQgPSBib2RpZXNbMF0ucGFyZW50O1xyXG4gICB9XHJcbn07XHJcbiAgXHJcbiBNb3VzZS5wcm90b3R5cGUucmVsZWFzZSA9IGZ1bmN0aW9uKCkge1xyXG4gICBpZiAodGhpcy5ncmFiYmVkKSB7XHJcbiAgICAgdGhpcy5ncmFiYmVkID0gdW5kZWZpbmVkO1xyXG4gICB9XHJcbn07XHJcbiAgXHJcbk1vdXNlLnByb3RvdHlwZS5tb3ZlID0gZnVuY3Rpb24ocG9pbnRlcikge1xyXG4gICAvLyBwMiB1c2VzIGRpZmZlcmVudCBjb29yZGluYXRlIHN5c3RlbSwgc28gY29udmVydCB0aGUgcG9pbnRlciBwb3NpdGlvbiB0byBwMidzIGNvb3JkaW5hdGUgc3lzdGVtXHJcbiAgIHRoaXMuYm9keS5wb3NpdGlvblswXSA9IHRoaXMuZ2FtZS5waHlzaWNzLnAyLnB4bWkocG9pbnRlci5wb3NpdGlvbi54KTtcclxuICAgdGhpcy5ib2R5LnBvc2l0aW9uWzFdID0gdGhpcy5nYW1lLnBoeXNpY3MucDIucHhtaShwb2ludGVyLnBvc2l0aW9uLnkpO1xyXG4gICB0aGlzLnggPSBwb2ludGVyLnBvc2l0aW9uLnggKyB0aGlzLmdhbWUuY2FtZXJhLng7XHJcbiAgIHRoaXMueSA9IHBvaW50ZXIucG9zaXRpb24ueSArIHRoaXMuZ2FtZS5jYW1lcmEueTtcclxufTtcclxuXHJcbk1vdXNlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbigpIHtcclxuICAgdGhpcy5nYW1lLmRlYnVnLmdlb20odGhpcy5saW5lKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTW91c2U7XHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuIiwidmFyIFJlbmRlcmFibGVzID0gZnVuY3Rpb24oKSB7XHJcblx0aWYoUmVuZGVyYWJsZXMucHJvdG90eXBlLmV4aXN0cykge1xyXG5cdFx0cmV0dXJuIFJlbmRlcmFibGVzLnByb3RvdHlwZS5leGlzdGluZ1JlZmVyZW5jZTtcclxuXHR9XHJcblx0XHJcblx0dGhpcy5saXN0ID0gW107XHJcblx0UmVuZGVyYWJsZXMucHJvdG90eXBlLmV4aXN0cyA9IHRydWU7XHJcblx0UmVuZGVyYWJsZXMucHJvdG90eXBlLmV4aXN0aW5nUmVmZXJlbmNlID0gdGhpcztcclxufTtcclxuXHJcblJlbmRlcmFibGVzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJlbmRlcmFibGVzO1xyXG4vL1RoZXNlIHZhcidzIGhlbHAgY3JlYXRlIHRoZSBzaW5nbGV0b24gZnVuY3Rpb25hbGl0eVxyXG5SZW5kZXJhYmxlcy5wcm90b3R5cGUuZXhpc3RzID0gZmFsc2U7XHJcblJlbmRlcmFibGVzLnByb3RvdHlwZS5leGlzdGluZ1JlZmVyZW5jZSA9IG51bGw7XHJcblxyXG5SZW5kZXJhYmxlcy5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24oc3Vic2NyaWJlcikge1xyXG5cdHRoaXMubGlzdC5wdXNoKHN1YnNjcmliZXIpO1xyXG59O1xyXG5cclxuUmVuZGVyYWJsZXMucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24odW5zdWJzY3JpYmVyKSB7XHJcblx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGlzdC5sZW5ndGg7IGkrKykge1xyXG5cdFx0aWYodGhpcy5saXN0W2ldID09PSB1bnN1YnNjcmliZXIpIHtcclxuXHRcdFx0dGhpcy5saXN0W2ldID0gZmFsc2U7XHJcblx0XHR9XHJcblx0fVxyXG59O1xyXG5cclxuUmVuZGVyYWJsZXMucHJvdG90eXBlLnJlbmRlckFsbCA9IGZ1bmN0aW9uKCkge1xyXG5cdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxpc3QubGVuZ3RoOyBpKyspIHtcclxuXHRcdGlmKHRoaXMubGlzdFtpXSA9PT0gZmFsc2UpIHtcclxuXHRcdFx0Y29udGludWU7XHJcblx0XHR9XHJcblx0XHR0aGlzLmxpc3RbaV0ucmVuZGVyKCk7XHJcblx0fVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZW5kZXJhYmxlczsiLCIvLyBqYXZhc2NyaXB0LWFzdGFyIDAuNC4wXHJcbi8vIGh0dHA6Ly9naXRodWIuY29tL2Jncmlucy9qYXZhc2NyaXB0LWFzdGFyXHJcbi8vIEZyZWVseSBkaXN0cmlidXRhYmxlIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuLy8gSW1wbGVtZW50cyB0aGUgYXN0YXIgc2VhcmNoIGFsZ29yaXRobSBpbiBqYXZhc2NyaXB0IHVzaW5nIGEgQmluYXJ5IEhlYXAuXHJcbi8vIEluY2x1ZGVzIEJpbmFyeSBIZWFwICh3aXRoIG1vZGlmaWNhdGlvbnMpIGZyb20gTWFyaWpuIEhhdmVyYmVrZS5cclxuLy8gaHR0cDovL2Vsb3F1ZW50amF2YXNjcmlwdC5uZXQvYXBwZW5kaXgyLmh0bWxcclxuXHJcbihmdW5jdGlvbihkZWZpbml0aW9uKSB7XHJcbiAgICAvKiBnbG9iYWwgbW9kdWxlLCBkZWZpbmUgKi9cclxuICAgIGlmKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGRlZmluaXRpb24oKTtcclxuICAgIH0gZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcclxuICAgICAgICBkZWZpbmUoW10sIGRlZmluaXRpb24pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB2YXIgZXhwb3J0cyA9IGRlZmluaXRpb24oKTtcclxuICAgICAgICB3aW5kb3cuYXN0YXIgPSBleHBvcnRzLmFzdGFyO1xyXG4gICAgICAgIHdpbmRvdy5HcmFwaCA9IGV4cG9ydHMuR3JhcGg7XHJcbiAgICB9XHJcbn0pKGZ1bmN0aW9uKCkge1xyXG5cclxuZnVuY3Rpb24gcGF0aFRvKG5vZGUpe1xyXG4gICAgdmFyIGN1cnIgPSBub2RlLFxyXG4gICAgICAgIHBhdGggPSBbXTtcclxuICAgIHdoaWxlKGN1cnIucGFyZW50KSB7XHJcbiAgICAgICAgcGF0aC5wdXNoKGN1cnIpO1xyXG4gICAgICAgIGN1cnIgPSBjdXJyLnBhcmVudDtcclxuICAgIH1cclxuICAgIHJldHVybiBwYXRoLnJldmVyc2UoKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0SGVhcCgpIHtcclxuICAgIHJldHVybiBuZXcgQmluYXJ5SGVhcChmdW5jdGlvbihub2RlKSB7XHJcbiAgICAgICAgcmV0dXJuIG5vZGUuZjtcclxuICAgIH0pO1xyXG59XHJcblxyXG52YXIgYXN0YXIgPSB7XHJcbiAgICAvKipcclxuICAgICogUGVyZm9ybSBhbiBBKiBTZWFyY2ggb24gYSBncmFwaCBnaXZlbiBhIHN0YXJ0IGFuZCBlbmQgbm9kZS5cclxuICAgICogQHBhcmFtIHtHcmFwaH0gZ3JhcGhcclxuICAgICogQHBhcmFtIHtHcmlkTm9kZX0gc3RhcnRcclxuICAgICogQHBhcmFtIHtHcmlkTm9kZX0gZW5kXHJcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cclxuICAgICogQHBhcmFtIHtib29sfSBbb3B0aW9ucy5jbG9zZXN0XSBTcGVjaWZpZXMgd2hldGhlciB0byByZXR1cm4gdGhlXHJcbiAgICAgICAgICAgICAgIHBhdGggdG8gdGhlIGNsb3Nlc3Qgbm9kZSBpZiB0aGUgdGFyZ2V0IGlzIHVucmVhY2hhYmxlLlxyXG4gICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5oZXVyaXN0aWNdIEhldXJpc3RpYyBmdW5jdGlvbiAoc2VlXHJcbiAgICAqICAgICAgICAgIGFzdGFyLmhldXJpc3RpY3MpLlxyXG4gICAgKi9cclxuICAgIHNlYXJjaDogZnVuY3Rpb24oZ3JhcGgsIHN0YXJ0LCBlbmQsIG9wdGlvbnMpIHtcclxuICAgICAgICBncmFwaC5jbGVhbkRpcnR5KCk7XHJcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICAgICAgdmFyIGhldXJpc3RpYyA9IG9wdGlvbnMuaGV1cmlzdGljIHx8IGFzdGFyLmhldXJpc3RpY3MubWFuaGF0dGFuLFxyXG4gICAgICAgICAgICBjbG9zZXN0ID0gb3B0aW9ucy5jbG9zZXN0IHx8IGZhbHNlO1xyXG5cclxuICAgICAgICB2YXIgb3BlbkhlYXAgPSBnZXRIZWFwKCksXHJcbiAgICAgICAgICAgIGNsb3Nlc3ROb2RlID0gc3RhcnQ7IC8vIHNldCB0aGUgc3RhcnQgbm9kZSB0byBiZSB0aGUgY2xvc2VzdCBpZiByZXF1aXJlZFxyXG5cclxuICAgICAgICBzdGFydC5oID0gaGV1cmlzdGljKHN0YXJ0LCBlbmQpO1xyXG5cclxuICAgICAgICBvcGVuSGVhcC5wdXNoKHN0YXJ0KTtcclxuXHJcbiAgICAgICAgd2hpbGUob3BlbkhlYXAuc2l6ZSgpID4gMCkge1xyXG5cclxuICAgICAgICAgICAgLy8gR3JhYiB0aGUgbG93ZXN0IGYoeCkgdG8gcHJvY2VzcyBuZXh0LiAgSGVhcCBrZWVwcyB0aGlzIHNvcnRlZCBmb3IgdXMuXHJcbiAgICAgICAgICAgIHZhciBjdXJyZW50Tm9kZSA9IG9wZW5IZWFwLnBvcCgpO1xyXG5cclxuICAgICAgICAgICAgLy8gRW5kIGNhc2UgLS0gcmVzdWx0IGhhcyBiZWVuIGZvdW5kLCByZXR1cm4gdGhlIHRyYWNlZCBwYXRoLlxyXG4gICAgICAgICAgICBpZihjdXJyZW50Tm9kZSA9PT0gZW5kKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcGF0aFRvKGN1cnJlbnROb2RlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gTm9ybWFsIGNhc2UgLS0gbW92ZSBjdXJyZW50Tm9kZSBmcm9tIG9wZW4gdG8gY2xvc2VkLCBwcm9jZXNzIGVhY2ggb2YgaXRzIG5laWdoYm9ycy5cclxuICAgICAgICAgICAgY3VycmVudE5vZGUuY2xvc2VkID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIC8vIEZpbmQgYWxsIG5laWdoYm9ycyBmb3IgdGhlIGN1cnJlbnQgbm9kZS5cclxuICAgICAgICAgICAgdmFyIG5laWdoYm9ycyA9IGdyYXBoLm5laWdoYm9ycyhjdXJyZW50Tm9kZSk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBuZWlnaGJvcnMubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5laWdoYm9yID0gbmVpZ2hib3JzW2ldO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChuZWlnaGJvci5jbG9zZWQgfHwgbmVpZ2hib3IuaXNXYWxsKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBOb3QgYSB2YWxpZCBub2RlIHRvIHByb2Nlc3MsIHNraXAgdG8gbmV4dCBuZWlnaGJvci5cclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgZyBzY29yZSBpcyB0aGUgc2hvcnRlc3QgZGlzdGFuY2UgZnJvbSBzdGFydCB0byBjdXJyZW50IG5vZGUuXHJcbiAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGNoZWNrIGlmIHRoZSBwYXRoIHdlIGhhdmUgYXJyaXZlZCBhdCB0aGlzIG5laWdoYm9yIGlzIHRoZSBzaG9ydGVzdCBvbmUgd2UgaGF2ZSBzZWVuIHlldC5cclxuICAgICAgICAgICAgICAgIHZhciBnU2NvcmUgPSBjdXJyZW50Tm9kZS5nICsgbmVpZ2hib3IuZ2V0Q29zdChjdXJyZW50Tm9kZSksXHJcbiAgICAgICAgICAgICAgICAgICAgYmVlblZpc2l0ZWQgPSBuZWlnaGJvci52aXNpdGVkO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICghYmVlblZpc2l0ZWQgfHwgZ1Njb3JlIDwgbmVpZ2hib3IuZykge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBGb3VuZCBhbiBvcHRpbWFsIChzbyBmYXIpIHBhdGggdG8gdGhpcyBub2RlLiAgVGFrZSBzY29yZSBmb3Igbm9kZSB0byBzZWUgaG93IGdvb2QgaXQgaXMuXHJcbiAgICAgICAgICAgICAgICAgICAgbmVpZ2hib3IudmlzaXRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgbmVpZ2hib3IucGFyZW50ID0gY3VycmVudE5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgbmVpZ2hib3IuaCA9IG5laWdoYm9yLmggfHwgaGV1cmlzdGljKG5laWdoYm9yLCBlbmQpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5laWdoYm9yLmcgPSBnU2NvcmU7XHJcbiAgICAgICAgICAgICAgICAgICAgbmVpZ2hib3IuZiA9IG5laWdoYm9yLmcgKyBuZWlnaGJvci5oO1xyXG4gICAgICAgICAgICAgICAgICAgIGdyYXBoLm1hcmtEaXJ0eShuZWlnaGJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNsb3Nlc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIG5laWdoYm91ciBpcyBjbG9zZXIgdGhhbiB0aGUgY3VycmVudCBjbG9zZXN0Tm9kZSBvciBpZiBpdCdzIGVxdWFsbHkgY2xvc2UgYnV0IGhhc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhIGNoZWFwZXIgcGF0aCB0aGFuIHRoZSBjdXJyZW50IGNsb3Nlc3Qgbm9kZSB0aGVuIGl0IGJlY29tZXMgdGhlIGNsb3Nlc3Qgbm9kZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmVpZ2hib3IuaCA8IGNsb3Nlc3ROb2RlLmggfHwgKG5laWdoYm9yLmggPT09IGNsb3Nlc3ROb2RlLmggJiYgbmVpZ2hib3IuZyA8IGNsb3Nlc3ROb2RlLmcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9zZXN0Tm9kZSA9IG5laWdoYm9yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWJlZW5WaXNpdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFB1c2hpbmcgdG8gaGVhcCB3aWxsIHB1dCBpdCBpbiBwcm9wZXIgcGxhY2UgYmFzZWQgb24gdGhlICdmJyB2YWx1ZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgb3BlbkhlYXAucHVzaChuZWlnaGJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBbHJlYWR5IHNlZW4gdGhlIG5vZGUsIGJ1dCBzaW5jZSBpdCBoYXMgYmVlbiByZXNjb3JlZCB3ZSBuZWVkIHRvIHJlb3JkZXIgaXQgaW4gdGhlIGhlYXBcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3BlbkhlYXAucmVzY29yZUVsZW1lbnQobmVpZ2hib3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGNsb3Nlc3QpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHBhdGhUbyhjbG9zZXN0Tm9kZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBObyByZXN1bHQgd2FzIGZvdW5kIC0gZW1wdHkgYXJyYXkgc2lnbmlmaWVzIGZhaWx1cmUgdG8gZmluZCBwYXRoLlxyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH0sXHJcbiAgICAvLyBTZWUgbGlzdCBvZiBoZXVyaXN0aWNzOiBodHRwOi8vdGhlb3J5LnN0YW5mb3JkLmVkdS9+YW1pdHAvR2FtZVByb2dyYW1taW5nL0hldXJpc3RpY3MuaHRtbFxyXG4gICAgaGV1cmlzdGljczoge1xyXG4gICAgICAgIG1hbmhhdHRhbjogZnVuY3Rpb24ocG9zMCwgcG9zMSkge1xyXG4gICAgICAgICAgICB2YXIgZDEgPSBNYXRoLmFicyhwb3MxLnggLSBwb3MwLngpO1xyXG4gICAgICAgICAgICB2YXIgZDIgPSBNYXRoLmFicyhwb3MxLnkgLSBwb3MwLnkpO1xyXG4gICAgICAgICAgICByZXR1cm4gZDEgKyBkMjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRpYWdvbmFsOiBmdW5jdGlvbihwb3MwLCBwb3MxKSB7XHJcbiAgICAgICAgICAgIHZhciBEID0gMTtcclxuICAgICAgICAgICAgdmFyIEQyID0gTWF0aC5zcXJ0KDIpO1xyXG4gICAgICAgICAgICB2YXIgZDEgPSBNYXRoLmFicyhwb3MxLnggLSBwb3MwLngpO1xyXG4gICAgICAgICAgICB2YXIgZDIgPSBNYXRoLmFicyhwb3MxLnkgLSBwb3MwLnkpO1xyXG4gICAgICAgICAgICByZXR1cm4gKEQgKiAoZDEgKyBkMikpICsgKChEMiAtICgyICogRCkpICogTWF0aC5taW4oZDEsIGQyKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGNsZWFuTm9kZTpmdW5jdGlvbihub2RlKXtcclxuICAgICAgICBub2RlLmYgPSAwO1xyXG4gICAgICAgIG5vZGUuZyA9IDA7XHJcbiAgICAgICAgbm9kZS5oID0gMDtcclxuICAgICAgICBub2RlLnZpc2l0ZWQgPSBmYWxzZTtcclxuICAgICAgICBub2RlLmNsb3NlZCA9IGZhbHNlO1xyXG4gICAgICAgIG5vZGUucGFyZW50ID0gbnVsbDtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4qIEEgZ3JhcGggbWVtb3J5IHN0cnVjdHVyZVxyXG4qIEBwYXJhbSB7QXJyYXl9IGdyaWRJbiAyRCBhcnJheSBvZiBpbnB1dCB3ZWlnaHRzXHJcbiogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxyXG4qIEBwYXJhbSB7Ym9vbH0gW29wdGlvbnMuZGlhZ29uYWxdIFNwZWNpZmllcyB3aGV0aGVyIGRpYWdvbmFsIG1vdmVzIGFyZSBhbGxvd2VkXHJcbiovXHJcbmZ1bmN0aW9uIEdyYXBoKGdyaWRJbiwgb3B0aW9ucykge1xyXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICB0aGlzLm5vZGVzID0gW107XHJcbiAgICB0aGlzLmRpYWdvbmFsID0gISFvcHRpb25zLmRpYWdvbmFsO1xyXG4gICAgdGhpcy5ncmlkID0gW107XHJcbiAgICBmb3IgKHZhciB4ID0gMDsgeCA8IGdyaWRJbi5sZW5ndGg7IHgrKykge1xyXG4gICAgICAgIHRoaXMuZ3JpZFt4XSA9IFtdO1xyXG5cclxuICAgICAgICBmb3IgKHZhciB5ID0gMCwgcm93ID0gZ3JpZEluW3hdOyB5IDwgcm93Lmxlbmd0aDsgeSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBub2RlID0gbmV3IEdyaWROb2RlKHgsIHksIHJvd1t5XSk7XHJcbiAgICAgICAgICAgIHRoaXMuZ3JpZFt4XVt5XSA9IG5vZGU7XHJcbiAgICAgICAgICAgIHRoaXMubm9kZXMucHVzaChub2RlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB0aGlzLmluaXQoKTtcclxufVxyXG5cclxuR3JhcGgucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMuZGlydHlOb2RlcyA9IFtdO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm5vZGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgYXN0YXIuY2xlYW5Ob2RlKHRoaXMubm9kZXNbaV0pO1xyXG4gICAgfVxyXG59O1xyXG5cclxuR3JhcGgucHJvdG90eXBlLmNsZWFuRGlydHkgPSBmdW5jdGlvbigpIHtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kaXJ0eU5vZGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgYXN0YXIuY2xlYW5Ob2RlKHRoaXMuZGlydHlOb2Rlc1tpXSk7XHJcbiAgICB9XHJcbiAgICB0aGlzLmRpcnR5Tm9kZXMgPSBbXTtcclxufTtcclxuXHJcbkdyYXBoLnByb3RvdHlwZS5tYXJrRGlydHkgPSBmdW5jdGlvbihub2RlKSB7XHJcbiAgICB0aGlzLmRpcnR5Tm9kZXMucHVzaChub2RlKTtcclxufTtcclxuXHJcbkdyYXBoLnByb3RvdHlwZS5uZWlnaGJvcnMgPSBmdW5jdGlvbihub2RlKSB7XHJcbiAgICB2YXIgcmV0ID0gW10sXHJcbiAgICAgICAgeCA9IG5vZGUueCxcclxuICAgICAgICB5ID0gbm9kZS55LFxyXG4gICAgICAgIGdyaWQgPSB0aGlzLmdyaWQ7XHJcblxyXG4gICAgLy8gV2VzdFxyXG4gICAgaWYoZ3JpZFt4LTFdICYmIGdyaWRbeC0xXVt5XSkge1xyXG4gICAgICAgIHJldC5wdXNoKGdyaWRbeC0xXVt5XSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRWFzdFxyXG4gICAgaWYoZ3JpZFt4KzFdICYmIGdyaWRbeCsxXVt5XSkge1xyXG4gICAgICAgIHJldC5wdXNoKGdyaWRbeCsxXVt5XSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU291dGhcclxuICAgIGlmKGdyaWRbeF0gJiYgZ3JpZFt4XVt5LTFdKSB7XHJcbiAgICAgICAgcmV0LnB1c2goZ3JpZFt4XVt5LTFdKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBOb3J0aFxyXG4gICAgaWYoZ3JpZFt4XSAmJiBncmlkW3hdW3krMV0pIHtcclxuICAgICAgICByZXQucHVzaChncmlkW3hdW3krMV0pO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLmRpYWdvbmFsKSB7XHJcbiAgICAgICAgLy8gU291dGh3ZXN0XHJcbiAgICAgICAgaWYoZ3JpZFt4LTFdICYmIGdyaWRbeC0xXVt5LTFdKSB7XHJcbiAgICAgICAgICAgIHJldC5wdXNoKGdyaWRbeC0xXVt5LTFdKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFNvdXRoZWFzdFxyXG4gICAgICAgIGlmKGdyaWRbeCsxXSAmJiBncmlkW3grMV1beS0xXSkge1xyXG4gICAgICAgICAgICByZXQucHVzaChncmlkW3grMV1beS0xXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBOb3J0aHdlc3RcclxuICAgICAgICBpZihncmlkW3gtMV0gJiYgZ3JpZFt4LTFdW3krMV0pIHtcclxuICAgICAgICAgICAgcmV0LnB1c2goZ3JpZFt4LTFdW3krMV0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gTm9ydGhlYXN0XHJcbiAgICAgICAgaWYoZ3JpZFt4KzFdICYmIGdyaWRbeCsxXVt5KzFdKSB7XHJcbiAgICAgICAgICAgIHJldC5wdXNoKGdyaWRbeCsxXVt5KzFdKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJldDtcclxufTtcclxuXHJcbkdyYXBoLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIGdyYXBoU3RyaW5nID0gW10sXHJcbiAgICAgICAgbm9kZXMgPSB0aGlzLmdyaWQsIC8vIHdoZW4gdXNpbmcgZ3JpZFxyXG4gICAgICAgIHJvd0RlYnVnLCByb3csIHksIGw7XHJcbiAgICBmb3IgKHZhciB4ID0gMCwgbGVuID0gbm9kZXMubGVuZ3RoOyB4IDwgbGVuOyB4KyspIHtcclxuICAgICAgICByb3dEZWJ1ZyA9IFtdO1xyXG4gICAgICAgIHJvdyA9IG5vZGVzW3hdO1xyXG4gICAgICAgIGZvciAoeSA9IDAsIGwgPSByb3cubGVuZ3RoOyB5IDwgbDsgeSsrKSB7XHJcbiAgICAgICAgICAgIHJvd0RlYnVnLnB1c2gocm93W3ldLndlaWdodCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdyYXBoU3RyaW5nLnB1c2gocm93RGVidWcuam9pbignICcpKTtcclxuICAgIH1cclxuICAgIHJldHVybiBncmFwaFN0cmluZy5qb2luKCdcXG4nKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIEdyaWROb2RlKHgsIHksIHdlaWdodCkge1xyXG4gICAgdGhpcy54ID0geDtcclxuICAgIHRoaXMueSA9IHk7XHJcbiAgICB0aGlzLndlaWdodCA9IHdlaWdodDtcclxufVxyXG5cclxuR3JpZE5vZGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gJ1snICsgdGhpcy54ICsgJyAnICsgdGhpcy55ICsgJ10nO1xyXG59O1xyXG5cclxuR3JpZE5vZGUucHJvdG90eXBlLmdldENvc3QgPSBmdW5jdGlvbihmcm9tTmVpZ2hib3IpIHtcclxuICAgIC8vIFRha2UgZGlhZ29uYWwgd2VpZ2h0IGludG8gY29uc2lkZXJhdGlvbi5cclxuICAgIGlmIChmcm9tTmVpZ2hib3IgJiYgZnJvbU5laWdoYm9yLnggIT09IHRoaXMueCAmJiBmcm9tTmVpZ2hib3IueSAhPT0gdGhpcy55KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMud2VpZ2h0ICogMS40MTQyMTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLndlaWdodDtcclxufTtcclxuXHJcbkdyaWROb2RlLnByb3RvdHlwZS5pc1dhbGwgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLndlaWdodCA9PT0gMDtcclxufTtcclxuXHJcbmZ1bmN0aW9uIEJpbmFyeUhlYXAoc2NvcmVGdW5jdGlvbil7XHJcbiAgICB0aGlzLmNvbnRlbnQgPSBbXTtcclxuICAgIHRoaXMuc2NvcmVGdW5jdGlvbiA9IHNjb3JlRnVuY3Rpb247XHJcbn1cclxuXHJcbkJpbmFyeUhlYXAucHJvdG90eXBlID0ge1xyXG4gICAgcHVzaDogZnVuY3Rpb24oZWxlbWVudCkge1xyXG4gICAgICAgIC8vIEFkZCB0aGUgbmV3IGVsZW1lbnQgdG8gdGhlIGVuZCBvZiB0aGUgYXJyYXkuXHJcbiAgICAgICAgdGhpcy5jb250ZW50LnB1c2goZWxlbWVudCk7XHJcblxyXG4gICAgICAgIC8vIEFsbG93IGl0IHRvIHNpbmsgZG93bi5cclxuICAgICAgICB0aGlzLnNpbmtEb3duKHRoaXMuY29udGVudC5sZW5ndGggLSAxKTtcclxuICAgIH0sXHJcbiAgICBwb3A6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIC8vIFN0b3JlIHRoZSBmaXJzdCBlbGVtZW50IHNvIHdlIGNhbiByZXR1cm4gaXQgbGF0ZXIuXHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuY29udGVudFswXTtcclxuICAgICAgICAvLyBHZXQgdGhlIGVsZW1lbnQgYXQgdGhlIGVuZCBvZiB0aGUgYXJyYXkuXHJcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMuY29udGVudC5wb3AoKTtcclxuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgYW55IGVsZW1lbnRzIGxlZnQsIHB1dCB0aGUgZW5kIGVsZW1lbnQgYXQgdGhlXHJcbiAgICAgICAgLy8gc3RhcnQsIGFuZCBsZXQgaXQgYnViYmxlIHVwLlxyXG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnQubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRbMF0gPSBlbmQ7XHJcbiAgICAgICAgICAgIHRoaXMuYnViYmxlVXAoMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9LFxyXG4gICAgcmVtb3ZlOiBmdW5jdGlvbihub2RlKSB7XHJcbiAgICAgICAgdmFyIGkgPSB0aGlzLmNvbnRlbnQuaW5kZXhPZihub2RlKTtcclxuXHJcbiAgICAgICAgLy8gV2hlbiBpdCBpcyBmb3VuZCwgdGhlIHByb2Nlc3Mgc2VlbiBpbiAncG9wJyBpcyByZXBlYXRlZFxyXG4gICAgICAgIC8vIHRvIGZpbGwgdXAgdGhlIGhvbGUuXHJcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMuY29udGVudC5wb3AoKTtcclxuXHJcbiAgICAgICAgaWYgKGkgIT09IHRoaXMuY29udGVudC5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGVudFtpXSA9IGVuZDtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnNjb3JlRnVuY3Rpb24oZW5kKSA8IHRoaXMuc2NvcmVGdW5jdGlvbihub2RlKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zaW5rRG93bihpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYnViYmxlVXAoaSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgc2l6ZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudC5sZW5ndGg7XHJcbiAgICB9LFxyXG4gICAgcmVzY29yZUVsZW1lbnQ6IGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgICAgICB0aGlzLnNpbmtEb3duKHRoaXMuY29udGVudC5pbmRleE9mKG5vZGUpKTtcclxuICAgIH0sXHJcbiAgICBzaW5rRG93bjogZnVuY3Rpb24obikge1xyXG4gICAgICAgIC8vIEZldGNoIHRoZSBlbGVtZW50IHRoYXQgaGFzIHRvIGJlIHN1bmsuXHJcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmNvbnRlbnRbbl07XHJcblxyXG4gICAgICAgIC8vIFdoZW4gYXQgMCwgYW4gZWxlbWVudCBjYW4gbm90IHNpbmsgYW55IGZ1cnRoZXIuXHJcbiAgICAgICAgd2hpbGUgKG4gPiAwKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBDb21wdXRlIHRoZSBwYXJlbnQgZWxlbWVudCdzIGluZGV4LCBhbmQgZmV0Y2ggaXQuXHJcbiAgICAgICAgICAgIHZhciBwYXJlbnROID0gKChuICsgMSkgPj4gMSkgLSAxLCBwYXJlbnQgPSB0aGlzLmNvbnRlbnRbcGFyZW50Tl07IC8vIGpzaGludCBpZ25vcmU6bGluZVxyXG4gICAgICAgICAgICAvLyBTd2FwIHRoZSBlbGVtZW50cyBpZiB0aGUgcGFyZW50IGlzIGdyZWF0ZXIuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnNjb3JlRnVuY3Rpb24oZWxlbWVudCkgPCB0aGlzLnNjb3JlRnVuY3Rpb24ocGFyZW50KSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZW50W3BhcmVudE5dID0gZWxlbWVudDtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udGVudFtuXSA9IHBhcmVudDtcclxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSAnbicgdG8gY29udGludWUgYXQgdGhlIG5ldyBwb3NpdGlvbi5cclxuICAgICAgICAgICAgICAgIG4gPSBwYXJlbnROO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIEZvdW5kIGEgcGFyZW50IHRoYXQgaXMgbGVzcywgbm8gbmVlZCB0byBzaW5rIGFueSBmdXJ0aGVyLlxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGJ1YmJsZVVwOiBmdW5jdGlvbihuKSB7XHJcbiAgICAgICAgLy8gTG9vayB1cCB0aGUgdGFyZ2V0IGVsZW1lbnQgYW5kIGl0cyBzY29yZS5cclxuICAgICAgICB2YXIgbGVuZ3RoID0gdGhpcy5jb250ZW50Lmxlbmd0aCxcclxuICAgICAgICAgICAgZWxlbWVudCA9IHRoaXMuY29udGVudFtuXSxcclxuICAgICAgICAgICAgZWxlbVNjb3JlID0gdGhpcy5zY29yZUZ1bmN0aW9uKGVsZW1lbnQpO1xyXG5cclxuICAgICAgICB3aGlsZSh0cnVlKSB7XHJcbiAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIGluZGljZXMgb2YgdGhlIGNoaWxkIGVsZW1lbnRzLlxyXG4gICAgICAgICAgICB2YXIgY2hpbGQyTiA9IChuICsgMSkgPDwgMSwgY2hpbGQxTiA9IGNoaWxkMk4gLSAxOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcclxuICAgICAgICAgICAgLy8gVGhpcyBpcyB1c2VkIHRvIHN0b3JlIHRoZSBuZXcgcG9zaXRpb24gb2YgdGhlIGVsZW1lbnQsIGlmIGFueS5cclxuICAgICAgICAgICAgdmFyIHN3YXAgPSBudWxsLFxyXG4gICAgICAgICAgICAgICAgY2hpbGQxU2NvcmU7XHJcbiAgICAgICAgICAgIC8vIElmIHRoZSBmaXJzdCBjaGlsZCBleGlzdHMgKGlzIGluc2lkZSB0aGUgYXJyYXkpLi4uXHJcbiAgICAgICAgICAgIGlmIChjaGlsZDFOIDwgbGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBMb29rIGl0IHVwIGFuZCBjb21wdXRlIGl0cyBzY29yZS5cclxuICAgICAgICAgICAgICAgIHZhciBjaGlsZDEgPSB0aGlzLmNvbnRlbnRbY2hpbGQxTl07XHJcbiAgICAgICAgICAgICAgICBjaGlsZDFTY29yZSA9IHRoaXMuc2NvcmVGdW5jdGlvbihjaGlsZDEpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBzY29yZSBpcyBsZXNzIHRoYW4gb3VyIGVsZW1lbnQncywgd2UgbmVlZCB0byBzd2FwLlxyXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkMVNjb3JlIDwgZWxlbVNjb3JlKXtcclxuICAgICAgICAgICAgICAgICAgICBzd2FwID0gY2hpbGQxTjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gRG8gdGhlIHNhbWUgY2hlY2tzIGZvciB0aGUgb3RoZXIgY2hpbGQuXHJcbiAgICAgICAgICAgIGlmIChjaGlsZDJOIDwgbGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQyID0gdGhpcy5jb250ZW50W2NoaWxkMk5dLFxyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkMlNjb3JlID0gdGhpcy5zY29yZUZ1bmN0aW9uKGNoaWxkMik7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQyU2NvcmUgPCAoc3dhcCA9PT0gbnVsbCA/IGVsZW1TY29yZSA6IGNoaWxkMVNjb3JlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN3YXAgPSBjaGlsZDJOO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBJZiB0aGUgZWxlbWVudCBuZWVkcyB0byBiZSBtb3ZlZCwgc3dhcCBpdCwgYW5kIGNvbnRpbnVlLlxyXG4gICAgICAgICAgICBpZiAoc3dhcCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZW50W25dID0gdGhpcy5jb250ZW50W3N3YXBdO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZW50W3N3YXBdID0gZWxlbWVudDtcclxuICAgICAgICAgICAgICAgIG4gPSBzd2FwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgd2UgYXJlIGRvbmUuXHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG5yZXR1cm4ge1xyXG4gICAgYXN0YXI6IGFzdGFyLFxyXG4gICAgR3JhcGg6IEdyYXBoXHJcbn07XHJcblxyXG59KTtcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuLyoqXHJcbiogQGF1dGhvciAgICAgICBKZXJlbXkgRG93ZWxsIDxqZXJlbXlAY29kZXZpbnNreS5jb20+XHJcbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cDovL3d3dy53dGZwbC5uZXQvdHh0L2NvcHlpbmcvfFdURlBMfVxyXG4qL1xyXG5cclxuLyoqXHJcbiogQ3JlYXRlcyBhIG5ldyBgSnVpY3lgIG9iamVjdC5cclxuKlxyXG4qIEBjbGFzcyBQaGFzZXIuUGx1Z2luLkp1aWN5XHJcbiogQGNvbnN0cnVjdG9yXHJcbipcclxuKiBAcGFyYW0ge1BoYXNlci5HYW1lfSBnYW1lIEN1cnJlbnQgZ2FtZSBpbnN0YW5jZS5cclxuKi9cclxuUGhhc2VyLlBsdWdpbi5KdWljeSA9IGZ1bmN0aW9uIChnYW1lKSB7XHJcblxyXG4gIFBoYXNlci5QbHVnaW4uY2FsbCh0aGlzLCBnYW1lKTtcclxuXHJcbiAgLyoqXHJcbiAgKiBAcHJvcGVydHkge1BoYXNlci5SZWN0YW5nbGV9IF9ib3VuZHNDYWNoZSAtIEEgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IHdvcmxkIGJvdW5kcy5cclxuICAqIEBwcml2YXRlXHJcbiAgKi9cclxuICB0aGlzLl9ib3VuZHNDYWNoZSA9IFBoYXNlci5VdGlscy5leHRlbmQoZmFsc2UsIHt9LCB0aGlzLmdhbWUud29ybGQuYm91bmRzKTtcclxuXHJcbiAgLyoqXHJcbiAgKiBAcHJvcGVydHkge251bWJlcn0gX3NoYWtlV29ybGRNYXggLSBUaGUgbWF4aW11bSB3b3JsZCBzaGFrZSByYWRpdXNcclxuICAqIEBwcml2YXRlXHJcbiAgKi9cclxuICB0aGlzLl9zaGFrZVdvcmxkTWF4ID0gMjA7XHJcblxyXG4gIC8qKlxyXG4gICogQHByb3BlcnR5IHtudW1iZXJ9IF9zaGFrZVdvcmxkVGltZSAtIFRoZSBtYXhpbXVtIHdvcmxkIHNoYWtlIHRpbWVcclxuICAqIEBwcml2YXRlXHJcbiAgKi9cclxuICB0aGlzLl9zaGFrZVdvcmxkVGltZSA9IDA7XHJcblxyXG4gIC8qKlxyXG4gICogQHByb3BlcnR5IHtudW1iZXJ9IF90cmFpbENvdW50ZXIgLSBBIGNvdW50IG9mIGhvdyBtYW55IHRyYWlscyB3ZSdyZSB0cmFja2luZ1xyXG4gICogQHByaXZhdGVcclxuICAqLyAgXHJcbiAgdGhpcy5fdHJhaWxDb3VudGVyID0gMDtcclxuXHJcbiAgLyoqXHJcbiAgKiBAcHJvcGVydHkge29iamVjdH0gX292ZXJTY2FsZXMgLSBBbiBvYmplY3QgY29udGFpbmluZyBvdmVyc2NhbGluZyBjb25maWd1cmF0aW9uc1xyXG4gICogQHByaXZhdGVcclxuICAqLyAgXHJcbiAgdGhpcy5fb3ZlclNjYWxlcyA9IHt9O1xyXG5cclxuICAvKipcclxuICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBfb3ZlclNjYWxlc0NvdW50ZXIgLSBBIGNvdW50IG9mIGhvdyBtYW55IG92ZXJTY2FsZXMgd2UncmUgdHJhY2tpbmdcclxuICAqIEBwcml2YXRlXHJcbiAgKi8gIFxyXG4gIHRoaXMuX292ZXJTY2FsZXNDb3VudGVyID0gMDtcclxufTtcclxuXHJcbmlmKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XHJcbiAgbW9kdWxlLmV4cG9ydHMgPSBQaGFzZXIuUGx1Z2luLkp1aWN5O1xyXG59XHJcblxyXG5QaGFzZXIuUGx1Z2luLkp1aWN5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUGhhc2VyLlBsdWdpbi5wcm90b3R5cGUpO1xyXG5QaGFzZXIuUGx1Z2luLkp1aWN5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBoYXNlci5QbHVnaW4uSnVpY3k7XHJcblxyXG4vKipcclxuKiBDcmVhdGVzIGEgbmV3IGBKdWljeS5TY3JlZW5GbGFzaGAgb2JqZWN0LlxyXG4qXHJcbiogQGNsYXNzIFBoYXNlci5QbHVnaW4uSnVpY3kuU2NyZWVuRmxhc2hcclxuKiBAY29uc3RydWN0b3JcclxuKlxyXG4qIEBwYXJhbSB7UGhhc2VyLkdhbWV9IGdhbWUgLSAgQ3VycmVudCBnYW1lIGluc3RhbmNlLlxyXG4qIEBwYXJhbSB7c3RyaW5nfSBjb2xvcj0nd2hpdGUnIC0gVGhlIGNvbG9yIHRvIGZsYXNoIHRoZSBzY3JlZW4uXHJcbiogQG1lbWJlcm9mIFBoYXNlci5QbHVnaW4uSnVpY3lcclxuKi9cclxuUGhhc2VyLlBsdWdpbi5KdWljeS5TY3JlZW5GbGFzaCA9IGZ1bmN0aW9uKGdhbWUsIGNvbG9yKSB7XHJcbiAgY29sb3IgPSBjb2xvciB8fCAnd2hpdGUnO1xyXG4gIHZhciBibWQgPSBnYW1lLmFkZC5iaXRtYXBEYXRhKGdhbWUud2lkdGgsIGdhbWUuaGVpZ2h0KTtcclxuICBibWQuY3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xyXG4gIGJtZC5jdHguZmlsbFJlY3QoMCwwLCBnYW1lLndpZHRoLCBnYW1lLmhlaWdodCk7XHJcblxyXG4gIFBoYXNlci5TcHJpdGUuY2FsbCh0aGlzLCBnYW1lLCAwLDAsIGJtZCk7XHJcbiAgdGhpcy5hbHBoYSA9IDA7XHJcbn07XHJcblxyXG5QaGFzZXIuUGx1Z2luLkp1aWN5LlNjcmVlbkZsYXNoLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUGhhc2VyLlNwcml0ZS5wcm90b3R5cGUpO1xyXG5QaGFzZXIuUGx1Z2luLkp1aWN5LlNjcmVlbkZsYXNoLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBoYXNlci5QbHVnaW4uSnVpY3kuU2NyZWVuRmxhc2g7XHJcblxyXG5cclxuLypcclxuKiBGbGFzaGVzIHRoZSBzY3JlZW5cclxuKlxyXG4qIEBwYXJhbSB7bnVtYmVyfSBbbWF4QWxwaGE9MV0gLSBUaGUgbWF4aW11bSBhbHBoYSB0byBmbGFzaCB0aGUgc2NyZWVuIHRvXHJcbiogQHBhcmFtIHtudW1iZXJ9IFtkdXJhdGlvbj0xMDBdIC0gVGhlIGR1cmF0aW9uIG9mIHRoZSBmbGFzaCBpbiBtaWxsaXNlY29uZHNcclxuKiBAbWV0aG9kIFBoYXNlci5QbHVnaW4uSnVpY3kuU2NyZWVuRmxhc2gucHJvdG90eXBlLmZsYXNoXHJcbiogQG1lbWJlcm9mIFBoYXNlci5QbHVnaW4uSnVpY3kuU2NyZWVuRmxhc2hcclxuKi9cclxuUGhhc2VyLlBsdWdpbi5KdWljeS5TY3JlZW5GbGFzaC5wcm90b3R5cGUuZmxhc2ggPSBmdW5jdGlvbihtYXhBbHBoYSwgZHVyYXRpb24pIHtcclxuICBtYXhBbHBoYSA9IG1heEFscGhhIHx8IDE7XHJcbiAgZHVyYXRpb24gPSBkdXJhdGlvbiB8fCAxMDA7XHJcbiAgdmFyIGZsYXNoVHdlZW4gPSB0aGlzLmdhbWUuYWRkLnR3ZWVuKHRoaXMpLnRvKHthbHBoYTogbWF4QWxwaGF9LCAxMDAsIFBoYXNlci5FYXNpbmcuQm91bmNlLkluT3V0LCB0cnVlLDAsIDAsIHRydWUpO1xyXG4gIGZsYXNoVHdlZW4ub25Db21wbGV0ZS5hZGQoZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLmFscGhhID0gMDtcclxuICB9LCB0aGlzKTtcclxufTtcclxuXHJcbi8qKlxyXG4qIENyZWF0ZXMgYSBuZXcgYEp1aWN5LlRyYWlsYCBvYmplY3QuXHJcbipcclxuKiBAY2xhc3MgUGhhc2VyLlBsdWdpbi5KdWljeS5UcmFpbFxyXG4qIEBjb25zdHJ1Y3RvclxyXG4qXHJcbiogQHBhcmFtIHtQaGFzZXIuR2FtZX0gZ2FtZSAtICBDdXJyZW50IGdhbWUgaW5zdGFuY2UuXHJcbiogQHBhcmFtIHtudW1iZXJ9IFt0cmFpbExlbmd0aD0xMDBdIC0gVGhlIGxlbmd0aCBvZiB0aGUgdHJhaWxcclxuKiBAcGFyYW0ge251bWJlcn0gW2NvbG9yPTB4RkZGRkZGXSAtIFRoZSBjb2xvciBvZiB0aGUgdHJhaWxcclxuKiBAbWVtYmVyb2YgUGhhc2VyLlBsdWdpbi5KdWljeVxyXG4qL1xyXG5QaGFzZXIuUGx1Z2luLkp1aWN5LlRyYWlsID0gZnVuY3Rpb24oZ2FtZSwgdHJhaWxMZW5ndGgsIGNvbG9yKSB7XHJcbiAgUGhhc2VyLkdyYXBoaWNzLmNhbGwodGhpcywgZ2FtZSwgMCwwKTtcclxuICBcclxuICAvKipcclxuICAqIEBwcm9wZXJ0eSB7UGhhc2VyLlNwcml0ZX0gdGFyZ2V0IC0gVGhlIHRhcmdldCBzcHJpdGUgd2hvc2UgbW92ZW1lbnQgd2Ugd2FudCB0byBjcmVhdGUgdGhlIHRyYWlsIGZyb21cclxuICAqL1xyXG4gIHRoaXMudGFyZ2V0ID0gbnVsbDtcclxuICAvKipcclxuICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0cmFpbExlbmd0aCAtIFRoZSBudW1iZXIgb2Ygc2VnbWVudHMgdG8gdXNlIHRvIGNyZWF0ZSB0aGUgdHJhaWxcclxuICAqL1xyXG4gIHRoaXMudHJhaWxMZW5ndGggPSB0cmFpbExlbmd0aCB8fCAxMDA7XHJcbiAgLyoqXHJcbiAgKiBAcHJvcGVydHkge251bWJlcn0gdHJhaWxXaWR0aCAtIFRoZSB3aWR0aCBvZiB0aGUgdHJhaWxcclxuICAqL1xyXG4gIHRoaXMudHJhaWxXaWR0aCA9IDE1LjA7XHJcblxyXG4gIC8qKlxyXG4gICogQHByb3BlcnR5IHtib29sZWFufSB0cmFpbFNjYWxlIC0gV2hldGhlciBvciBub3QgdG8gdGFwZXIgdGhlIHRyYWlsIHRvd2FyZHMgdGhlIGVuZFxyXG4gICovXHJcbiAgdGhpcy50cmFpbFNjYWxpbmcgPSBmYWxzZTtcclxuXHJcbiAgLyoqXHJcbiAgKiBAcHJvcGVydHkge1BoYXNlci5TcHJpdGV9IHRyYWlsQ29sb3IgLSBUaGUgY29sb3Igb2YgdGhlIHRyYWlsXHJcbiAgKi9cclxuICB0aGlzLnRyYWlsQ29sb3IgPSBjb2xvciB8fCAweEZGRkZGRjtcclxuICBcclxuICAvKipcclxuICAqIEBwcm9wZXJ0eSB7QXJyYXk8UGhhc2VyLlBvaW50Pn0gX3NlZ21lbnRzIC0gQSBoaXN0b3JpY2FsIGNvbGxlY3Rpb24gb2YgdGhlIHByZXZpb3VzIHBvc2l0aW9uIG9mIHRoZSB0YXJnZXRcclxuICAqIEBwcml2YXRlXHJcbiAgKi9cclxuICB0aGlzLl9zZWdtZW50cyA9IFtdO1xyXG4gIC8qKlxyXG4gICogQHByb3BlcnR5IHtBcnJheTxudW1iZXI+fSBfdmVydHMgLSBBIGNvbGxlY3Rpb24gb2YgdmVydGljZXMgY3JlYXRlZCBmcm9tIF9zZWdtZW50c1xyXG4gICogQHByaXZhdGVcclxuICAqL1xyXG4gIHRoaXMuX3ZlcnRzID0gW107XHJcbiAgLyoqXHJcbiAgKiBAcHJvcGVydHkge0FycmF5PFBoYXNlci5Qb2ludD59IF9zZWdtZW50cyAtIEEgY29sbGVjdGlvbiBvZiBpbmRpY2VzIGNyZWF0ZWQgZnJvbSBfdmVydHNcclxuICAqIEBwcml2YXRlXHJcbiAgKi9cclxuICB0aGlzLl9pbmRpY2VzID0gW107XHJcblxyXG59O1xyXG5cclxuUGhhc2VyLlBsdWdpbi5KdWljeS5UcmFpbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFBoYXNlci5HcmFwaGljcy5wcm90b3R5cGUpO1xyXG5QaGFzZXIuUGx1Z2luLkp1aWN5LlRyYWlsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBoYXNlci5QbHVnaW4uSnVpY3kuVHJhaWw7XHJcblxyXG4vKipcclxuKiBVcGRhdGVzIHRoZSBUcmFpbCBpZiBhIHRhcmdldCBpcyBzZXRcclxuKlxyXG4qIEBtZXRob2QgUGhhc2VyLlBsdWdpbi5KdWljeS5UcmFpbCN1cGRhdGVcclxuKiBAbWVtYmVyb2YgUGhhc2VyLlBsdWdpbi5KdWljeS5UcmFpbFxyXG4qL1xyXG5cclxuUGhhc2VyLlBsdWdpbi5KdWljeS5UcmFpbC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgaWYodGhpcy50YXJnZXQpIHtcclxuICAgIHRoaXMueCA9IHRoaXMudGFyZ2V0Lng7XHJcbiAgICB0aGlzLnkgPSB0aGlzLnRhcmdldC55O1xyXG4gICAgdGhpcy5hZGRTZWdtZW50KHRoaXMudGFyZ2V0LngsIHRoaXMudGFyZ2V0LnkpO1xyXG4gICAgdGhpcy5yZWRyYXdTZWdtZW50cyh0aGlzLnRhcmdldC54LCB0aGlzLnRhcmdldC55KTtcclxuICB9XHJcbn07XHJcblxyXG4vKipcclxuKiBBZGRzIGEgc2VnbWVudCB0byB0aGUgc2VnbWVudHMgbGlzdCBhbmQgY3VsbHMgdGhlIGxpc3QgaWYgaXQgaXMgdG9vIGxvbmdcclxuKiBcclxuKiBAcGFyYW0ge251bWJlcn0gW3hdIC0gVGhlIHggcG9zaXRpb24gb2YgdGhlIHBvaW50XHJcbiogQHBhcmFtIHtudW1iZXJ9IFt5XSAtIFRoZSB5IHBvc2l0aW9uIG9mIHRoZSBwb2ludFxyXG4qIFxyXG4qIEBtZXRob2QgUGhhc2VyLlBsdWdpbi5KdWljeS5UcmFpbCNhZGRTZWdtZW50XHJcbiogQG1lbWJlcm9mIFBoYXNlci5QbHVnaW4uSnVpY3kuVHJhaWxcclxuKi9cclxuUGhhc2VyLlBsdWdpbi5KdWljeS5UcmFpbC5wcm90b3R5cGUuYWRkU2VnbWVudCA9IGZ1bmN0aW9uKHgsIHkpIHtcclxuICB2YXIgc2VnbWVudDtcclxuXHJcbiAgd2hpbGUodGhpcy5fc2VnbWVudHMubGVuZ3RoID4gdGhpcy50cmFpbExlbmd0aCkge1xyXG4gICAgc2VnbWVudCA9IHRoaXMuX3NlZ21lbnRzLnNoaWZ0KCk7XHJcbiAgfVxyXG4gIGlmKCFzZWdtZW50KSB7XHJcbiAgICBzZWdtZW50ID0gbmV3IFBoYXNlci5Qb2ludCgpO1xyXG4gIH1cclxuXHJcbiAgc2VnbWVudC54ID0geDtcclxuICBzZWdtZW50LnkgPSB5O1xyXG5cclxuICB0aGlzLl9zZWdtZW50cy5wdXNoKHNlZ21lbnQpO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4qIENyZWF0ZXMgYW5kIGRyYXdzIHRoZSB0cmlhbmdsZSB0cmFpbCBmcm9tIHNlZ21lbnRzXHJcbiogXHJcbiogQHBhcmFtIHtudW1iZXJ9IFtvZmZzZXRYXSAtIFRoZSB4IHBvc2l0aW9uIG9mIHRoZSBvYmplY3RcclxuKiBAcGFyYW0ge251bWJlcn0gW29mZnNldFldIC0gVGhlIHkgcG9zaXRpb24gb2YgdGhlIG9iamVjdFxyXG4qIFxyXG4qIEBtZXRob2QgUGhhc2VyLlBsdWdpbi5KdWljeS5UcmFpbCNyZWRyYXdTZWdtZW50XHJcbiogQG1lbWJlcm9mIFBoYXNlci5QbHVnaW4uSnVpY3kuVHJhaWxcclxuKi9cclxuUGhhc2VyLlBsdWdpbi5KdWljeS5UcmFpbC5wcm90b3R5cGUucmVkcmF3U2VnbWVudHMgPSBmdW5jdGlvbihvZmZzZXRYLCBvZmZzZXRZKSB7XHJcbiAgdGhpcy5jbGVhcigpO1xyXG4gIHZhciBzMSwgLy8gY3VycmVudCBzZWdtZW50XHJcbiAgICAgIHMyLCAvLyBwcmV2aW91cyBzZWdtZW50XHJcbiAgICAgIHZlcnRJbmRleCA9IDAsIC8vIGtlZXBzIHRyYWNrIG9mIHdoaWNoIHZlcnRleCBpbmRleCB3ZSdyZSBhdFxyXG4gICAgICBvZmZzZXQsIC8vIHRlbXBvcmFyeSBzdG9yYWdlIGZvciBhbW91bnQgdG8gZXh0ZW5kIGxpbmUgb3V0d2FyZHMsIGJpZ2dlciA9IHdpZGVyXHJcbiAgICAgIGFuZywgLy90ZW1wb3Jhcnkgc3RvcmFnZSBvZiB0aGUgaW50ZXItc2VnbWVudCBhbmdsZXNcclxuICAgICAgc2luID0gMCwgLy8gYXMgYWJvdmVcclxuICAgICAgY29zID0gMDsgLy8gYWdhaW4gYXMgYWJvdmVcclxuXHJcbiAgLy8gZmlyc3Qgd2UgbWFrZSBzdXJlIHRoYXQgdGhlIHZlcnRpY2UgbGlzdCBpcyB0aGUgc2FtZSBsZW5ndGggYXMgd2Ugd2Ugd2FudFxyXG4gIC8vIGVhY2ggc2VnbWVudCAoZXhjZXB0IHRoZSBmaXJzdCkgd2lsbCBjcmVhdGUgdG8gdmVydGljZXMgd2l0aCB0d28gdmFsdWVzIGVhY2hcclxuICBpZiAodGhpcy5fdmVydHMubGVuZ3RoICE9PSAodGhpcy5fc2VnbWVudHMubGVuZ3RoIC0xKSAqIDQpIHtcclxuICAgIC8vIGlmIGl0J3Mgbm90IGNvcnJlY3QsIHdlIGNsZWFyIHRoZSBlbnRpcmUgbGlzdFxyXG4gICAgdGhpcy5fdmVydHMgPSBbXTtcclxuICB9XHJcblxyXG4gIC8vIG5vdyB3ZSBsb29wIG92ZXIgYWxsIHRoZSBzZWdtZW50cywgdGhlIGxpc3QgaGFzIHRoZSBcInlvdW5nZXN0XCIgc2VnbWVudCBhdCB0aGUgZW5kXHJcbiAgdmFyIHByZXZBbmcgPSAwOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcclxuICBcclxuICBmb3IodmFyIGogPSAwOyBqIDwgdGhpcy5fc2VnbWVudHMubGVuZ3RoOyArK2opIHtcclxuICAgIC8vIHN0b3JlIHRoZSBhY3RpdmUgc2VnbWVudCBmb3IgY29udmVuaWVuY2VcclxuICAgIHMxID0gdGhpcy5fc2VnbWVudHNbal07XHJcblxyXG4gICAgLy8gaWYgdGhlcmUncyBhIHByZXZpb3VzIHNlZ21lbnQsIHRpbWUgdG8gZG8gc29tZSBtYXRoXHJcbiAgICBpZihzMikge1xyXG4gICAgICAvLyB3ZSBjYWxjdWxhdGUgdGhlIGFuZ2xlIGJldHdlZW4gdGhlIHR3byBzZWdtZW50c1xyXG4gICAgICAvLyB0aGUgcmVzdWx0IHdpbGwgYmUgaW4gcmFkaWFucywgc28gYWRkaW5nIGhhbGYgb2YgcGkgd2lsbCBcInR1cm5cIiB0aGUgYW5nbGUgOTAgZGVncmVlc1xyXG4gICAgICAvLyB0aGF0IG1lYW5zIHdlIGNhbiB1c2UgdGhlIHNpbiBhbmQgY29zIHZhbHVlcyB0byBcImV4cGFuZFwiIHRoZSBsaW5lIG91dHdhcmRzXHJcbiAgICAgIGFuZyA9IE1hdGguYXRhbjIoczEueSAtIHMyLnksIHMxLnggLSBzMi54KSArIE1hdGguUEkgLyAyO1xyXG4gICAgICBzaW4gPSBNYXRoLnNpbihhbmcpO1xyXG4gICAgICBjb3MgPSBNYXRoLmNvcyhhbmcpO1xyXG5cclxuICAgICAgLy8gbm93IGl0J3MgdGltZSB0byBjcmVhdCBldGhlIHR3byB2ZXJ0aWNlcyB0aGF0IHdpbGwgcmVwcmVzZW50IHRoaXMgcGFpciBvZiBzZWdtZW50c1xyXG4gICAgICAvLyB1c2luZyBhIGxvb3AgaGVyZSBpcyBwcm9iYWJseSBhIGJpdCBvdmVya2lsbCBzaW5jZSBpdCdzIG9ubHkgdHdvIGl0ZXJhdGlvbnNcclxuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IDI7ICsraSkge1xyXG4gICAgICAgIC8vIHRoaXMgbWFrZXMgdGhlIGZpcnN0IHNlZ21lbnQgc3RhbmQgb3V0IHRvIHRoZSBcImxlZnRcIiBvZiB0aGUgbGluZVxyXG4gICAgICAgIC8vIGFubmQgdGhlIHNlY29uZCB0byB0aGUgcmlnaHQsIGNoYW5naW5nIHRoYXQgbWFnaWMgbnVtYmVyIGF0IHRoZSBlbmQgd2lsbCBhbHRoZXIgdGhlIGxpbmUgd2lkdGhcclxuICAgICAgICBvZmZzZXQgPSAoIC0wLjUgKyBpIC8gMSkgKiB0aGlzLnRyYWlsV2lkdGg7XHJcblxyXG4gICAgICAgIC8vIGlmIHRyYWlsIHNjYWxlIGVmZmVjdCBpcyBlbmFibGVkLCB3ZSBzY2FsZSBkb3duIHRoZSBvZmZzZXQgYXMgd2UgbW92ZSBkb3duIHRoZSBsaXN0XHJcbiAgICAgICAgaWYodGhpcy50cmFpbFNjYWxpbmcpIHtcclxuICAgICAgICAgIG9mZnNldCAqPSBqIC8gdGhpcy5fc2VnbWVudHMubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gZmluYWxseSB3ZSBwdXQgdG8gdmFsdWVzIGluIHRoZSB2ZXJ0IGxpc3RcclxuICAgICAgICAvLyB1c2luZyB0aGUgc2VnbWVudCBjb29yZGluYXRlcyBhcyBhIGJhc2Ugd2UgYWRkIHRoZSBcImV4dGVuZGVkXCIgcG9pbnRcclxuICAgICAgICAvLyBvZmZzZXRYIGFuZCBvZmZzZXRZIGFyZSB1c2VkIGhlciB0byBtb3ZlIHRoZSBlbnRpcmUgdHJhaWxcclxuICAgICAgICB0aGlzLl92ZXJ0c1t2ZXJ0SW5kZXgrK10gPSBzMS54ICsgY29zICogb2Zmc2V0IC0gb2Zmc2V0WDtcclxuICAgICAgICB0aGlzLl92ZXJ0c1t2ZXJ0SW5kZXgrK10gPSBzMS55ICsgc2luICogb2Zmc2V0IC0gb2Zmc2V0WTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gZmluYWxseSBzdG9yZSB0aGUgY3VycmVudCBzZWdtZW50IGFzIHRoZSBwcmV2aW91cyBzZWdtZW50IGFuZCBnbyBmb3IgYW5vdGhlciByb3VuZFxyXG4gICAgczIgPSBzMS5jb3B5VG8oe30pO1xyXG4gIH1cclxuICAvLyB3ZSBuZWVkIGF0IGxlYXN0IGZvdXIgdmVydGljZXMgdG8gZHJhdyBzb21ldGhpbmdcclxuICBpZih0aGlzLl92ZXJ0cy5sZW5ndGggPj0gOCkge1xyXG4gICAgLy8gbm93LCB3ZSBoYXZlIGEgdHJpYW5nbGUgXCJzdHJpcFwiLCBidXQgZmxhc2ggY2FuJ3QgZHJhdyB0aGF0IHdpdGhvdXQgXHJcbiAgICAvLyBpbnN0cnVjdGlvbnMgZm9yIHdoaWNoIHZlcnRpY2VzIHRvIGNvbm5lY3QsIHNvIGl0J3MgdGltZSB0byBtYWtlIHRob3NlXHJcbiAgICBcclxuICAgIC8vIGhlcmUsIHdlIGxvb3Agb3ZlciBhbGwgdGhlIHZlcnRpY2VzIGFuZCBwYWlyIHRoZW0gdG9nZXRoZXIgaW4gdHJpYW5nbGVzXHJcbiAgICAvLyBlYWNoIGdyb3VwIG9mIGZvdXIgdmVydGljZXMgZm9ybXMgdHdvIHRyaWFuZ2xlc1xyXG4gICAgZm9yKHZhciBrID0gMDsgayA8IHRoaXMuX3ZlcnRzLmxlbmd0aDsgaysrKSB7XHJcbiAgICAgIHRoaXMuX2luZGljZXNbayAqIDYgKyAwXSA9IGsgKiAyICsgMDtcclxuICAgICAgdGhpcy5faW5kaWNlc1trICogNiArIDFdID0gayAqIDIgKyAxO1xyXG4gICAgICB0aGlzLl9pbmRpY2VzW2sgKiA2ICsgMl0gPSBrICogMiArIDI7XHJcbiAgICAgIHRoaXMuX2luZGljZXNbayAqIDYgKyAzXSA9IGsgKiAyICsgMTtcclxuICAgICAgdGhpcy5faW5kaWNlc1trICogNiArIDRdID0gayAqIDIgKyAyO1xyXG4gICAgICB0aGlzLl9pbmRpY2VzW2sgKiA2ICsgNV0gPSBrICogMiArIDM7XHJcbiAgICB9XHJcbiAgICB0aGlzLmJlZ2luRmlsbCh0aGlzLnRyYWlsQ29sb3IpO1xyXG4gICAgdGhpcy5kcmF3VHJpYW5nbGVzKHRoaXMuX3ZlcnRzLCB0aGlzLl9pbmRpY2VzKTtcclxuICAgIHRoaXMuZW5kRmlsbCgpO1xyXG4gICAgXHJcbiAgfVxyXG59O1xyXG5cclxuUGhhc2VyLlBsdWdpbi5KdWljeS5wcm90b3R5cGUuc2hha2UgPSBmdW5jdGlvbiAoZHVyYXRpb24sIHN0cmVuZ3RoKSB7XHJcbiAgaWYgKHRoaXMuZ2FtZS5jYW1lcmEudGFyZ2V0ICE9PSBudWxsKSB7XHJcbiAgICAgdGhpcy5jYW1lcmFUYXJnZXQgPSB0aGlzLmdhbWUuY2FtZXJhLnRhcmdldDtcclxuICAgICB0aGlzLmdhbWUuY2FtZXJhLnVuZm9sbG93KCk7XHJcbiAgfVxyXG4gIHRoaXMuX3NoYWtlV29ybGRUaW1lID0gZHVyYXRpb24gfHwgMjA7XHJcbiAgdGhpcy5fc2hha2VXb3JsZE1heCA9IHN0cmVuZ3RoIHx8IDIwO1xyXG59O1xyXG5cclxuUGhhc2VyLlBsdWdpbi5KdWljeS5wcm90b3R5cGUuY3JlYXRlU2NyZWVuRmxhc2ggPSBmdW5jdGlvbihjb2xvcikge1xyXG4gICAgcmV0dXJuIG5ldyBQaGFzZXIuUGx1Z2luLkp1aWN5LlNjcmVlbkZsYXNoKHRoaXMuZ2FtZSwgY29sb3IpO1xyXG59O1xyXG5cclxuXHJcblBoYXNlci5QbHVnaW4uSnVpY3kucHJvdG90eXBlLmNyZWF0ZVRyYWlsID0gZnVuY3Rpb24obGVuZ3RoLCBjb2xvcikge1xyXG4gIHJldHVybiBuZXcgUGhhc2VyLlBsdWdpbi5KdWljeS5UcmFpbCh0aGlzLmdhbWUsIGxlbmd0aCwgY29sb3IpO1xyXG59O1xyXG5cclxuUGhhc2VyLlBsdWdpbi5KdWljeS5wcm90b3R5cGUub3ZlclNjYWxlID0gZnVuY3Rpb24ob2JqZWN0LCBzY2FsZSwgaW5pdGlhbFNjYWxlKSB7XHJcbiAgc2NhbGUgPSBzY2FsZSB8fCAxLjU7XHJcbiAgdmFyIGlkID0gdGhpcy5fb3ZlclNjYWxlc0NvdW50ZXIrKztcclxuICBpbml0aWFsU2NhbGUgPSBpbml0aWFsU2NhbGUgfHwgbmV3IFBoYXNlci5Qb2ludCgxLDEpO1xyXG4gIHZhciBzY2FsZU9iaiA9IHRoaXMuX292ZXJTY2FsZXNbaWRdO1xyXG4gIGlmKCFzY2FsZU9iaikge1xyXG4gICAgc2NhbGVPYmogPSB7XHJcbiAgICAgIG9iamVjdDogb2JqZWN0LFxyXG4gICAgICBjYWNoZTogaW5pdGlhbFNjYWxlLmNvcHlUbyh7fSlcclxuICAgIH07XHJcbiAgfSBcclxuICBzY2FsZU9iai5zY2FsZSA9IHNjYWxlO1xyXG4gIFxyXG4gIHRoaXMuX292ZXJTY2FsZXNbaWRdID0gc2NhbGVPYmo7XHJcbn07XHJcblxyXG5QaGFzZXIuUGx1Z2luLkp1aWN5LnByb3RvdHlwZS5qZWxseSA9IGZ1bmN0aW9uKG9iamVjdCwgc3RyZW5ndGgsIGRlbGF5LCBpbml0aWFsU2NhbGUpIHtcclxuICBzdHJlbmd0aCA9IHN0cmVuZ3RoIHx8IDAuMjtcclxuICBkZWxheSA9IGRlbGF5IHx8IDA7XHJcbiAgaW5pdGlhbFNjYWxlID0gaW5pdGlhbFNjYWxlIHx8ICBuZXcgUGhhc2VyLlBvaW50KDEsIDEpO1xyXG4gIFxyXG4gIHRoaXMuZ2FtZS5hZGQudHdlZW4ob2JqZWN0LnNjYWxlKS50byh7eDogaW5pdGlhbFNjYWxlLnggKyAoaW5pdGlhbFNjYWxlLnggKiBzdHJlbmd0aCl9LCA1MCwgUGhhc2VyLkVhc2luZy5RdWFkcmF0aWMuSW5PdXQsIHRydWUsIGRlbGF5KVxyXG4gIC50byh7eDogaW5pdGlhbFNjYWxlLnh9LCA2MDAsIFBoYXNlci5FYXNpbmcuRWxhc3RpYy5PdXQsIHRydWUpO1xyXG5cclxuICB0aGlzLmdhbWUuYWRkLnR3ZWVuKG9iamVjdC5zY2FsZSkudG8oe3k6IGluaXRpYWxTY2FsZS55ICsgKGluaXRpYWxTY2FsZS55ICogc3RyZW5ndGgpfSwgNTAsIFBoYXNlci5FYXNpbmcuUXVhZHJhdGljLkluT3V0LCB0cnVlLCBkZWxheSArIDUwKVxyXG4gIC50byh7eTogaW5pdGlhbFNjYWxlLnl9LCA2MDAsIFBoYXNlci5FYXNpbmcuRWxhc3RpYy5PdXQsIHRydWUpO1xyXG59O1xyXG5cclxuUGhhc2VyLlBsdWdpbi5KdWljeS5wcm90b3R5cGUubW91c2VTdHJldGNoID0gZnVuY3Rpb24ob2JqZWN0LCBzdHJlbmd0aCwgaW5pdGlhbFNjYWxlKSB7XHJcbiAgICBzdHJlbmd0aCA9IHN0cmVuZ3RoIHx8IDAuNTtcclxuICAgIGluaXRpYWxTY2FsZSA9IGluaXRpYWxTY2FsZSB8fCBuZXcgUGhhc2VyLlBvaW50KDEsMSk7XHJcbiAgICBvYmplY3Quc2NhbGUueCA9IGluaXRpYWxTY2FsZS54ICsgKE1hdGguYWJzKG9iamVjdC54IC0gdGhpcy5nYW1lLmlucHV0LmFjdGl2ZVBvaW50ZXIueCkgLyAxMDApICogc3RyZW5ndGg7XHJcbiAgICBvYmplY3Quc2NhbGUueSA9IGluaXRpYWxTY2FsZS55ICsgKGluaXRpYWxTY2FsZS55ICogc3RyZW5ndGgpIC0gKG9iamVjdC5zY2FsZS54ICogc3RyZW5ndGgpO1xyXG59O1xyXG5cclxuUGhhc2VyLlBsdWdpbi5KdWljeS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBzY2FsZU9iajtcclxuICAvLyBTY3JlZW4gU2hha2VcclxuICBpZih0aGlzLl9zaGFrZVdvcmxkVGltZSA+IDApIHsgXHJcbiAgICB2YXIgbWFnbml0dWRlID0gKHRoaXMuX3NoYWtlV29ybGRUaW1lIC8gdGhpcy5fc2hha2VXb3JsZE1heCkgKiB0aGlzLl9zaGFrZVdvcmxkTWF4O1xyXG4gICAgdmFyIHggPSB0aGlzLmdhbWUucm5kLmludGVnZXJJblJhbmdlKC1tYWduaXR1ZGUsIG1hZ25pdHVkZSkgKyB0aGlzLmNhbWVyYVRhcmdldC54IC0gdGhpcy5nYW1lLmNhbWVyYS53aWR0aCAvIDI7XHJcbiAgICB2YXIgeSA9IHRoaXMuZ2FtZS5ybmQuaW50ZWdlckluUmFuZ2UoLW1hZ25pdHVkZSwgbWFnbml0dWRlKSArIHRoaXMuY2FtZXJhVGFyZ2V0LnkgLSB0aGlzLmdhbWUuY2FtZXJhLmhlaWdodCAvIDI7XHJcblxyXG4gICAgdGhpcy5nYW1lLmNhbWVyYS54ID0geDtcclxuICAgIHRoaXMuZ2FtZS5jYW1lcmEueSA9IHk7XHJcbiAgICB0aGlzLl9zaGFrZVdvcmxkVGltZS0tO1xyXG4gICAgaWYodGhpcy5fc2hha2VXb3JsZFRpbWUgPD0gMCkge1xyXG4gICAgICAgdGhpcy5nYW1lLmNhbWVyYS5mb2xsb3codGhpcy5jYW1lcmFUYXJnZXQpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gb3ZlciBzY2FsZXNcclxuICBmb3IodmFyIHMgaW4gdGhpcy5fb3ZlclNjYWxlcykge1xyXG4gICAgaWYodGhpcy5fb3ZlclNjYWxlcy5oYXNPd25Qcm9wZXJ0eShzKSkge1xyXG4gICAgICBzY2FsZU9iaiA9IHRoaXMuX292ZXJTY2FsZXNbc107XHJcbiAgICAgIGlmKHNjYWxlT2JqLnNjYWxlID4gMC4wMSkge1xyXG4gICAgICAgIHNjYWxlT2JqLm9iamVjdC5zY2FsZS54ID0gc2NhbGVPYmouc2NhbGUgKiBzY2FsZU9iai5jYWNoZS54O1xyXG4gICAgICAgIHNjYWxlT2JqLm9iamVjdC5zY2FsZS55ID0gc2NhbGVPYmouc2NhbGUgKiBzY2FsZU9iai5jYWNoZS55O1xyXG4gICAgICAgIHNjYWxlT2JqLnNjYWxlIC09IHRoaXMuZ2FtZS50aW1lLmVsYXBzZWQgKiBzY2FsZU9iai5zY2FsZSAqIDAuMzU7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc2NhbGVPYmoub2JqZWN0LnNjYWxlLnggPSBzY2FsZU9iai5jYWNoZS54O1xyXG4gICAgICAgIHNjYWxlT2JqLm9iamVjdC5zY2FsZS55ID0gc2NhbGVPYmouY2FjaGUueTtcclxuICAgICAgICBkZWxldGUgdGhpcy5fb3ZlclNjYWxlc1tzXTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbi8vIERyYXcgVHJpYW5nbGVzIFBvbHlmaWxsIGZvciBiYWNrIGNvbXBhdGliaWxpdHlcclxuaWYoIVBoYXNlci5HcmFwaGljcy5wcm90b3R5cGUuZHJhd1RyaWFuZ2xlKSB7XHJcbiAgUGhhc2VyLkdyYXBoaWNzLnByb3RvdHlwZS5kcmF3VHJpYW5nbGUgPSBmdW5jdGlvbihwb2ludHMsIGN1bGwpIHtcclxuICAgICAgdmFyIHRyaWFuZ2xlID0gbmV3IFBoYXNlci5Qb2x5Z29uKHBvaW50cyk7XHJcbiAgICAgIGlmIChjdWxsKSB7XHJcbiAgICAgICAgICB2YXIgY2FtZXJhVG9GYWNlID0gbmV3IFBoYXNlci5Qb2ludCh0aGlzLmdhbWUuY2FtZXJhLnggLSBwb2ludHNbMF0ueCwgdGhpcy5nYW1lLmNhbWVyYS55IC0gcG9pbnRzWzBdLnkpO1xyXG4gICAgICAgICAgdmFyIGFiID0gbmV3IFBoYXNlci5Qb2ludChwb2ludHNbMV0ueCAtIHBvaW50c1swXS54LCBwb2ludHNbMV0ueSAtIHBvaW50c1swXS55KTtcclxuICAgICAgICAgIHZhciBjYiA9IG5ldyBQaGFzZXIuUG9pbnQocG9pbnRzWzFdLnggLSBwb2ludHNbMl0ueCwgcG9pbnRzWzFdLnkgLSBwb2ludHNbMl0ueSk7XHJcbiAgICAgICAgICB2YXIgZmFjZU5vcm1hbCA9IGNiLmNyb3NzKGFiKTtcclxuICAgICAgICAgIGlmIChjYW1lcmFUb0ZhY2UuZG90KGZhY2VOb3JtYWwpID4gMCkge1xyXG4gICAgICAgICAgICAgIHRoaXMuZHJhd1BvbHlnb24odHJpYW5nbGUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhpcy5kcmF3UG9seWdvbih0cmlhbmdsZSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuO1xyXG4gIH07XHJcbn0iLCJ2YXIgQm9vdCA9IGZ1bmN0aW9uICgpIHt9O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCb290O1xyXG5cclxuQm9vdC5wcm90b3R5cGUgPSB7XHJcblxyXG4gIHByZWxvYWQ6IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMubG9hZC5pbWFnZSgncHJlbG9hZGVyJywgJ2Fzc2V0cy9wcmVsb2FkZXIuZ2lmJyk7XHJcbiAgfSxcclxuXHJcbiAgY3JlYXRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLmdhbWUuaW5wdXQubWF4UG9pbnRlcnMgPSAxO1xyXG5cclxuICAgIGlmICh0aGlzLmdhbWUuZGV2aWNlLmRlc2t0b3ApIHtcclxuICAgICAgdGhpcy5nYW1lLnN0YWdlLnNjYWxlLnBhZ2VBbGlnbkhvcml6b250YWxseSA9IHRydWU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLmdhbWUuc2NhbGUuc2NhbGVNb2RlID0gUGhhc2VyLlNjYWxlTWFuYWdlci5TSE9XX0FMTDtcclxuICAgICAgdGhpcy5nYW1lLnNjYWxlLm1pbldpZHRoID0gIDQ4MDtcclxuICAgICAgdGhpcy5nYW1lLnNjYWxlLm1pbkhlaWdodCA9IDI2MDtcclxuICAgICAgdGhpcy5nYW1lLnNjYWxlLm1heFdpZHRoID0gNjQwO1xyXG4gICAgICB0aGlzLmdhbWUuc2NhbGUubWF4SGVpZ2h0ID0gNDgwO1xyXG4gICAgICB0aGlzLmdhbWUuc2NhbGUuZm9yY2VMYW5kc2NhcGUgPSB0cnVlO1xyXG4gICAgICB0aGlzLmdhbWUuc2NhbGUucGFnZUFsaWduSG9yaXpvbnRhbGx5ID0gdHJ1ZTtcclxuICAgICAgdGhpcy5nYW1lLnNjYWxlLnNldFNjcmVlblNpemUodHJ1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5nYW1lLnN0YXRlLnN0YXJ0KCdQcmVsb2FkZXInKTtcclxuICB9XHJcbn07XHJcbiIsIi8qXHJcbk1haW4gdGVzdGluZyBlbnZpcm9ubWVudC5cclxuKi9cclxuXHJcbnZhciBSZW5kZXJhYmxlcyA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9uQWNjZXNzL1JlbmRlcmFibGVzJyk7XHJcbnZhciBVSUJ1aWxkZXIgPSByZXF1aXJlKCcuLi91aS9VSUJ1aWxkZXInKTtcclxudmFyIEN1YmUgPSByZXF1aXJlKCcuLi9lbnRpdGllcy9jdWJlJyk7XHJcbnZhciBNb2R1bGVCdWlsZGVyID0gcmVxdWlyZSgnLi4vZW50aXRpZXMvTW9kdWxlQnVpbGRlcicpO1xyXG52YXIgVXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xyXG52YXIgQ3ViZUdyb3VwID0gcmVxdWlyZSgnLi4vZW50aXRpZXMvY3ViZV9ncm91cCcpO1xyXG52YXIgSGFja2FibGUgPSByZXF1aXJlKCcuLi9lbnRpdGllcy9IYWNrYWJsZScpO1xyXG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJy4uL2VmZmVjdHMvRW1pdHRlcicpO1xyXG52YXIgbW91c2VCb2R5OyAvLyBwaHlzaWNzIGJvZHkgZm9yIG1vdXNlXHJcbnZhciBNb3VzZSA9IHJlcXVpcmUoJy4uL2VudGl0aWVzL21vdXNlJyk7XHJcbnZhciBKdWljeSA9IHJlcXVpcmUoJy4uL3BsdWdpbnMvSnVpY3knKTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXHJcblxyXG52YXIgYmcsIGJnMjtcclxudmFyIG51bVJvaWRzID0gMDtcclxudmFyIG1heFJvaWRzID0gNTA7XHJcbnZhciBhc3Rlcm9pZHMsIGFzdGVyb2lkTGlzdDtcclxudmFyIGxlZnRLZXksIHJpZ2h0S2V5LCBjd0tleSwgY2N3S2V5O1xyXG52YXIgYXN0ZXJvaWRDRywgY3ViZUNHO1xyXG5cclxudmFyIEdhbWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdGhpcy50ZXN0ZW50aXR5ID0gbnVsbDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2FtZTtcclxuXHJcbkdhbWUucHJvdG90eXBlID0ge1xyXG5cdFxyXG4gIGNyZWF0ZTogZnVuY3Rpb24gKCkge1xyXG5cdHRoaXMuZ2FtZS53b3JsZC5zZXRCb3VuZHMoMCwgMCwgODAwMCwgNDAwMCk7XHJcblx0XHJcblx0Ly9DcmVhdGUgdGhlIHR3byBiYWNrZ3JvdW5kIGltYWdlc1xyXG4gICAgYmcgPSB0aGlzLmdhbWUuYWRkLnNwcml0ZSgwLCAwLCAnZWFydGhOaWdodCcpO1xyXG5cdGJnMiA9IHRoaXMuZ2FtZS5hZGQuc3ByaXRlKC04MDAwLCAwLCAnZWFydGhOaWdodCcpO1xyXG5cdFxyXG5cdHRoaXMuZ2FtZS5waHlzaWNzLnN0YXJ0U3lzdGVtKFBoYXNlci5QaHlzaWNzLlAySlMpO1xyXG4gICB0aGlzLmdhbWUucGh5c2ljcy5wMi5zZXRJbXBhY3RFdmVudHModHJ1ZSk7XHJcbiAgICBcclxuXHRjdWJlQ0cgPSB0aGlzLmdhbWUucGh5c2ljcy5wMi5jcmVhdGVDb2xsaXNpb25Hcm91cCgpO1xyXG5cdGFzdGVyb2lkQ0cgPSB0aGlzLmdhbWUucGh5c2ljcy5wMi5jcmVhdGVDb2xsaXNpb25Hcm91cCgpO1xyXG5cdFxyXG4gICB0aGlzLm1vdXNlID0gbmV3IE1vdXNlKHRoaXMuZ2FtZSwgdGhpcy5pbnB1dCk7XHJcbiAgIFxyXG4gICB0aGlzLnVwZGF0ZURlcGVuZGVudHMgPSBbXTtcclxuXHJcblx0Ly9jcmVhdGUgUmVuZGVyYWJsZXMgY2xhc3NcclxuXHR0aGlzLnJlbmRlcmFibGVzID0gbmV3IFJlbmRlcmFibGVzKCk7XHJcblx0Ly9jcmVhdGUgdGhlIFVJQnVpbGRlclxyXG5cdHRoaXMudWlCdWlsZGVyID0gbmV3IFVJQnVpbGRlcih0aGlzLCB0aGlzLnJlbmRlcmFibGVzKTsgICBcclxuXHQvL2NyZWF0ZSBNb2R1bGVCdWlsZGVyIGFuZCBzdG9yZSBpdCBpbiB0aGlzIGdhbWUgc3RhdGUgb2JqZWN0XHJcblx0dGhpcy5tb2R1bGVCdWlsZGVyID0gbmV3IE1vZHVsZUJ1aWxkZXIodGhpcyk7XHJcblx0Ly9jcmVhdGUgYW5kIHN0b3JlIHRoZSBjb3JlIG1vZHVsZVxyXG5cdHRoaXMuY29yZU1vZHVsZSA9IHRoaXMubW9kdWxlQnVpbGRlci5idWlsZCgnY29yZScsIDEyMDAsIDEyMDAsIHRydWUpO1xyXG5cdHRoaXMuY3ViZVdpZHRoID0gdGhpcy5jb3JlTW9kdWxlLmN1YmUud2lkdGg7XHJcblx0dGhpcy5jb3JlTW9kdWxlLmN1YmUuYm9keS5zZXRDb2xsaXNpb25Hcm91cChjdWJlQ0cpO1xyXG5cdHRoaXMuY29yZU1vZHVsZS5jdWJlLmJvZHkuY29sbGlkZXMoW2N1YmVDRywgYXN0ZXJvaWRDR10pO1xyXG5cdHRoaXMuY3ViZUJ1ZmZlciA9IDI7XHJcblx0dmFyIHBsYXllckdyb3VwID0gbmV3IEN1YmVHcm91cCh0aGlzLCB0aGlzLmNvcmVNb2R1bGUuY3ViZSk7XHJcblx0dGhpcy51cGRhdGVEZXBlbmRlbnRzLnB1c2gocGxheWVyR3JvdXApO1xyXG5cdHRoaXMucGxheWVyID0gcGxheWVyR3JvdXA7XHJcblx0dGhpcy5wbGF5ZXIuaXNQbGF5ZXIgPSB0cnVlO1xyXG5cclxuXHQvL0NyZWF0ZSB0aGUgZW1pdHRlciBmb3IgdGhlIGJpbmFyeSBwYXJ0aWNsZSBlZmZlY3RzXHJcblx0dGhpcy5CaW5hcnlFbWl0dGVyID0gbmV3IEVtaXR0ZXIodGhpcyk7XHJcblx0XHJcblx0Ly90ZXN0IGhhY2thYmxlIG9iamVjdFxyXG5cdHRoaXMudGVzdEhhY2sgPSBuZXcgSGFja2FibGUodGhpcywgMTYwMCwxMjAwLCAnaGFja2FibGUxJywgNDAwKTtcclxuXHJcblx0XHJcblx0dGhpcy5zcGFjZUtleSA9IHRoaXMuZ2FtZS5pbnB1dC5rZXlib2FyZC5hZGRLZXkoUGhhc2VyLktleWJvYXJkLlNQQUNFQkFSKTtcclxuXHR0aGlzLmdhbWUuaW5wdXQua2V5Ym9hcmQuYWRkS2V5Q2FwdHVyZShbdGhpcy5zcGFjZUtleV0pO1xyXG5cclxuXHRcclxuXHRhc3Rlcm9pZHMgPSB0aGlzLmdhbWUuYWRkLmdyb3VwKCk7XHJcblx0YXN0ZXJvaWRzLmVuYWJsZUJvZHkgPSB0cnVlO1xyXG5cdGFzdGVyb2lkcy5waHlzaWNzQm9keVR5cGUgPSBQaGFzZXIuUGh5c2ljcy5QMkpTO1xyXG5cdGFzdGVyb2lkTGlzdCA9IG5ldyBQaGFzZXIuQXJyYXlTZXQoKTtcclxuXHR0aGlzLmdlbmVyYXRlQXN0ZXJvaWRzKCk7XHJcblx0XHJcblx0bGVmdEtleSA9IHRoaXMuZ2FtZS5pbnB1dC5rZXlib2FyZC5hZGRLZXkoUGhhc2VyLktleWJvYXJkLkEpO1xyXG5cdHJpZ2h0S2V5ID0gdGhpcy5nYW1lLmlucHV0LmtleWJvYXJkLmFkZEtleShQaGFzZXIuS2V5Ym9hcmQuRCk7XHJcblx0Y2N3S2V5ID0gdGhpcy5nYW1lLmlucHV0LmtleWJvYXJkLmFkZEtleShQaGFzZXIuS2V5Ym9hcmQuUSk7XHJcblx0Y3dLZXkgPSB0aGlzLmdhbWUuaW5wdXQua2V5Ym9hcmQuYWRkS2V5KFBoYXNlci5LZXlib2FyZC5FKTtcclxuXHRcclxuXHQvL0RFQlVHR0lORyBMSVNURU5FUlMtIGFsbG93IHlvdSB0byBjcmVhdGUgbW9kdWxlcyBieSBwcmVzc2luZyBrZXlzXHJcblx0Ly9jb3JlXHJcblx0dGhpcy5wbGFjZUNvcmVLZXkgPSB0aGlzLmdhbWUuaW5wdXQua2V5Ym9hcmQuYWRkS2V5KFBoYXNlci5LZXlib2FyZC5QKTtcclxuXHR0aGlzLnBsYWNlQ29yZUtleS5vbkRvd24uYWRkKHRoaXMuYWRkQ29yZSwgdGhpcyk7XHJcblx0Ly9zaGllbGRcclxuXHR0aGlzLnBsYWNlU2hpZWxkS2V5ID0gdGhpcy5nYW1lLmlucHV0LmtleWJvYXJkLmFkZEtleShQaGFzZXIuS2V5Ym9hcmQuTyk7XHJcbiAgICB0aGlzLnBsYWNlU2hpZWxkS2V5Lm9uRG93bi5hZGQodGhpcy5hZGRTaGllbGQsIHRoaXMpO1xyXG5cdC8vdGhydXN0ZXJcclxuXHR0aGlzLnBsYWNlVGhydXN0ZXJLZXkgPSB0aGlzLmdhbWUuaW5wdXQua2V5Ym9hcmQuYWRkS2V5KFBoYXNlci5LZXlib2FyZC5JKTtcclxuICAgIHRoaXMucGxhY2VUaHJ1c3RlcktleS5vbkRvd24uYWRkKHRoaXMuYWRkVGhydXN0ZXIsIHRoaXMpO1xyXG5cdC8vc29sYXJQYW5lbFxyXG5cdHRoaXMucGxhY2VTUEtleSA9IHRoaXMuZ2FtZS5pbnB1dC5rZXlib2FyZC5hZGRLZXkoUGhhc2VyLktleWJvYXJkLlUpO1xyXG4gICAgdGhpcy5wbGFjZVNQS2V5Lm9uRG93bi5hZGQodGhpcy5hZGRTUCwgdGhpcyk7XHJcblx0Ly9oYWNrZXJcclxuXHR0aGlzLnBsYWNlSGFja0tleSA9IHRoaXMuZ2FtZS5pbnB1dC5rZXlib2FyZC5hZGRLZXkoUGhhc2VyLktleWJvYXJkLlkpO1xyXG5cdHRoaXMucGxhY2VIYWNrS2V5Lm9uRG93bi5hZGQodGhpcy5hZGRIYWNrLCB0aGlzKTtcclxuXHQvL2d1blxyXG5cdHRoaXMucGxhY2VHdW5LZXkgPSB0aGlzLmdhbWUuaW5wdXQua2V5Ym9hcmQuYWRkS2V5KFBoYXNlci5LZXlib2FyZC5UKTtcclxuICAgIHRoaXMucGxhY2VHdW5LZXkub25Eb3duLmFkZCh0aGlzLmFkZEd1biwgdGhpcyk7XHJcblx0Ly9FTkRcclxuICAgIFxyXG4gICAgLy8gRGVidWcgY29udHJvbGxlclxyXG4gICAgdGhpcy5kZWJ1Z0tleSA9IHRoaXMuZ2FtZS5pbnB1dC5rZXlib2FyZC5hZGRLZXkoUGhhc2VyLktleWJvYXJkLkgpO1xyXG4gICAgdGhpcy5kZWJ1Z0tleS5vbkRvd24uYWRkKHRoaXMuZGVidWcsIHRoaXMpO1xyXG4gICAgdGhpcy5yb290U3Bhd25lZCA9IGZhbHNlO1xyXG4gICAgXHJcbiAgICB0aGlzLmRlYnVnTnVtID0gMDtcclxuICAgIHRoaXMubXlSb290ID0gdW5kZWZpbmVkO1xyXG5cclxuXHQgdGhpcy5nYW1lLmNhbWVyYS5zZXRQb3NpdGlvbigxMDAwLCAxMDAwKTtcclxuICAgIFxyXG4gICAgdGhpcy5sZXZlbERhdGEgPSBKU09OLnBhcnNlKHRoaXMuZ2FtZS5jYWNoZS5nZXRUZXh0KCdsZXZlbF9vbmUnKSk7XHJcbiAgICAvL3RoaXMubG9hZERhdGEoKTtcclxuICAgIFxyXG4gICAgdGhpcy5qdWljeSA9IHRoaXMuZ2FtZS5wbHVnaW5zLmFkZChuZXcgUGhhc2VyLlBsdWdpbi5KdWljeSh0aGlzKSk7XHJcbiAgICB0aGlzLmdhbWUuY2FtZXJhLmZvbGxvdyh0aGlzLmNvcmVNb2R1bGUuY3ViZSk7XHJcbiAgfSxcclxuICBcclxuICBsb2FkRGF0YTogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHZhciBteUxldmVsID0gdGhpcy5sZXZlbERhdGFbJ2xldmVsX29uZSddO1xyXG4gICAgICBmb3IgKHZhciBrZXkgaW4gbXlMZXZlbCkge1xyXG4gICAgICAgICBpZiAobXlMZXZlbC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gbXlMZXZlbFtrZXldO1xyXG4gICAgICAgICAgICBpZiAoZWxlbWVudC5oYXNPd25Qcm9wZXJ0eSgnYmx1ZXByaW50JykpIHsgLy8gZW5lbXkgdHlwZVxyXG4gICAgICAgICAgICAgICB2YXIgZW5lbXlYID0gZWxlbWVudFsneF9wb3MnXTtcclxuICAgICAgICAgICAgICAgdmFyIGVuZW15WSA9IGVsZW1lbnRbJ3lfcG9zJ107XHJcbiAgICAgICAgICAgICAgIHZhciBlbmVteUdyb3VwID0gbmV3IEN1YmVHcm91cCh0aGlzLCB1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICAgICB0aGlzLnVwZGF0ZURlcGVuZGVudHMucHVzaChlbmVteUdyb3VwKTtcclxuICAgICAgICAgICAgICAgdmFyIGJsdWVwcmludCA9IGVsZW1lbnRbJ2JsdWVwcmludCddO1xyXG4gICAgICAgICAgICAgICAvLyB2YXIgcHJhY3RpY2FsID0gW107XHJcbiAgICAgICAgICAgICAgIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IGJsdWVwcmludC5sZW5ndGg7IHJvdysrKSB7XHJcbiAgICAgICAgICAgICAgICAgIC8vIHZhciBuZXdDb2wgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgY29sID0gMDsgY29sIDwgYmx1ZXByaW50W3Jvd10ubGVuZ3RoOyBjb2wrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IGJsdWVwcmludFtyb3ddW2NvbF07XHJcbiAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdNb2R1bGUgPSB0aGlzLm1vZHVsZUJ1aWxkZXIuYnVpbGQodHlwZSwgZW5lbXlYICsgcm93ICogKHRoaXMuY3ViZVdpZHRoICsgdGhpcy5jdWJlQnVmZmVyKSxcclxuICAgICAgICAgICAgICAgICAgICAgZW5lbXlZIC0gY29sICogKHRoaXMuY3ViZVdpZHRoICsgdGhpcy5jdWJlQnVmZmVyKSwgZmFsc2UpO1xyXG5cdFx0XHRcdFx0IG5ld01vZHVsZS5jdWJlLmJvZHkuc2V0Q29sbGlzaW9uR3JvdXAoY3ViZUNHKTtcclxuXHRcdFx0XHRcdCBuZXdNb2R1bGUuY3ViZS5ib2R5LmNvbGxpZGVzKFtjdWJlQ0csIGFzdGVyb2lkQ0ddKTtcclxuICAgICAgICAgICAgICAgICAgICAgLy8gbmV3Q29sLnB1c2gobmV3TW9kdWxlLmN1YmUpO1xyXG4gICAgICAgICAgICAgICAgICAgICB2YXIgcG9pbnQgPSBuZXcgUGhhc2VyLlBvaW50KHJvdywgY29sKTtcclxuICAgICAgICAgICAgICAgICAgICAgZW5lbXlHcm91cC5hZGQobmV3TW9kdWxlLmN1YmUsIHBvaW50KTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAvLyBwcmFjdGljYWwucHVzaChuZXdDb2wpO1xyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIC8vIFRPRE86IGdpdmUgZGlmZmVyZW50IHR5cGVzIGhlcmVcclxuICAgICAgICAgICAgICAgZW5lbXlHcm91cC5naXZlQUkoJ3JhbScsIHRoaXMucGxheWVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICB9XHJcbiAgICAgIH1cclxuICB9LFxyXG5cclxuICB1cGRhdGU6IGZ1bmN0aW9uICgpIHsgICAgXHJcblx0aWYobGVmdEtleS5pc0Rvd24pIHtcclxuXHRcdGlmKHRoaXMuY29yZU1vZHVsZS5jdWJlLmJvZHkuYW5ndWxhclZlbG9jaXR5ID4gLTkpIHsgXHJcblx0XHRcdHRoaXMuY29yZU1vZHVsZS5jdWJlLmJvZHkuYW5ndWxhckZvcmNlICs9IC01ICogTWF0aC5wb3codGhpcy5wbGF5ZXIubnVtQ3ViZXMsIDEuNjUpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRcclxuXHRpZihyaWdodEtleS5pc0Rvd24pIHtcclxuXHRcdGlmKHRoaXMuY29yZU1vZHVsZS5jdWJlLmJvZHkuYW5ndWxhclZlbG9jaXR5IDwgOSkge1xyXG5cdFx0XHR0aGlzLmNvcmVNb2R1bGUuY3ViZS5ib2R5LmFuZ3VsYXJGb3JjZSArPSA1ICogTWF0aC5wb3codGhpcy5wbGF5ZXIubnVtQ3ViZXMsIDEuNjUpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRcclxuXHRpZihjY3dLZXkuaXNEb3duKSB7XHJcblx0XHRpZih0aGlzLm1vdXNlLmdyYWJiZWQgIT09IHVuZGVmaW5lZCAmJiB0aGlzLm1vdXNlLmdyYWJiZWQuc3ByaXRlLmdyb3VwID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0dGhpcy5tb3VzZS5ncmFiYmVkLmFuZ3VsYXJGb3JjZSArPSAtNTtcclxuXHRcdH1cclxuXHR9XHJcblx0XHJcblx0aWYoY3dLZXkuaXNEb3duKSB7XHJcblx0XHRpZih0aGlzLm1vdXNlLmdyYWJiZWQgIT09IHVuZGVmaW5lZCAmJiB0aGlzLm1vdXNlLmdyYWJiZWQuc3ByaXRlLmdyb3VwID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0dGhpcy5tb3VzZS5ncmFiYmVkLmFuZ3VsYXJGb3JjZSArPSA1O1xyXG5cdFx0fVxyXG5cdH1cclxuXHRcclxuXHR0aGlzLm1vdXNlLnVwZGF0ZSgpO1xyXG5cdHRoaXMuc2Nyb2xsQkcoKTtcclxuICAgXHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnVwZGF0ZURlcGVuZGVudHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdGlmICh0aGlzLnVwZGF0ZURlcGVuZGVudHNbaV0udXBkYXRlKSB7XHJcblx0XHRcdHRoaXMudXBkYXRlRGVwZW5kZW50c1tpXS51cGRhdGUoKTtcclxuXHRcdH1cclxuXHR9XHJcbiAgfSxcclxuICBcclxuICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcclxuXHR0aGlzLm1vdXNlLnJlbmRlcigpO1xyXG5cdHRoaXMucmVuZGVyYWJsZXMucmVuZGVyQWxsKCk7XHJcbiAgfSxcclxuICBcclxuXHRzY3JvbGxCRzogZnVuY3Rpb24oKSB7XHJcblx0XHRiZy54ICs9IDAuMTI1O1xyXG5cdFx0aWYoYmcueCA+PSA4MDAwKSB7XHJcblx0XHRcdGJnLnggKz0gMDtcclxuXHRcdH1cclxuXHRcdGJnMi54ICs9IDAuMTI1O1xyXG5cdFx0aWYoYmcyLnggPj0gODAwMCkge1xyXG5cdFx0XHRiZzIueCA9IDA7XHJcblx0XHR9XHJcblx0fSxcclxuXHRcclxuXHRnZW5lcmF0ZUFzdGVyb2lkczogZnVuY3Rpb24oKSB7XHJcblx0XHRmb3IoO251bVJvaWRzIDwgbWF4Um9pZHM7IG51bVJvaWRzKyspIHtcclxuXHRcdFx0dmFyIGNvaW5BID0gdGhpcy5nYW1lLnJuZC5pbnRlZ2VySW5SYW5nZSgwLDEpO1xyXG5cdFx0XHR2YXIgY29pbkIgPSB0aGlzLmdhbWUucm5kLmludGVnZXJJblJhbmdlKDAsMSk7XHJcblx0XHRcdHZhciBhc3Rlcm9pZDtcclxuXHRcdFx0aWYoY29pbkEgPT09IDEpIHtcclxuXHRcdFx0XHRpZihjb2luQiA9PT0gMSkgeyAvL1NwYXduIGFzdGVyb2lkIGFib3ZlIHNjcmVlblxyXG5cdFx0XHRcdFx0YXN0ZXJvaWQgPSBhc3Rlcm9pZHMuY3JlYXRlKHRoaXMuY29yZU1vZHVsZS5jdWJlLnggKyB0aGlzLmdhbWUucm5kLmludGVnZXJJblJhbmdlKC10aGlzLmdhbWUuY2FtZXJhLndpZHRoLzIsIHRoaXMuZ2FtZS5jYW1lcmEud2lkdGgvMiksIHRoaXMuY29yZU1vZHVsZS5jdWJlLnkgLSB0aGlzLmdhbWUuY2FtZXJhLmhlaWdodC8yIC0gdGhpcy5nYW1lLnJuZC5pbnRlZ2VySW5SYW5nZSgzMiwgMzAwKSwgJ2FzdGVyb2lkJyk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2UgeyAvL1NwYXduIGFzdGVyb2lkIGJlbG93IHNjcmVlblxyXG5cdFx0XHRcdFx0YXN0ZXJvaWQgPSBhc3Rlcm9pZHMuY3JlYXRlKHRoaXMuY29yZU1vZHVsZS5jdWJlLnggKyB0aGlzLmdhbWUucm5kLmludGVnZXJJblJhbmdlKC10aGlzLmdhbWUuY2FtZXJhLndpZHRoLzIsIHRoaXMuZ2FtZS5jYW1lcmEud2lkdGgvMiksIHRoaXMuY29yZU1vZHVsZS5jdWJlLnkgKyB0aGlzLmdhbWUuY2FtZXJhLmhlaWdodC8yICsgdGhpcy5nYW1lLnJuZC5pbnRlZ2VySW5SYW5nZSgzMiwgMzAwKSwgJ2FzdGVyb2lkJyk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdGlmKGNvaW5CID09PSAxKSB7IC8vU3Bhd24gYXN0ZXJvaWQgdG8gbGVmdCBvZiBzY3JlZW5cclxuXHRcdFx0XHRcdGFzdGVyb2lkID0gYXN0ZXJvaWRzLmNyZWF0ZSh0aGlzLmNvcmVNb2R1bGUuY3ViZS54IC0gdGhpcy5nYW1lLmNhbWVyYS53aWR0aC8yIC0gdGhpcy5nYW1lLnJuZC5pbnRlZ2VySW5SYW5nZSgzMiwgMzAwKSwgdGhpcy5jb3JlTW9kdWxlLmN1YmUueSArIHRoaXMuZ2FtZS5ybmQuaW50ZWdlckluUmFuZ2UoLXRoaXMuZ2FtZS5jYW1lcmEuaGVpZ2h0LzIsIHRoaXMuZ2FtZS5jYW1lcmEuaGVpZ2h0LzIpLCAnYXN0ZXJvaWQnKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZSB7IC8vU3Bhd24gYXN0ZXJvaWQgdG8gcmlnaHRcclxuXHRcdFx0XHRcdGFzdGVyb2lkID0gYXN0ZXJvaWRzLmNyZWF0ZSh0aGlzLmNvcmVNb2R1bGUuY3ViZS54ICsgdGhpcy5nYW1lLmNhbWVyYS53aWR0aC8yICsgdGhpcy5nYW1lLnJuZC5pbnRlZ2VySW5SYW5nZSgzMiwgMzAwKSwgdGhpcy5jb3JlTW9kdWxlLmN1YmUueSArIHRoaXMuZ2FtZS5ybmQuaW50ZWdlckluUmFuZ2UoLXRoaXMuZ2FtZS5jYW1lcmEuaGVpZ2h0LzIsIHRoaXMuZ2FtZS5jYW1lcmEuaGVpZ2h0LzIpLCAnYXN0ZXJvaWQnKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0XHJcblx0XHRcdGFzdGVyb2lkLmJvZHkuc2V0Q2lyY2xlKDE2KTsgLy9DaGFuZ2UgdGhlIGNvbGxpc2lvbiBkZXRlY3Rpb24gZnJvbSBhbiBBQUJCIHRvIGEgY2lyY2xlXHJcblx0XHRcdGFzdGVyb2lkLmJvZHkuYW5ndWxhckRhbXBpbmcgPSAwO1xyXG5cdFx0XHRhc3Rlcm9pZC5ib2R5LmRhbXBpbmcgPSAwO1xyXG5cdFx0XHRhc3Rlcm9pZC5ib2R5LnJvdGF0aW9uID0gdGhpcy5nYW1lLnJuZC5yZWFsSW5SYW5nZSgwLCAyICogMy4xNCk7XHJcblx0XHRcdGFzdGVyb2lkLmJvZHkuZm9yY2UueCA9IHRoaXMuZ2FtZS5ybmQuaW50ZWdlckluUmFuZ2UoLTEwLCAxMCkgKiA3NTA7XHJcblx0XHRcdGFzdGVyb2lkLmJvZHkuZm9yY2UueSA9IHRoaXMuZ2FtZS5ybmQuaW50ZWdlckluUmFuZ2UoLTEwLCAxMCkgKiA3NTA7XHJcblx0XHRcdGFzdGVyb2lkLmJvZHkuc2V0Q29sbGlzaW9uR3JvdXAoYXN0ZXJvaWRDRyk7XHJcblx0XHRcdGFzdGVyb2lkLmJvZHkuY29sbGlkZXMoW2FzdGVyb2lkQ0csIGN1YmVDR10pO1xyXG5cdFx0XHRhc3Rlcm9pZC5ib2R5LmNvbGxpZGVXb3JsZEJvdW5kcyA9IGZhbHNlO1xyXG5cdFx0XHRhc3Rlcm9pZC5hdXRvQ3VsbCA9IHRydWU7XHJcblx0XHRcdGFzdGVyb2lkLmNoZWNrV29ybGRCb3VuZHMgPSB0cnVlO1xyXG5cdFx0XHRhc3Rlcm9pZC5ldmVudHMub25PdXRPZkJvdW5kcy5hZGQodGhpcy5yZXNldEFzdGVyb2lkLCBhc3Rlcm9pZCk7XHJcblx0XHRcdGFzdGVyb2lkTGlzdC5hZGQoYXN0ZXJvaWQpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblx0XHJcblx0cmVzZXRBc3Rlcm9pZDogZnVuY3Rpb24oKSB7IC8vTmVlZHMgdG8gYmUgdXBkYXRlZCBvbmNlIGNvbGxpc2lvbiBncm91cHMgYXJlIHdvcmtpbmdcclxuXHRcdC8vdGhpcy5vYmoueCA9IDEwO1xyXG5cdFx0Ly90aGlzLm9iai55ID0gMTA7XHJcblx0fSxcclxuXHRcclxuICAvL0RFQlVHIEZVTkNUSU9OUy0gZXZlbnQgZnVuY3Rpb25zIGNhbGxlZCBmcm9tIGxpc3RlbmVycyB0aGF0IGFsbG93IHlvdSB0byBjcmVhdGUgbW9kdWxlcyB3aXRoIGtleSBwcmVzc2VzXHJcbiAgYWRkQ29yZTogZnVuY3Rpb24gKCkgeyBcclxuXHQvL0F0dGVtcHRzIHRvIGNyZWF0ZSBtb3JlIGNvcmUgbW9kdWxlcyBoZXJlIHdpbGwgb25seSByZXR1cm4gdGhlIGV4aXN0aW5nIGNvcmVcclxuXHR2YXIgbmV3TW9kdWxlID0gdGhpcy5tb2R1bGVCdWlsZGVyLmJ1aWxkKCdjb3JlJywgdGhpcy5tb3VzZS54LCB0aGlzLm1vdXNlLnksIHRydWUpO1xyXG5cdG5ld01vZHVsZS5jdWJlLmJvZHkuc2V0Q29sbGlzaW9uR3JvdXAoY3ViZUNHKTtcclxuXHRuZXdNb2R1bGUuY3ViZS5ib2R5LmNvbGxpZGVzKFtjdWJlQ0csIGFzdGVyb2lkQ0ddKTtcclxuICB9LFxyXG4gIGFkZFNoaWVsZDogZnVuY3Rpb24gKCkge1xyXG5cdHZhciBuZXdNb2R1bGUgPSB0aGlzLm1vZHVsZUJ1aWxkZXIuYnVpbGQoJ3NoaWVsZCcsIHRoaXMubW91c2UueCwgdGhpcy5tb3VzZS55LCB0cnVlKTtcclxuXHRuZXdNb2R1bGUuY3ViZS5ib2R5LnNldENvbGxpc2lvbkdyb3VwKGN1YmVDRyk7XHJcblx0bmV3TW9kdWxlLmN1YmUuYm9keS5jb2xsaWRlcyhbY3ViZUNHLCBhc3Rlcm9pZENHXSk7XHJcbiAgfSxcclxuICBhZGRUaHJ1c3RlcjogZnVuY3Rpb24gKCkge1xyXG5cdHZhciBuZXdNb2R1bGUgPSB0aGlzLm1vZHVsZUJ1aWxkZXIuYnVpbGQoJ3RocnVzdGVyJywgdGhpcy5tb3VzZS54LCB0aGlzLm1vdXNlLnksIHRydWUpO1xyXG5cdG5ld01vZHVsZS5jdWJlLmJvZHkuc2V0Q29sbGlzaW9uR3JvdXAoY3ViZUNHKTtcclxuXHRuZXdNb2R1bGUuY3ViZS5ib2R5LmNvbGxpZGVzKFtjdWJlQ0csIGFzdGVyb2lkQ0ddKTtcclxuICB9LFxyXG4gIGFkZFNQOiBmdW5jdGlvbiAoKSB7XHJcblx0dmFyIG5ld01vZHVsZSA9IHRoaXMubW9kdWxlQnVpbGRlci5idWlsZCgnc29sYXJQYW5lbCcsIHRoaXMubW91c2UueCwgdGhpcy5tb3VzZS55LCB0cnVlKTtcclxuXHRuZXdNb2R1bGUuY3ViZS5ib2R5LnNldENvbGxpc2lvbkdyb3VwKGN1YmVDRyk7XHJcblx0bmV3TW9kdWxlLmN1YmUuYm9keS5jb2xsaWRlcyhbY3ViZUNHLCBhc3Rlcm9pZENHXSk7XHJcbiAgfSxcclxuICBhZGRIYWNrOiBmdW5jdGlvbiAoKSB7XHJcblx0dmFyIG5ld01vZHVsZSA9IHRoaXMubW9kdWxlQnVpbGRlci5idWlsZCgnaGFja2VyJywgdGhpcy5tb3VzZS54LCB0aGlzLm1vdXNlLnksIHRydWUpO1xyXG5cdG5ld01vZHVsZS5jdWJlLmJvZHkuc2V0Q29sbGlzaW9uR3JvdXAoY3ViZUNHKTtcclxuXHRuZXdNb2R1bGUuY3ViZS5ib2R5LmNvbGxpZGVzKFtjdWJlQ0csIGFzdGVyb2lkQ0ddKTtcclxuICB9LFxyXG4gIGFkZEd1bjogZnVuY3Rpb24gKCkge1xyXG5cdHZhciBuZXdNb2R1bGUgPSB0aGlzLm1vZHVsZUJ1aWxkZXIuYnVpbGQoJ2d1bicsIHRoaXMubW91c2UueCwgdGhpcy5tb3VzZS55LCB0cnVlKTtcclxuXHRuZXdNb2R1bGUuY3ViZS5ib2R5LnNldENvbGxpc2lvbkdyb3VwKGN1YmVDRyk7XHJcblx0bmV3TW9kdWxlLmN1YmUuYm9keS5jb2xsaWRlcyhbY3ViZUNHLCBhc3Rlcm9pZENHXSk7XHJcbiAgfSxcclxuXHJcbiAgZGVidWc6IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMuanVpY3kuc2hha2UoKTtcclxuICB9XHJcbn07XHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbiIsInZhciBNZW51ID0gZnVuY3Rpb24gKCkge1xyXG4gIHRoaXMudGV4dCA9IG51bGw7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE1lbnU7XHJcblxyXG5NZW51LnByb3RvdHlwZSA9IHtcclxuXHJcbiAgY3JlYXRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgeCA9IHRoaXMuZ2FtZS53aWR0aCAvIDI7XHJcbiAgICB2YXIgeSA9IHRoaXMuZ2FtZS5oZWlnaHQgLyAyO1xyXG5cclxuICAgIHZhciBzdHlsZSA9IHsgZm9udDogJzY1cHggQXJpYWwnLCBmaWxsOiAnI2ZmZmZmZicsIGFsaWduOiAnY2VudGVyJyB9O1xyXG4gICAgdGhpcy50aXRsZSA9IHRoaXMuZ2FtZS5hZGQudGV4dCh0aGlzLmdhbWUud29ybGQuY2VudGVyWCwgdGhpcy5nYW1lLndvcmxkLmNlbnRlclkgLSAyNTAsICdBYm92ZSBUaGUgSXJvbiBDdXJ0YWluJywgc3R5bGUpO1xyXG4gICAgdGhpcy5uZXdHYW1lID0gdGhpcy5nYW1lLmFkZC50ZXh0KHRoaXMuZ2FtZS53b3JsZC5jZW50ZXJYLCB0aGlzLmdhbWUud29ybGQuY2VudGVyWSAtIDE1MCwgJ05ldyBTaW11bGF0aW9uJywgc3R5bGUpO1xyXG4gICAgdGhpcy5sZXZlbCA9IHRoaXMuZ2FtZS5hZGQudGV4dCh0aGlzLmdhbWUud29ybGQuY2VudGVyWCwgdGhpcy5nYW1lLndvcmxkLmNlbnRlclkgLSA1MCwgJ01pc3Npb24gU2VsZWN0Jywgc3R5bGUpO1xyXG4gICAgdGhpcy5jb250cm9scyA9IHRoaXMuZ2FtZS5hZGQudGV4dCh0aGlzLmdhbWUud29ybGQuY2VudGVyWCwgdGhpcy5nYW1lLndvcmxkLmNlbnRlclkgKyA1MCwgJ01hbnVhbCcsIHN0eWxlKTtcclxuICAgIHRoaXMuY3JlZGl0cyA9IHRoaXMuZ2FtZS5hZGQudGV4dCh0aGlzLmdhbWUud29ybGQuY2VudGVyWCwgdGhpcy5nYW1lLndvcmxkLmNlbnRlclkgKyAxNTAsICdDcmVkaXRzJywgc3R5bGUpO1xyXG5cclxuICAgIHRoaXMuaW5wdXQub25Eb3duLmFkZCh0aGlzLm9uRG93biwgdGhpcyk7XHJcbiAgfSxcclxuXHJcbiAgdXBkYXRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgfSxcclxuXHJcbiAgb25Eb3duOiBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLmdhbWUuc3RhdGUuc3RhcnQocGxheWVyU3RhdGUuY3VycmVudExldmVsKTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXHJcbiAgfVxyXG59O1xyXG4iLCJ2YXIgUHJlbG9hZGVyID0gZnVuY3Rpb24gKGdhbWUpIHtcclxuICBnYW1lID0gbnVsbDtcclxuICB0aGlzLmFzc2V0ID0gbnVsbDtcclxuICB0aGlzLnJlYWR5ID0gZmFsc2U7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFByZWxvYWRlcjtcclxuXHJcblByZWxvYWRlci5wcm90b3R5cGUgPSB7XHJcblxyXG4gIHByZWxvYWQ6IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMuYXNzZXQgPSB0aGlzLmFkZC5zcHJpdGUoNjQwLCAzNjAsICdwcmVsb2FkZXInKTtcclxuICAgIHRoaXMuYXNzZXQuYW5jaG9yLnNldFRvKDAuNSwgMC41KTtcclxuXHJcbiAgICB0aGlzLmxvYWQub25Mb2FkQ29tcGxldGUuYWRkT25jZSh0aGlzLm9uTG9hZENvbXBsZXRlLCB0aGlzKTtcclxuICAgIHRoaXMubG9hZC5zZXRQcmVsb2FkU3ByaXRlKHRoaXMuYXNzZXQpO1xyXG4gICAgdGhpcy5sb2FkLmltYWdlKCd0ZXN0c3ByaXRlJywgJ2Fzc2V0cy90ZXN0Mi5wbmcnKTtcclxuXHR0aGlzLmxvYWQuc3ByaXRlc2hlZXQoJ2NvcmUnLCAnYXNzZXRzL2NvcmVTaGVldC5wbmcnLCA2NCwgNjQpOyBcclxuXHR0aGlzLmxvYWQuc3ByaXRlc2hlZXQoJ3RocnVzdGVyJywgJ2Fzc2V0cy90aHJ1c3RlclNoZWV0LnBuZycsIDY0LCA2NCk7XHJcblx0dGhpcy5sb2FkLnNwcml0ZXNoZWV0KCdndW4nLCAnYXNzZXRzL2d1blNoZWV0LnBuZycsIDY0LCA2NCk7XHJcblx0dGhpcy5sb2FkLmltYWdlKCdzaGllbGQnLCAnYXNzZXRzL3NoaWVsZC5wbmcnKTtcclxuXHR0aGlzLmxvYWQuaW1hZ2UoJ3NvbGFyUGFuZWwnLCAnYXNzZXRzL3NvbGFyUGFuZWwucG5nJyk7XHJcblx0dGhpcy5sb2FkLmltYWdlKCdoYWNrZXInLCAnYXNzZXRzL2hhY2tlci5wbmcnKTtcclxuXHR0aGlzLmxvYWQuc3ByaXRlc2hlZXQoJ2hhY2thYmxlMScsICdhc3NldHMvaGFja2FibGUxLnBuZycsIDI1NiwgMjU2KTtcclxuICAgIHRoaXMubG9hZC5hdGxhc0pTT05IYXNoKCdjb25uZWN0aW9ucycsICdhc3NldHMvY29ubmVjdGlvbnMucG5nJywgJ2Fzc2V0cy9jb25uZWN0aW9ucy5qc29uJyk7XHJcblx0dGhpcy5sb2FkLmltYWdlKCdhc3Rlcm9pZCcsICdhc3NldHMvYXN0ZXJvaWQucG5nJyk7XHJcbiAgICB0aGlzLmxvYWQuYXRsYXNKU09OSGFzaCgnY29ubmVjdGlvbnMnLCAnYXNzZXRzL2Nvbm5lY3Rpb25zLnBuZycsICdhc3NldHMvY29ubmVjdGlvbnMuanNvbicpO1xyXG5cdHRoaXMubG9hZC5pbWFnZSgnZWFydGhOaWdodCcsICdhc3NldHMvYmdfZWFydGhOaWdodFNtYWxsLmpwZycpO1xyXG4gICAgdGhpcy5sb2FkLnBoeXNpY3MoJ21vZHVsZV9waHlzaWNzJywgJ2Fzc2V0cy9tb2R1bGVfcGh5c2ljcy5qc29uJyk7XHJcbiAgICB0aGlzLmxvYWQudGV4dCgnbGV2ZWxfb25lJywgJ2Fzc2V0cy9sZXZlbF9vbmUuanNvbicpO1xyXG4gIH0sXHJcblxyXG4gIGNyZWF0ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy5hc3NldC5jcm9wRW5hYmxlZCA9IGZhbHNlO1xyXG4gIH0sXHJcblxyXG4gIHVwZGF0ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKCEhdGhpcy5yZWFkeSkge1xyXG4gICAgICAvL3RoaXMuZ2FtZS5zdGF0ZS5zdGFydCgnTWVudScpO1xyXG4gICAgICB0aGlzLmdhbWUuc3RhdGUuc3RhcnQocGxheWVyU3RhdGUuY3VycmVudExldmVsKTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgb25Mb2FkQ29tcGxldGU6IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMucmVhZHkgPSB0cnVlO1xyXG4gIH1cclxufTtcclxuIiwidmFyIFNwbGFzaCA9IGZ1bmN0aW9uICgpIHtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU3BsYXNoO1xyXG5cclxuU3BsYXNoLnByb3RvdHlwZSA9IHtcclxuICBjcmVhdGU6IGZ1bmN0aW9uICgpIHtcclxuICB9XHJcbn07IiwiLy9OT1RFOiBET04nVCBVU0UgdGhpcyBjb2RlIHRvIGNyZWF0ZSBhIFByb2dyZXNzQmFyLiBJbnN0ZWFkLCB1c2UgdGhlIFVJQnVpbGRlciBvYmplY3QgYW5kIGNhbGwgYnVpbGRQcm9ncmVzc0JhclxyXG5cclxudmFyIFByb2dyZXNzQmFyID0gZnVuY3Rpb24oc2V0VHlwZSwgc2V0TWF4VmFsdWUsIHNldEdyYXBoaWNzLCBzZXRSZW5kZXJhYmxlcykge1xyXG5cdHRoaXMudHlwZSA9IHNldFR5cGU7IC8vVHdvIHR5cGVzLCBcImdyb3dpbmdcIiAoc3RhcnRzIGF0IDAsIHRyaWdnZXJzIGV2ZW50IHdoZW4gZnVsbCkgXHJcblx0XHRcdFx0XHRcdCAvL2FuZCBcInNocmlua2luZ1wiIChzdGFydHMgZnVsbCwgdHJpZ2dlcnMgYXQgMClcclxuXHR0aGlzLnggPSBudWxsO1xyXG5cdHRoaXMueSA9IG51bGw7XHJcblx0dGhpcy53aWR0aCA9IG51bGw7XHJcblx0dGhpcy5oZWlnaHQgPSBudWxsO1xyXG5cdHRoaXMubWF4VmFsdWUgPSBzZXRNYXhWYWx1ZTtcclxuXHR0aGlzLmdyYXBoaWNzID0gc2V0R3JhcGhpY3M7IC8vc3RvcmUgZ3JhcGhpY3MgY2xhc3MgKHVzZWQgdG8gZHJhdyBiYXIpXHJcblx0dGhpcy5yZW5kZXJhYmxlcyA9IHNldFJlbmRlcmFibGVzO1xyXG5cdFxyXG5cdHRoaXMub25FdmVudCA9IGZ1bmN0aW9uKCkge307IC8vb3ZlcndyaXRlIHRoaXMgZnVuY3Rpb24gdG8gbWFrZSB3aGF0ZXZlciB5b3Ugd2FudCBoYXBwZW4gd2hlbiBwcm9ncmVzc0JhciByZWFjaGVzIGxpbWl0XHJcblx0XHJcblx0Ly9zd2l0Y2godGhpcy50eXBlKSB7XHJcblx0Ly9jYXNlICdncm93aW5nJyA6IFxyXG5cdGlmKHNldFR5cGUgPT0gJ2dyb3dpbmcnKSB7XHJcblx0XHR0aGlzLnZhbHVlID0gMDtcclxuXHRcdC8vdHJ5VHJpZ2dlciBpcyBjYWxsZWQgYXV0b21hdGljYWxseSB3aGVuIHlvdSBhZGQvc3VidHJhY3QgdmFsdWUsIGFuZCB3aWxsIHRyaWdnZXIgdGhlIG9uRXZlbnQoKSBmdW5jdGlvblxyXG5cdFx0dGhpcy50cnlUcmlnZ2VyID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdGlmKHRoaXMudmFsdWUgPj0gdGhpcy5tYXhWYWx1ZSkge1xyXG5cdFx0XHRcdHRoaXMub25FdmVudCgpO1xyXG5cdFx0XHR9XHJcblx0XHR9O1xyXG5cdFx0Ly9icmVhaztcclxuXHR9XHJcblx0ZWxzZSBpZihzZXRUeXBlID09ICdzaHJpbmtpbmcnKSB7XHJcblx0Ly9jYXNlICdzaHJpbmtpbmcnIDpcclxuXHRcdHRoaXMudmFsdWUgPSB0aGlzLm1heFZhbHVlO1xyXG5cdFx0dGhpcy50cnlUcmlnZ2VyID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdGlmKHRoaXMudmFsdWUgPD0gMCkge1xyXG5cdFx0XHRcdHRoaXMub25FdmVudCgpO1xyXG5cdFx0XHR9XHJcblx0XHR9O1xyXG5cdC8vfVxyXG5cdH1cclxufTtcclxuXHJcblByb2dyZXNzQmFyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFByb2dyZXNzQmFyO1xyXG5cclxuUHJvZ3Jlc3NCYXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcclxuXHR0aGlzLmdyYXBoaWNzLmNsZWFyKCk7XHJcblx0dGhpcy5yZW5kZXJhYmxlcy51bnN1YnNjcmliZSh0aGlzKTtcclxufTtcclxuXHJcbi8vVG8gc3VidHJhY3QgdmFsdWUsIGp1c3QgdXNlIG5lZ2F0aXZlIG51bWJlcnMgYXMgYXJndW1lbnQgaS5lLiBmb28uYWRkVmFsdWUoLTUpO1xyXG5Qcm9ncmVzc0Jhci5wcm90b3R5cGUuYWRkVmFsdWUgPSBmdW5jdGlvbiAoYWRkVGhpcykge1xyXG5cdHRoaXMudmFsdWUgKz0gYWRkVGhpcztcclxuXHRpZih0aGlzLnZhbHVlID4gdGhpcy5tYXhWYWx1ZSkge1xyXG5cdFx0dGhpcy52YWx1ZSA9IHRoaXMubWF4VmFsdWU7XHJcblx0fVxyXG5cdGlmKHRoaXMudmFsdWUgPCAwKSB7XHJcblx0XHR0aGlzLnZhbHVlID0gMDtcclxuXHR9XHJcblx0dGhpcy50cnlUcmlnZ2VyKCk7XHJcbn07XHJcblxyXG4vL1NldHMgdGhlIGxvY2F0aW9uIHdoZXJlIHByb2dyZXNzIGJhciBpcyByZW5kZXJlZFxyXG5Qcm9ncmVzc0Jhci5wcm90b3R5cGUuc2V0TG9jYXRpb24gPSBmdW5jdGlvbihzZXRYLCBzZXRZKSB7XHJcblx0dGhpcy54ID0gc2V0WDtcclxuXHR0aGlzLnkgPSBzZXRZO1xyXG59O1xyXG5cclxuLy9TZXRzIHRoZSBzaXplIG9mIHRoZSBwcm9ncmVzcyBiYXJcclxuUHJvZ3Jlc3NCYXIucHJvdG90eXBlLnNldFNpemUgPSBmdW5jdGlvbihzZXRXaWR0aCwgc2V0SGVpZ2h0KSB7XHJcblx0dGhpcy53aWR0aCA9IHNldFdpZHRoO1xyXG5cdHRoaXMuaGVpZ2h0ID0gc2V0SGVpZ2h0O1xyXG59O1xyXG5cclxuLy9SZW5kZXJzIHByb2dyZXNzQmFyXHJcblByb2dyZXNzQmFyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbigpIHtcclxuXHR0aGlzLmdyYXBoaWNzLmNsZWFyKCk7XHJcblx0Ly9EcmF3IGJhY2tncm91bmQgb2YgYmFyXHJcblx0dGhpcy5ncmFwaGljcy5saW5lU3R5bGUoMiwgMHhBQUFBQUEsIDEpO1xyXG5cdHRoaXMuZ3JhcGhpY3MuYmVnaW5GaWxsKDB4ODg4ODg4KTtcclxuXHR0aGlzLmdyYXBoaWNzLmRyYXdSZWN0KHRoaXMueC10aGlzLndpZHRoLzIsIHRoaXMueS10aGlzLmhlaWdodC8yLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XHJcblx0dGhpcy5ncmFwaGljcy5lbmRGaWxsKCk7XHJcblx0Ly9EcmF3IHZhbHVlIG9mIGJhclxyXG5cdHZhciBwZXJjZW50YWdlID0gdGhpcy52YWx1ZSAvIHRoaXMubWF4VmFsdWU7XHJcblx0dmFyIGJhcldpZHRoID0gdGhpcy53aWR0aCAtIDU7XHJcblx0dmFyIGJhckhlaWdodCA9IHRoaXMuaGVpZ2h0IC0gNTtcclxuXHR0aGlzLmdyYXBoaWNzLmxpbmVTdHlsZSgxLCAweDg4ODhGRiwgMSk7XHJcblx0dGhpcy5ncmFwaGljcy5iZWdpbkZpbGwoMHgwMDAwOTkpO1xyXG5cdHRoaXMuZ3JhcGhpY3MuZHJhd1JlY3QodGhpcy54LShiYXJXaWR0aC8yKSwgdGhpcy55LShiYXJIZWlnaHQvMiksIGJhcldpZHRoKnBlcmNlbnRhZ2UsIGJhckhlaWdodCk7XHJcblx0dGhpcy5ncmFwaGljcy5lbmRGaWxsKCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFByb2dyZXNzQmFyOyIsInZhciBQcm9ncmVzc0JhciA9IHJlcXVpcmUoJy4vUHJvZ3Jlc3NCYXInKTtcclxuXHJcbnZhciBVSUJ1aWxkZXIgPSBmdW5jdGlvbihzZXRHYW1lU3RhdGUsIHNldFJlbmRlcmFibGVzKSB7XHJcblx0Ly9FbnN1cmUgdGhhdCBjYW5ub3QgY3JlYXRlIG11bHRpcGxlIGluc3RhbmNlcyBvZiB0aGlzIGNsYXNzXHJcblx0aWYoVUlCdWlsZGVyLnByb3RvdHlwZS5leGlzdHMpIHtcclxuXHRcdHJldHVybiBVSUJ1aWxkZXIucHJvdG90eXBlLmV4aXN0aW5nUmVmZXJlbmNlO1xyXG5cdH1cclxuXHRcclxuXHR0aGlzLmdhbWVTdGF0ZSA9IHNldEdhbWVTdGF0ZTtcclxuXHR0aGlzLnJlbmRlcmFibGVzID0gc2V0UmVuZGVyYWJsZXM7XHJcblx0Ly9DcmVhdGUgYW5kIHN0b3JlIGEgZ3JhcGhpY3Mgb2JqZWN0ICh1c2VkIGZvciBzdHVmZiBsaWtlIGRyYXdpbmcgcmVjdGFuZ2xlcylcclxuXHRVSUJ1aWxkZXIucHJvdG90eXBlLmV4aXN0cyA9IHRydWU7XHJcblx0VUlCdWlsZGVyLnByb3RvdHlwZS5leGlzdGluZ1JlZmVyZW5jZSA9IHRoaXM7XHJcbn07XHJcblxyXG5VSUJ1aWxkZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVUlCdWlsZGVyO1xyXG4vL1RoZXNlIHZhcidzIGhlbHAgY3JlYXRlIHRoZSBzaW5nbGV0b24gZnVuY3Rpb25hbGl0eVxyXG5VSUJ1aWxkZXIucHJvdG90eXBlLmV4aXN0cyA9IGZhbHNlO1xyXG5VSUJ1aWxkZXIucHJvdG90eXBlLmV4aXN0aW5nUmVmZXJlbmNlID0gbnVsbDtcclxuXHJcbi8vVXNlIHRoaXMgZnVuY3Rpb24gdG8gY3JlYXRlIGEgcHJvZ3Jlc3MgYmFyXHJcbi8vVXNhZ2U6IHR5cGU6IGNhbiBiZSBcImdyb3dpbmdcIiBvciBcInNocmlua2luZ1wiLCB0aGlzIHdpbGwgZWZmZWN0IGlmIGJhciBzdGFydHMgYXQgMCBhbmQgZ29lcyB1cCBvciB2aXMgdmVyc2FcclxuLy9cdFx0IG1heFZhbHVlOiBzZXRzIHRoZSBtYXggdmFsdWUgb2YgdGhlIHByb2dyZXNzIGJhciwgaS5lLiB1c2luZyAxMDAgY3JlYXRlcyBhIGJhciBmcm9tIDAgdG8gMTAwXHJcbi8vXHRcdCB4LHk6IHNldHMgbG9jYXRpb25cclxuLy9cdFx0IERPTidUIEZPUkdFVCB0byBvdmVyd3JpdGUgdGhlIG9uRXZlbnQoKSBmdW5jdGlvbiBmb3IgdGhlIHByb2dyZXNzIGJhciBhZnRlciBjcmVhdGluZyBpdFxyXG4vL1x0XHRcdC1vbkV2ZW50KCkgaXMgYXV0b21hdGljYWxseSBjYWxsZWQgd2hlbiBiYXIgZmlsbHMvc2hyaW5rcyBwYXN0IGxpbWl0IChkZXBlbmRpbmcgb24gYmFyIHR5cGUpXHJcblVJQnVpbGRlci5wcm90b3R5cGUuYnVpbGRQcm9ncmVzc0JhciA9IGZ1bmN0aW9uKHR5cGUsIHgsIHksIHdpZHRoLCBoZWlnaHQsIG1heFZhbHVlKSB7XHJcblx0Ly9jcmVhdGUgYW5kIGZvcm1hdCBuZXcgcHJvZyBiYXJcclxuXHR2YXIgZ3JhcGhpY3MgPSB0aGlzLmdhbWVTdGF0ZS5nYW1lLmFkZC5ncmFwaGljcygwLDApO1xyXG5cdHZhciBuZXdQcm9nQmFyID0gbmV3IFByb2dyZXNzQmFyKHR5cGUsIG1heFZhbHVlLCBncmFwaGljcywgdGhpcy5yZW5kZXJhYmxlcyk7XHJcblx0bmV3UHJvZ0Jhci5zZXRMb2NhdGlvbih4LHkpO1xyXG5cdG5ld1Byb2dCYXIuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcclxuXHQvL3N1YnNjcmliZSB0byAncmVuZGVyYWJsZXMnIHNvIHRoYXQgcmVuZGVyKCkgaXMgY2FsbGVkIGF1dG9tYXRpY2FsbHlcclxuXHR0aGlzLnJlbmRlcmFibGVzLnN1YnNjcmliZShuZXdQcm9nQmFyKTtcclxuXHRyZXR1cm4gbmV3UHJvZ0JhcjtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVUlCdWlsZGVyOyIsIi8qXHJcbkNvbGxlY3Rpb24gb2YgdXRpbGl0eSBmdW5jdGlvbnMuXHJcbiovXHJcblxyXG52YXIgVXRpbHMgPSB7XHJcbiAgICBjb250YWluc09iamVjdDogZnVuY3Rpb24ob2JqLCBsaXN0KSB7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGxpc3RbaV0gPT09IG9iaikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH0sXHJcbiAgICBkaXN0YW5jZTogZnVuY3Rpb24oeDEsIHkxLCB4MiwgeTIpIHtcclxuICAgICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coeDEgLSB4MiwgMikgKyBNYXRoLnBvdyh5MSAtIHkyLCAyKSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFV0aWxzOyJdfQ==
