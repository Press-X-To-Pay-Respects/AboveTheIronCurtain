(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"./src/js/main.js":[function(require,module,exports){
'use strict';

var game = new Phaser.Game(window.innerWidth, window.innerHeigh, Phaser.AUTO, 'atic-game');

window.playerState = {
    currentLevel: 'Game'
};

game.state.add('Boot', require('./states/boot'));
game.state.add('Splash', require('./states/splash'));
game.state.add('Preloader', require('./states/preloader'));
game.state.add('Menu', require('./states/menu'));
game.state.add('Game', require('./states/game'));

game.state.start('Boot');
},{"./states/boot":"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\states\\boot.js","./states/game":"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\states\\game.js","./states/menu":"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\states\\menu.js","./states/preloader":"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\states\\preloader.js","./states/splash":"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\states\\splash.js"}],"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\effects\\BinaryParticle.js":[function(require,module,exports){
var BinaryParticle = function(game, targetObj, x, y, tarOffsetX, tarOffsetY) {
	var style = {font: '20px Avant Garde', fill: '#EEEE33', align: 'center'};
	var byteSymbol = Math.random() >= 0.5 ? '1' : '0';
	Phaser.Text.call(this, game, x, y, byteSymbol, style);
	game.add.existing(this);
	this.targetObj = targetObj;
	this.speed = 3.6;
	this.tarOffsetX = tarOffsetX;
	this.tarOffsetY = tarOffsetY;
	console.log('ran');
};

BinaryParticle.prototype = Object.create(Phaser.Text.prototype);
BinaryParticle.prototype.constructor = BinaryParticle;

BinaryParticle.prototype.update = function() {
	//Get delta vector to target object
	var delta = [this.targetObj.x + this.tarOffsetX - this.x, this.targetObj.y + this.tarOffsetY - this.y];
	//Get distance and check if we've reached target distance
	var dist = Math.sqrt(Math.pow(delta[0], 2) + Math.pow(delta[1], 2));
	if(dist <= this.speed) {
		this.destroy();
		return;
	}
	//Normalize delta vector
	delta = [delta[0]/dist, delta[1]/dist];
	//Update position
	this.x = this.x + this.speed*delta[0];
	this.y = this.y + this.speed*delta[1];
};

module.exports = BinaryParticle;
},{}],"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\effects\\Emitter.js":[function(require,module,exports){
var BinaryParticle = require('./BinaryParticle');

var Emitter = function(gameState) {
	this.gameState = gameState;
};

Emitter.prototype.constructor = Emitter;

Emitter.prototype.emitBinary = function (targetObj, x, y, spacing) {
	var offsetX = (Math.random()-0.5)*spacing;
	var offsetY = (Math.random()-0.5)*spacing;
	var newParticle = new BinaryParticle(this.gameState.game, targetObj, x, y, offsetX, offsetY);
};

module.exports = Emitter;
},{"./BinaryParticle":"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\effects\\BinaryParticle.js"}],"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\entities\\Hackable.js":[function(require,module,exports){
/*
Defines a hackable object.
*/

var Hackable = function (gameState, x, y, sprite, hackDistance) {
   Phaser.Sprite.call(this, gameState.game, x, y, sprite);
   gameState.game.add.existing(this);
	//store gameState
	this.gameState = gameState;
	//set isHacked to false
	this.isHacked = false;
	//add hackBar
	this.hackBar = gameState.uiBuilder.buildProgressBar('growing', 1500, 1200, 100, 10,  200);
	this.hackBar.setStyle(0, 0xFFFFFF, 0x363636, 0, 0, 0, 0xFFFFFF, 0x2020CC);
	this.hackBar.hackable = this;
	this.hackBar.onEvent = function() {
		this.hackable.frame = 1;
		this.hackable.isHacked = true;
		this.destroy();
	};
	this.tag = 'neutralObj';	//Tag is used to identify object type during collision checking
	this.hackDistance = hackDistance;
	var scale = 0.5;
   this.scale.x = scale;
   this.scale.y = scale;
   this.anchor.setTo(0.5, 0.5);
   gameState.game.physics.p2.enable(this);
   this.body.onBeginContact.add(this.cubeCollide, this);
   this.body.damping = 0.9;
   this.body.angularDamping = 0.9;
};

Hackable.prototype = Object.create(Phaser.Sprite.prototype);
Hackable.prototype.constructor = Hackable;

/**
 * Automatically called by World.update
 */
Hackable.prototype.update = function() {
	this.hackBar.setLocation(this.x, this.y - 70);
	//check if getting hacked
	if(!this.isHacked) {
		if(this.gameState.player.hackerModules.length > 0) {
			var dist;
			var hacker;
			//Loop through all hacker modules on the player's cubsat
			for(var i = 0; i < this.gameState.player.hackerModules.length; i++) {
				hacker = this.gameState.player.hackerModules[i];
				dist = Math.sqrt( Math.pow(this.x - hacker.cube.x, 2) + Math.pow(this.y - hacker.cube.y, 2) );
				if(dist < this.hackDistance) {
					//If hacker is in range, increase hack value and try to emit binary particle
					this.hackBar.addValue(0.05);
					hacker.count++;
					if(hacker.count >= hacker.cycle) {
						hacker.count = 0;
						this.gameState.BinaryEmitter.emitBinary(this, hacker.cube.x, hacker.cube.y, 60);
					}
				}
			}
		}
	}
};


Hackable.prototype.cubeCollide = function(other) {
/*   if (this.group === undefined) {
      return;
   }
   this.group.handleCollision(this, other.sprite);*/
};

module.exports = Hackable;
},{}],"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\entities\\Module.js":[function(require,module,exports){
//Don't use this function to create modules, instead use moduleBuilder()
var Module = function(setType, setCube) {
	this.type = setType;
	this.cube = setCube;
   setCube.module = this;
};

Module.prototype.constructor = Module;

module.exports = Module;
},{}],"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\entities\\ModuleBuilder.js":[function(require,module,exports){
var Cube = require('./cube');
var Module = require('./Module');

var thrustAmt = 5000;

//Use this to create a moduleBuilder- only need to create one instance of it
var ModuleBuilder = function(setGameState, setColGroup) {
	//Ensure that cannot create multiple instances of this class
	if(ModuleBuilder.prototype.exists) {
		return ModuleBuilder.prototype.existingReference;
	}
		
	this.gameState = setGameState;
   this.colGroup = setColGroup;
	// this.coreExists = false;	//records if core has been created
	this.core = null;			//stores core when it is created
	//var space = this.gameState.input.keyboard.addKey(Phaser.Keyboard.SPACEBAR);
	ModuleBuilder.prototype.exists = true;
	ModuleBuilder.prototype.existingReference = this;
};

ModuleBuilder.prototype.constructor = ModuleBuilder;

//These var's help create the singleton functionality
ModuleBuilder.prototype.exists = false;
ModuleBuilder.prototype.existingReference = null;

/** Module functions **/
function solarPanelGiveTarget(target) {
   if (this.cube.group && target.cube.group && this.cube.group !== target.cube.group || this === target) {
      return;
   }
   var ourGroup = this.cube.group;
   var newConnection = {start: this.cube, end: target.cube};
   this.cube.myConnection = newConnection;
   target.cube.myConnection = newConnection;
   ourGroup.displayConnection(this.cube.myConnection);
}

function solarPanelMouseOver() {
   if (!this.cube.myConnection || !this.cube.group) {
      return;
   }
   this.cube.group.displayConnection(this.cube.myConnection);
}

function solarPanelOnRemove() {
   if (!this.cube.myConnection || !this.cube.myConnection.end) {
      console.log('solarPanelOnRemove() had an error');
   }
   this.cube.myConnection.end.myConnection = undefined;
   this.cube.myConnection = undefined;
}

function beginAct() {
   this.act = true;
   this.cube.frame = 1;
}

function endAct() {
   this.act = false;
   this.cube.frame = 0;
}

function thrusterUpdate() {
   if (this.haltTime && this.haltTime > 0) {
      this.haltTime -= this.cube.game.time.elapsed;
      this.cube.frame = 0;
   } else if (this.act && this.cube.myConnection) {
      this.cube.body.force.x = thrustAmt * Math.cos(this.cube.rotation - Math.PI / 2);
      this.cube.body.force.y = thrustAmt * Math.sin(this.cube.rotation - Math.PI / 2);
	  if(this.cube.frame === 1) {
		this.cube.frame = 2;
	  }
	  else {
		this.cube.frame = 1;
	  }
   }
}

function thrusterHalt() {
   this.haltTime = 1500;
}

/** End module functions **/

//call this function from ModuleBuilder to construct modules
//TYPES: 'core' 'shield' 'thruster' 'solarPannel' 'hacker'
ModuleBuilder.prototype.build = function(type, x, y, forPlayer) {
	//Check if core has been created
	if(type === 'core' && this.coreExists) {
		//if so, return existing core b/c is singleton
		//b/c of this, can call ModuleBuilder.build('core') to access reference to existing core
		return this.core;
	}
	
	//Create cube object to be stored within module
	//Sprite names for modules are directly mapped to module names, so just pass 'type' as sprite name
	var newCube = new Cube(this.gameState, x, y, type);
    var scale = 0.5;
    newCube.name = this.gameState.debugNum++;
    newCube.scale.setTo(scale, scale);
    newCube.anchor.setTo(0.5, 0.5);
    this.gameState.game.physics.p2.enable(newCube);
    newCube.body.onBeginContact.add(newCube.cubeCollide, newCube);
	newCube.body.collideWorldBounds = false;
    newCube.body.damping = 0.9;
    newCube.body.angularDamping = 0.9;
    if (!this.gameState.rootSpawned) {
       newCube.root = true;
       this.gameState.rootSpawned = true;
    }

   var cIndicator = this.gameState.add.sprite(0, 0, 'connections', 'connection_line.png');
   cIndicator.anchor.setTo(0.5, 0.5);
   cIndicator.animations.add('end', ['connection_end.png'], 60, true);
   cIndicator.animations.add('line', ['connection_line.png'], 60, true);
   cIndicator.animations.add('right', ['connection_right.png'], 60, true);
   newCube.addChild(cIndicator);
   newCube.cIndicator = cIndicator;
   cIndicator.alpha = 0;
	
	//Create module to wrap around cube class
	var newModule = new Module(type, newCube);
		
	//TODO: edit special module atributes based on 'type'
	if(type === 'hacker') {
		newModule.cycle = 6;
		newModule.count = 0;
	}
	
	//Store module if it is core
	if(type === 'core')
	{
		newModule.cube.animations.add('core', [0,1,2], 20, true);
		newModule.cube.animations.play('core');
		this.core = newModule;
		this.coreExists = true;
	}
   // solar panel testing
   if (type === 'solarPanel') {
      newModule.giveTarget = solarPanelGiveTarget;
      newModule.mouseOver = solarPanelMouseOver;
      newModule.onRemove = solarPanelOnRemove;
   }
   
   //Thruster module events
	if(type === 'thruster') {
      if (forPlayer) {
         var space = this.gameState.input.keyboard.addKey(Phaser.Keyboard.SPACEBAR); 
         this.gameState.input.keyboard.addKeyCapture([space]);
         // space.onDown.add(applyThrust, newModule);
         space.onDown.add(beginAct, newModule);
         space.onUp.add(endAct, newModule);
      } else {
         // newModule.thrust = false;
         newModule.beginAct = beginAct;
         newModule.endAct = endAct;
      }
      newModule.update = thrusterUpdate;
      newModule.thrusterHalt = thrusterHalt;
	}
	//Return the module object
	return newModule;
};

module.exports = ModuleBuilder;
















},{"./Module":"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\entities\\Module.js","./cube":"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\entities\\cube.js"}],"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\entities\\cube.js":[function(require,module,exports){
/*
Defines a cube.
*/

var Cube = function (gameState, x, y, sprite) {
    Phaser.Sprite.call(this, gameState.game, x, y, sprite);
	 this.tag = 'module';	//tag is used to detect object type during collision checking
    this.game = gameState.game;
    this.game.add.existing(this);
    this.group = undefined;
    this.module = undefined;
    this.indicatorFade = 0.02;
    this.healthBar = gameState.uiBuilder.buildProgressBar('shrinking', 0, 0, 20, 4, 3);
	this.healthBar.setStyle(0, 0xFFFFFF, 0x363636, 0, 0, 0, 0xFFFFFF, 0x20CC20);
	this.healthBar.cube = this;
	//set update function of health bar
	this.healthBar.update = function() {
		this.setLocation(this.cube.x, this.cube.y+10);
	};
	//onEvent called when cube runs out of health
	this.healthBar.onEvent = function() {
		this.dying = true;
		this.life = 50;
		// this.group.countCubes();
		this.destroy();
	};
	this.constraints = [];
};

Cube.prototype = Object.create(Phaser.Sprite.prototype);
Cube.prototype.constructor = Cube;

/**
 * Automatically called by World.update
 */
Cube.prototype.update = function() {
   if (this.cIndicator && this.cIndicator.alpha > 0) {
      this.cIndicator.alpha -= this.indicatorFade;
   }
   if (this.module.update) {
      this.module.update();
   }
   if (this.dying) {
      this.life -= this.game.time.elapsed;
      if (this.life < 0) {
         this.dying = false;
         this.group.destroyCube(this);
      }
   }
};

Cube.prototype.cubeCollide = function(other) {
   if (!this.group || !other || !other.sprite || other.sprite.key === 'asteroid') {
      return;
   }
	this.group.handleCollision(this, other.sprite);
	this.group.countCubes();
};

Cube.prototype.toString = function() {
   var string = '';
   string += this.concat('name', this.name);
   return string;
};

Cube.prototype.concat = function(string, val) {
   return string + ': ' + val + '\n';
};
Cube.prototype.displayIndicator = function() {
  this.cIndicator.alpha = 1; 
};

Cube.prototype.takeDamage = function(amt) {
   this.healthBar.addValue(-amt);
};

Cube.prototype.remove = function() {
   if (!this.group) {
      return;
   }
   this.group.remove(this);
};

module.exports = Cube;















},{}],"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\entities\\cube_group.js":[function(require,module,exports){
var Astar = require('../libs/javascript-astar/astar');
var EnemyAI = require('./enemy_ai');

/*
Defines a cube group.
*/

var CubeGroup = function (game, root) {
   this.game = game;
   this.root = root;
   this.cubes = [];
   var col = [];
   col.push(this.root);
   this.cubes.push(col);
   if (this.root) {
      this.root.group = this;
   }
   this.DIR = {NORTH: 0, EAST: 1, SOUTH: 2, WEST: 3};
   this.offset = 2;
	this.hackerModules = [];	//list of hacker modules in this group

   this.numCubes = 1;
   this.bounceBackForce = 30;
   this.minRamVel = 300;
};

CubeGroup.prototype.constructor = CubeGroup;

/**
 * Automatically called by World.update
 */
CubeGroup.prototype.update = function() {
   if (this.AI) {
      this.AI.update();
   }
};

CubeGroup.prototype.call = function(fun) {
   for (var row = 0; row < this.cubesWidth(); row++) {
      for (var col = 0; col < this.cubesHeight(); col++) {
         var cube = this.cubes[row][col];
         if (cube && cube.hasOwnProperty(fun)) {
            // if cubes need functions called
         } else if (cube && cube.module && cube.module.hasOwnProperty(fun)) {
            var fn = cube.module[fun];
            if (typeof fn === 'function') {
               fn.call(cube.module);
            }
         }
      }
   }
};

CubeGroup.prototype.giveAI = function(type, player) {
   this.AI = new EnemyAI(this.game, this, type, player);
};

CubeGroup.prototype.add = function(cube, point) {
  if (!this.root && cube.module.type === 'core') {
     this.root = cube;
  }
  cube.group = this;
  this.set(cube, point);
  this.createConstraints(cube, point);
  // this.displayCubes();
};

CubeGroup.prototype.handleCollision = function(origin, other) {
   // stop if other does not exist, either is not a cube, both are in same group
	if (other === null || origin.prototype !== other.prototype || origin.group === other.group || other.tag !== 'module') {
		return;
	}
   if (other.group && other.group !== this && origin.ramDelay <= 0) {
      // console.log(origin.name, 'ramming damage!');
      other.takeDamage(1);
      origin.resetRamDelay();
   } else if (!other.group && this.isPlayer) {		
		//Check if one of these two is a hacker module, if so add it to the other's hackerModules list
	   if(!origin.group) {
			if(origin.module.type === 'hacker') {
				other.group.hackerModules.push(origin.module);
			}
		}
		if(!other.group) {
			if(other.module.type === 'hacker') {
				origin.group.hackerModules.push(other.module);
			}
		}
		var relSide = this.relativeSide(origin.body, other.body);
		var originLoc = this.find(origin);
		var otherLoc = this.adjust(originLoc, relSide);
		this.set(other, otherLoc);
		otherLoc = this.find(other); // update position since set can shift grid
		if (!otherLoc) {
			// console.log('handle collision failed to find position for good applicant');
			return;
		}
		this.createConstraints(other, otherLoc);
	}
};

CubeGroup.prototype.createConstraints = function(me, point) {
   // this.displayCubes();
   var myNorth = this.get(this.adjust(point, this.DIR.NORTH));
   var myEast = this.get(this.adjust(point, this.DIR.EAST));
   var mySouth = this.get(this.adjust(point, this.DIR.SOUTH));
   var myWest = this.get(this.adjust(point, this.DIR.WEST));
   var constraint;
   if (myNorth) {
      constraint = this.game.physics.p2.createLockConstraint(me.body, myNorth.body, [0, me.width + this.offset]); // me - north
      me.constraints.push(constraint);
      myNorth.constraints.push(constraint);
   }
   if (myEast) {
      constraint = this.game.physics.p2.createLockConstraint(me.body, myEast.body, [-me.width - this.offset, 0]); // me - east
      me.constraints.push(constraint);
      myEast.constraints.push(constraint);
   }
   if (mySouth) {
      constraint = this.game.physics.p2.createLockConstraint(mySouth.body, me.body, [0, me.width + this.offset]); // south - me
      me.constraints.push(constraint);
      mySouth.constraints.push(constraint);
   }
   if (myWest) {
      constraint = this.game.physics.p2.createLockConstraint(myWest.body, me.body, [-me.width - this.offset, 0]); // west - me
      me.constraints.push(constraint);
      myWest.constraints.push(constraint);
   }
};

CubeGroup.prototype.relativeSide = function(thisBody, otherBody) {
  var thisPoint = new Phaser.Point(thisBody.x, thisBody.y);
  var otherPoint = new Phaser.Point(otherBody.x, otherBody.y);
  var angleToOther = this.angleBetweenPoints(thisPoint, otherPoint);
  var diffAngle = Math.abs(Math.abs(angleToOther) - Math.abs(thisBody.rotation));
   if (diffAngle < 1 / 4 * Math.PI || diffAngle > 7 / 4 * Math.PI) { // north
     return this.DIR.NORTH;
  } else if (diffAngle >= 1 / 4 * Math.PI && diffAngle < 3 / 4 * Math.PI) { // east
     return this.DIR.EAST;
  } else if (diffAngle >= 3 / 4 * Math.PI && diffAngle < 5 / 4 * Math.PI) { // south
     return this.DIR.SOUTH;
  } else if (diffAngle >= 5 / 4 * Math.PI && diffAngle < 7 / 4 * Math.PI) { // west
     return this.DIR.WEST;
  }
};

CubeGroup.prototype.angleBetweenPoints = function(thisPoint, otherPoint) {
  var angleToOther = Phaser.Point.angle(thisPoint, otherPoint);
  if (angleToOther < 0) { // fix dumb part of Phaser.Point.angle()
     angleToOther = 2 * Math.PI + angleToOther;
  }
  angleToOther = (angleToOther + 3/2 * Math.PI) % (2 * Math.PI); // rotate 90 d clockwise
   return angleToOther;
};

CubeGroup.prototype.find = function(cube) {
   for (var row = 0; row < this.cubesWidth(); row++) {
      for (var col = 0; col < this.cubesHeight(); col++) {
         if (this.cubes[row][col] === cube) {
            return new Phaser.Point(row, col);
         }
      }
   }
   return undefined;
};

CubeGroup.prototype.get = function(point) {
  if (!point || this.outOfBounds(point)) {
      return;
  }
  return this.cubes[point.x][point.y];
};

CubeGroup.prototype.cubesWidth = function() {
   return this.cubes.length;
};

CubeGroup.prototype.cubesHeight = function() {
   return this.cubes[0].length;
};

CubeGroup.prototype.addTopRow = function() {
   for (var row = 0; row < this.cubesWidth(); row++) {
      this.cubes[row].push(undefined);
   }
};

CubeGroup.prototype.addRightCol = function() {
   var newCol = [];
   for (var i = 0; i < this.cubesHeight(); i++) {
      newCol.push(undefined);
   }
   this.cubes.push(newCol);
};

CubeGroup.prototype.addBotRow = function() {
   for (var row = 0; row < this.cubesWidth(); row++) {
      this.cubes[row].unshift(undefined);
   }
};

CubeGroup.prototype.addLeftCol = function() {
   var newCol = new Array(this.cubesHeight());
   this.cubes.unshift(newCol);
};

CubeGroup.prototype.getCube = function(point) {
   if (!point || this.outOfBounds(point)) {
      return undefined;
   }
   return this.cubes[point.x][point.y];
};

CubeGroup.prototype.adjust = function(point, dir) {
  if (!point) {
     return;
  }
  var newPoint = new Phaser.Point(point.x, point.y);
  switch (dir) {
      case this.DIR.NORTH:
      newPoint.y++;
      break;
      case this.DIR.EAST:
      newPoint.x++;
      break;
      case this.DIR.SOUTH:
      newPoint.y--;
      break;
      case this.DIR.WEST:
      newPoint.x--;
      break;
   }
   return newPoint;
};

CubeGroup.prototype.set = function(cube, point) {
   if (!point) {
      console.log('set given undefined point');
      return;
   }
   if (point.x < 0) {
      this.addLeftCol();
      point.x = 0;
   } else if (point.x >= this.cubesWidth()) {
      this.addRightCol();
      point.x = this.cubesWidth() - 1;
   } else if (point.y < 0) {
      this.addBotRow();
      point.y = 0;
   } else if (point.y >= this.cubesHeight()) {
      this.addTopRow();
      point.y = this.cubesHeight() - 1;
   }
   if (this.get(point)) {
      // console.log('tried to set to filled position');
      return;
   }
   this.cubes[point.x][point.y] = cube;
   cube.group = this;
};

CubeGroup.prototype.outOfBounds = function(point) {
   if (!point) {
      console.log('out of bounds given undefined point');
      return;
   }
   if (point.x < 0 || point.x >= this.cubesWidth() || point.y < 0 || point.y >= this.cubesHeight()) {
      return true;
   }
   return false;
};

CubeGroup.prototype.displayCubes = function() {
   console.log('================');
   var output = 'Display Cubes\n';
   var row = 0;
   var col = this.cubesHeight() - 1;
   while (col >= 0) {
      while (row < this.cubesWidth()) {
         var cube = this.cubes[row][col];
         if (cube) {
            output += '# ';
         } else {
            output += '_ ';
         }
         row++;
      }
      row = 0;
      col--;
      output += '\n';
   }
   console.log(output);
   console.log('---------------');
};

CubeGroup.prototype.displayConnection = function(connection) {
   var graph = new Astar.Graph(this.cubesToGraph());
   var startPoint = this.find(connection.start);
   var endPoint = this.find(connection.end);
   if (!startPoint || !endPoint) {
      console.log('displayConnection failed to get points');
      return;
   }
   var start = graph.grid[startPoint.x][startPoint.y];
   var end = graph.grid[endPoint.x][endPoint.y];
   var result = Astar.astar.search(graph, start, end);
   result.unshift(start);
   var previous;
   for(var i = 0; i < result.length; i++) {
      var curPoint = new Phaser.Point(result[i].x, result[i].y);
      var cur = this.get(curPoint);
      var indicator = cur.cIndicator;
      var dir;
      var prevPoint;
      var nextPoint;
      if (!previous) {
         indicator.animations.play('end');
         nextPoint = new Phaser.Point(result[i+1].x, result[i+1].y);
         dir = this.dirBetween(curPoint, nextPoint);
         indicator.rotation = this.dirToAngle(dir);
      } else if (i === result.length - 1) {
         indicator.animations.play('end');
         prevPoint = new Phaser.Point(previous.x, previous.y);
         dir = this.dirBetween(curPoint, prevPoint);
         indicator.rotation = this.dirToAngle(dir);
      } else {
         indicator.animations.play('line');
         prevPoint = new Phaser.Point(previous.x, previous.y);
         var prevDir = this.dirBetween(curPoint, prevPoint);
         nextPoint = new Phaser.Point(result[i+1].x, result[i+1].y);
         var nextDir = this.dirBetween(curPoint, nextPoint);
         this.manageIndicator(indicator, prevDir, nextDir);
      }
      previous = result[i];
      cur.displayIndicator();
    }
};

CubeGroup.prototype.manageIndicator = function(indicator, prevDir, nextDir) {
  indicator.scale.setTo(Math.abs(indicator.scale.x), indicator.scale.y);
  if (prevDir === this.DIR.NORTH && nextDir === this.DIR.SOUTH) { // 2
      indicator.rotation = Math.PI;
   } else if (prevDir === this.DIR.SOUTH && nextDir === this.DIR.NORTH) { // 1
      indicator.rotation = 0;
   } else if (prevDir === this.DIR.EAST && nextDir === this.DIR.WEST) { // 4
      indicator.rotation = 1 / 2 * Math.PI;
   } else if (prevDir === this.DIR.WEST && nextDir === this.DIR.EAST) { // 3
      indicator.rotation = 3 / 2  * Math.PI;
   } else {
      indicator.animations.play('right');
      if (prevDir === this.DIR.SOUTH && nextDir === this.DIR.EAST) { // 5
         indicator.rotation = 0;
      } else if (prevDir === this.DIR.WEST && nextDir === this.DIR.SOUTH) { // 6
         indicator.rotation = 1 / 2 * Math.PI;
      } else if (prevDir === this.DIR.NORTH && nextDir === this.DIR.WEST) { // 7
         indicator.rotation = Math.PI;
      } else if (prevDir === this.DIR.EAST && nextDir === this.DIR.NORTH) { // 8
         indicator.rotation = 3 / 2 * Math.PI;
      } else {
         indicator.scale.setTo(-Math.abs(indicator.scale.x), indicator.scale.y);
         if (prevDir === this.DIR.SOUTH && nextDir === this.DIR.WEST) { // 9
            indicator.rotation = 0;
         } else if (prevDir === this.DIR.WEST && nextDir === this.DIR.NORTH) { // 10
            indicator.rotation = 1 / 2 * Math.PI;
         } else if (prevDir === this.DIR.NORTH && nextDir === this.DIR.EAST) { // 11
            indicator.rotation = Math.PI;
         } else if (prevDir === this.DIR.EAST && nextDir === this.DIR.SOUTH) { // 12
            indicator.rotation = 3 / 2 * Math.PI;
         }
      }
   } 
};

CubeGroup.prototype.cubesToGraph = function() {
  var graph = [];
  for (var row = 0; row < this.cubesWidth(); row++) {
     var newCol = [];
      for (var col = 0; col < this.cubesHeight(); col++) {
         if (this.cubes[row][col]) {
            newCol.push(1);
         } else {
            newCol.push(0);
         }
      }
      graph.push(newCol);
   }
   return graph;
};

CubeGroup.prototype.dirBetween = function(a, b) {
   var deltaX = a.x - b.x;
   var deltaY = a.y - b.y;
   if (deltaX > 0) {
      return this.DIR.WEST;
   }
   if (deltaX < 0) {
      return this.DIR.EAST;
   }
   if (deltaY > 0) {
      return this.DIR.SOUTH;
   }
   if (deltaY < 0) {
      return this.DIR.NORTH;
   }
   return this.DIR.NORTH;
};

CubeGroup.prototype.dirToAngle = function(dir) {
  switch (dir) {
   case this.DIR.NORTH:
   return Math.PI;
   case this.DIR.EAST:
   return 3 / 2 * Math.PI;
   case this.DIR.SOUTH:
   return 0;
   case this.DIR.WEST:
   return 1 / 2 * Math.PI;
  }  
};

CubeGroup.prototype.destroyCube = function(cube) {
  // console.log('destroyCube');
  var loc = this.find(cube);
  if (!loc) {
     console.log('attempt to destroy cube not in group');
     return;
  }
  // remove cube from group
  this.remove(cube);
  // destroy cube
  cube.kill(true);
};

CubeGroup.prototype.remove = function(cube) {
   // console.log('remove');
   if (this.root === cube) {
      return;
   }
   // remove cube from array
   var row, col;
   for (row = 0; row < this.cubesWidth(); row++) {
      for (col = 0; col < this.cubesHeight(); col++) {
         if (this.cubes[row][col] === cube) {
            // this.cubes[row][col].group = undefined;
            this.cubes[row][col] = undefined;
            break;
         }
      }
   }
   // remove constraints from cube
   this.removeConstraints(cube);
   cube.group = undefined;
   if (cube.module && cube.module.hasOwnProperty('onRemove')) {
      cube.module.onRemove();
   }
   // test for exiles
   for (row = 0; row < this.cubesWidth(); row++) {
      for (col = 0; col < this.cubesHeight(); col++) {
         var exile = this.cubes[row][col];
         if (exile && this.isExile(exile)) {
            this.remove(exile);
         }
      }
   }
   // this.displayCubes();
};

CubeGroup.prototype.removeNeighborsConstraint = function(constraint, cube) {
   // console.log('removeNeighborsConstraint');
   var neighbors = this.getNeighbors(cube);
   for (var i = 0; i < neighbors.length; i++) {
      var neighbor = neighbors[i];
      for (var j = 0; j < neighbor.constraints.length; j++) {
         if (neighbor.constraints[j] === constraint) {
            neighbor.constraints.splice(j, 1);
         }
      }
   }
};

CubeGroup.prototype.getNeighbors = function(cube) {
   var loc = this.find(cube);
   var north = this.get(this.adjust(loc, this.DIR.NORTH));
   var east = this.get(this.adjust(loc, this.DIR.EAST));
   var south = this.get(this.adjust(loc, this.DIR.SOUTH));
   var west = this.get(this.adjust(loc, this.DIR.WEST));
   var neighbors = [];
   if (north) {
      neighbors.push(north);
   }
   if (east) {
      neighbors.push(east);
   }
   if (south) {
      neighbors.push(south);
   }
   if (west) {
      neighbors.push(west);
   }
   return neighbors;
};

CubeGroup.prototype.removeConstraints = function(cube) {
   // console.log('removeConstraints');
   while (cube.constraints.length > 0) {
      this.removeNeighborsConstraint(cube.constraints[0], cube);
      this.game.physics.p2.removeConstraint(cube.constraints[0]);
      cube.constraints.splice(0, 1);
   }
};

// only used to test Astar
CubeGroup.prototype.testPath = function() {
  var graph = new Astar.Graph([
        [1,1,1,1],
        [0,1,1,0],
        [0,0,0,1]
    ]);
   var start = graph.grid[0][0];
   var end = graph.grid[2][3];
   var result = Astar.astar.search(graph, start, end);
   result.unshift(start);
   for(var i = 0; i < result.length; i++) {
      console.log(result[i].x, result[i].y);
    } 
};

CubeGroup.prototype.isExile = function(cube) {
   if (cube === this.root) {
      return;
   }
   var graph = new Astar.Graph(this.cubesToGraph());
   var startPoint = this.find(this.root);
   var endPoint = this.find(cube);
   var start = graph.grid[startPoint.x][startPoint.y];
   var end = graph.grid[endPoint.x][endPoint.y];
   var result = Astar.astar.search(graph, start, end);
   // if no path is found, the cube is an exile
   if (result.length === 0) {
      return true;
   }
   return false;
};

CubeGroup.prototype.countCubes = function() {
	var row, col;
	var num  = 0;
	for (row = 0; row < this.cubesWidth(); row++) {
		for (col = 0; col < this.cubesHeight(); col++) {
			if (this.cubes[row][col] !== undefined) {
				num++;
			}
		}
	}
	//console.log(num);
	this.numCubes = num;
};

module.exports = CubeGroup;

















},{"../libs/javascript-astar/astar":"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\libs\\javascript-astar\\astar.js","./enemy_ai":"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\entities\\enemy_ai.js"}],"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\entities\\enemy_ai.js":[function(require,module,exports){
var Utils = require('../utils.js');

var EnemyAI = function(game, group, type, playerGroup) {
   this.game = game;
   this.group = group;
   this.type = type;
   this.playerGroup = playerGroup;
   this.player = this.playerGroup.root;
   this.ramDist = 500;
   this.rotationForce = 50;
   this.facingAllowance = Math.PI / 15;
   this.thrustersFiring = false;
   this.gunsFiring = false;
   switch (this.type) {
      case 'ram':
      this.allocateTo('thruster');
      break;
   }
};

EnemyAI.prototype.constructor = EnemyAI;

EnemyAI.prototype.update = function() {
   switch (this.type) {
      case 'ram':
      this.ramUpdate();
      break;
      case 'shoot':
      this.shootUpdate();
   }
};

EnemyAI.prototype.ramUpdate = function() {
   if (!this.group.root) {
      return;
   }
   var root = this.group.root;
   var myPos = new Phaser.Point(root.x, root.y);
   var playerPos = new Phaser.Point(this.player.x, this.player.y);
   var dist = Utils.distance(myPos.x, myPos.y, playerPos.x, playerPos.y);
   if (dist <= this.ramDist) {
      var angleTo = this.angleTo(myPos, playerPos);
      var diffAngle = angleTo - root.body.rotation;
      if (diffAngle > 0) {
         root.body.angularForce = this.rotationForce;
      } else {
         root.body.angularForce = -this.rotationForce;
      }
      if (Math.abs(diffAngle) <= this.facingAllowance && !this.thrustersFiring) {
         this.group.call('beginAct');
         this.thrustersFiring = true;
         this.allocateTo('thruster');
      } else if (Math.abs(diffAngle) > this.facingAllowance && this.thrustersFiring){
         this.group.call('endAct');
         this.thrustersFiring = false;
      }
   }
};

EnemyAI.prototype.shootUpdate = function() {
   if (!this.group.root) {
      return;
   }
   var root = this.group.root;
   var myPos = new Phaser.Point(root.x, root.y);
   var playerPos = new Phaser.Point(this.player.x, this.player.y);
   var dist = Utils.distance(myPos.x, myPos.y, playerPos.x, playerPos.y);
   if (dist <= this.ramDist) {
      var angleTo = this.angleTo(myPos, playerPos);
      var diffAngle = angleTo - root.body.rotation;
      if (diffAngle > 0) {
         root.body.angularForce = this.rotationForce;
      } else {
         root.body.angularForce = -this.rotationForce;
      }
      if (Math.abs(diffAngle) <= this.facingAllowance && !this.gunsFiring) {
         this.group.call('beginAct');
         this.gunsFiring = true;
         this.allocateTo('gun');
      } else if (Math.abs(diffAngle) > this.facingAllowance && this.gunsFiring){
         this.group.call('endAct');
         this.gunsFiring = false;
      }
   }
};

EnemyAI.prototype.allocateTo = function(type) {
   var panels = [];
   var types = [];
   for (var row = 0; row < this.group.cubesWidth(); row++) {
      for (var col = 0; col < this.group.cubesHeight(); col++) {
         var cube = this.group.cubes[row][col];
         if (cube && cube.module) {
            if (cube.module.type === 'solarPanel' && !cube.myConnection) {
               panels.push(cube.module);
            } else if (cube.module.type === type && !cube.myConnection) {
               types.push(cube.module);
            }
         }
      }
   }
   var i = 0;
   while (i < types.length && i < panels.length) {
      var tarPanel = panels[i];
      var tarType = types[i];
      var newConnection = {start: tarPanel.cube, end: tarType.cube};
      tarPanel.cube.myConnection = newConnection;
      tarType.cube.myConnection = newConnection;
      this.group.displayConnection(tarPanel.cube.myConnection);
      i++;
   }
};

EnemyAI.prototype.angleTo = function(from, to) {
  var angleToOther = Phaser.Point.angle(from, to);
  if (angleToOther < 0) { // fix dumb part of Phaser.Point.angle()
     angleToOther = 2 * Math.PI + angleToOther;
  }
  angleToOther = (angleToOther + 3/2 * Math.PI) % (2 * Math.PI); // rotate 90 d clockwise
  return angleToOther;
};

module.exports = EnemyAI;











},{"../utils.js":"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\utils.js"}],"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\entities\\mouse.js":[function(require,module,exports){
var Utils = require('../utils.js');

var Mouse = function(game, input, playerGroup) {
   this.game = game;
   this.input = input;
	this.body = new p2.Body(); // jshint ignore:line
   this.game.physics.p2.world.addBody(this.body);
   // this.game.physics.p2.enable(this);
   
   this.input.onDown.add(this.click, this);
   this.input.onUp.add(this.release, this);
   this.input.addMoveCallback(this.move, this);
   this.x = 0;
   this.y = 0;
   
   this.grabbed = undefined;
   this.lastClicked = undefined;
   this.line = new Phaser.Line(0, 0, 0, 0);
   
   this.removeThreshold = 400; // time in milliseconds
   this.removeTime = 0; // time till threshold
   
   this.playerGroup = playerGroup;
};

Mouse.prototype.constructor = Mouse;

Mouse.prototype.update = function() {
   if (this.grabbed) {
      var angle = Math.atan2(this.grabbed.sprite.y - (this.input.position.y + this.game.camera.y), this.grabbed.sprite.x - (this.input.position.x+ this.game.camera.x)) + Math.PI;
      var dist = Utils.distance(this.grabbed.sprite.x, this.grabbed.sprite.y, (this.input.position.x+ this.game.camera.x), (this.input.position.y + this.game.camera.y));
      var weight = 10;
      if (!this.grabbed.sprite.group) {
         this.grabbed.force.x = Math.cos(angle) * dist * weight;
         this.grabbed.force.y = Math.sin(angle) * dist * weight;
      }
      this.line.setTo(this.grabbed.sprite.x, this.grabbed.sprite.y, (this.input.position.x+ this.game.camera.x), (this.input.position.y + this.game.camera.y));
      this.removeTime += this.game.time.elapsed;
      if(this.grabbed.sprite.tag === 'module') {
		  if (this.removeTime >= this.removeThreshold && this.grabbed.sprite.key !== 'asteroid') {
			 this.grabbed.sprite.remove();
			 this.removeTime = 0;
		  }
	  }
    } else {
       this.line.setTo(0, 0, 0, 0);
    }
    var point = new Phaser.Point(this.x, this.y);
    var bodies = this.game.physics.p2.hitTest(point);
    if (bodies.length)
    {
        var hover = bodies[0].parent;
        if (hover.sprite.module && hover.sprite.module.mouseOver) {
           hover.sprite.module.mouseOver();
        }
    }
};

Mouse.prototype.click = function(pointer) {
   var point = new Phaser.Point(pointer.x + this.game.camera.x, pointer.y + this.game.camera.y);
   var bodies = this.game.physics.p2.hitTest(point);
   if (bodies.length)
   {
     var temp = bodies[0].parent;
     if (temp.sprite && temp.sprite.module && temp.sprite.module.type === 'core') {
        return;
     }
     if (temp.sprite && temp.sprite.group && temp.sprite.group !== this.playerGroup) {
        return;
     }
     this.removeTime = 0;
     this.grabbed = temp;
     // console.log(this.grabbed.sprite.name);
     if (this.grabbed.sprite.module && this.grabbed.sprite.module.hasOwnProperty('mouseDown')) {
        this.grabbed.sprite.module.mouseDown();
     }
     if (this.lastClicked && this.lastClicked.sprite && this.lastClicked.sprite.module &&
     this.lastClicked.sprite.module.giveTarget) {
        this.lastClicked.sprite.module.giveTarget(this.grabbed.sprite.module);
     }
     this.lastClicked = temp;
   }
};
  
 Mouse.prototype.release = function() {
   if (this.grabbed) {
     this.grabbed = undefined;
   }
};
  
Mouse.prototype.move = function(pointer) {
   // p2 uses different coordinate system, so convert the pointer position to p2's coordinate system
   this.body.position[0] = this.game.physics.p2.pxmi(pointer.position.x);
   this.body.position[1] = this.game.physics.p2.pxmi(pointer.position.y);
   this.x = pointer.position.x + this.game.camera.x;
   this.y = pointer.position.y + this.game.camera.y;
};

Mouse.prototype.render = function() {
   this.game.debug.geom(this.line);
};

module.exports = Mouse;















},{"../utils.js":"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\utils.js"}],"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\functionAccess\\Renderables.js":[function(require,module,exports){
var Renderables = function() {
	if(Renderables.prototype.exists) {
		return Renderables.prototype.existingReference;
	}
	
	this.list = [];
	Renderables.prototype.exists = true;
	Renderables.prototype.existingReference = this;
};

Renderables.prototype.constructor = Renderables;
//These var's help create the singleton functionality
Renderables.prototype.exists = false;
Renderables.prototype.existingReference = null;

Renderables.prototype.subscribe = function(subscriber) {
	this.list.push(subscriber);
};

Renderables.prototype.unsubscribe = function(unsubscriber) {
	for(var i = 0; i < this.list.length; i++) {
		if(this.list[i] === unsubscriber) {
			this.list[i] = false;
		}
	}
};

Renderables.prototype.renderAll = function() {
	for(var i = 0; i < this.list.length; i++) {
		if(this.list[i] === false) {
			continue;
		}
		this.list[i].render();
	}
};

module.exports = Renderables;
},{}],"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\libs\\javascript-astar\\astar.js":[function(require,module,exports){
// javascript-astar 0.4.0
// http://github.com/bgrins/javascript-astar
// Freely distributable under the MIT License.
// Implements the astar search algorithm in javascript using a Binary Heap.
// Includes Binary Heap (with modifications) from Marijn Haverbeke.
// http://eloquentjavascript.net/appendix2.html

(function(definition) {
    /* global module, define */
    if(typeof module === 'object' && typeof module.exports === 'object') {
        module.exports = definition();
    } else if(typeof define === 'function' && define.amd) {
        define([], definition);
    } else {
        var exports = definition();
        window.astar = exports.astar;
        window.Graph = exports.Graph;
    }
})(function() {

function pathTo(node){
    var curr = node,
        path = [];
    while(curr.parent) {
        path.push(curr);
        curr = curr.parent;
    }
    return path.reverse();
}

function getHeap() {
    return new BinaryHeap(function(node) {
        return node.f;
    });
}

var astar = {
    /**
    * Perform an A* Search on a graph given a start and end node.
    * @param {Graph} graph
    * @param {GridNode} start
    * @param {GridNode} end
    * @param {Object} [options]
    * @param {bool} [options.closest] Specifies whether to return the
               path to the closest node if the target is unreachable.
    * @param {Function} [options.heuristic] Heuristic function (see
    *          astar.heuristics).
    */
    search: function(graph, start, end, options) {
        graph.cleanDirty();
        options = options || {};
        var heuristic = options.heuristic || astar.heuristics.manhattan,
            closest = options.closest || false;

        var openHeap = getHeap(),
            closestNode = start; // set the start node to be the closest if required

        start.h = heuristic(start, end);

        openHeap.push(start);

        while(openHeap.size() > 0) {

            // Grab the lowest f(x) to process next.  Heap keeps this sorted for us.
            var currentNode = openHeap.pop();

            // End case -- result has been found, return the traced path.
            if(currentNode === end) {
                return pathTo(currentNode);
            }

            // Normal case -- move currentNode from open to closed, process each of its neighbors.
            currentNode.closed = true;

            // Find all neighbors for the current node.
            var neighbors = graph.neighbors(currentNode);

            for (var i = 0, il = neighbors.length; i < il; ++i) {
                var neighbor = neighbors[i];

                if (neighbor.closed || neighbor.isWall()) {
                    // Not a valid node to process, skip to next neighbor.
                    continue;
                }

                // The g score is the shortest distance from start to current node.
                // We need to check if the path we have arrived at this neighbor is the shortest one we have seen yet.
                var gScore = currentNode.g + neighbor.getCost(currentNode),
                    beenVisited = neighbor.visited;

                if (!beenVisited || gScore < neighbor.g) {

                    // Found an optimal (so far) path to this node.  Take score for node to see how good it is.
                    neighbor.visited = true;
                    neighbor.parent = currentNode;
                    neighbor.h = neighbor.h || heuristic(neighbor, end);
                    neighbor.g = gScore;
                    neighbor.f = neighbor.g + neighbor.h;
                    graph.markDirty(neighbor);
                    if (closest) {
                        // If the neighbour is closer than the current closestNode or if it's equally close but has
                        // a cheaper path than the current closest node then it becomes the closest node
                        if (neighbor.h < closestNode.h || (neighbor.h === closestNode.h && neighbor.g < closestNode.g)) {
                            closestNode = neighbor;
                        }
                    }

                    if (!beenVisited) {
                        // Pushing to heap will put it in proper place based on the 'f' value.
                        openHeap.push(neighbor);
                    }
                    else {
                        // Already seen the node, but since it has been rescored we need to reorder it in the heap
                        openHeap.rescoreElement(neighbor);
                    }
                }
            }
        }

        if (closest) {
            return pathTo(closestNode);
        }

        // No result was found - empty array signifies failure to find path.
        return [];
    },
    // See list of heuristics: http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html
    heuristics: {
        manhattan: function(pos0, pos1) {
            var d1 = Math.abs(pos1.x - pos0.x);
            var d2 = Math.abs(pos1.y - pos0.y);
            return d1 + d2;
        },
        diagonal: function(pos0, pos1) {
            var D = 1;
            var D2 = Math.sqrt(2);
            var d1 = Math.abs(pos1.x - pos0.x);
            var d2 = Math.abs(pos1.y - pos0.y);
            return (D * (d1 + d2)) + ((D2 - (2 * D)) * Math.min(d1, d2));
        }
    },
    cleanNode:function(node){
        node.f = 0;
        node.g = 0;
        node.h = 0;
        node.visited = false;
        node.closed = false;
        node.parent = null;
    }
};

/**
* A graph memory structure
* @param {Array} gridIn 2D array of input weights
* @param {Object} [options]
* @param {bool} [options.diagonal] Specifies whether diagonal moves are allowed
*/
function Graph(gridIn, options) {
    options = options || {};
    this.nodes = [];
    this.diagonal = !!options.diagonal;
    this.grid = [];
    for (var x = 0; x < gridIn.length; x++) {
        this.grid[x] = [];

        for (var y = 0, row = gridIn[x]; y < row.length; y++) {
            var node = new GridNode(x, y, row[y]);
            this.grid[x][y] = node;
            this.nodes.push(node);
        }
    }
    this.init();
}

Graph.prototype.init = function() {
    this.dirtyNodes = [];
    for (var i = 0; i < this.nodes.length; i++) {
        astar.cleanNode(this.nodes[i]);
    }
};

Graph.prototype.cleanDirty = function() {
    for (var i = 0; i < this.dirtyNodes.length; i++) {
        astar.cleanNode(this.dirtyNodes[i]);
    }
    this.dirtyNodes = [];
};

Graph.prototype.markDirty = function(node) {
    this.dirtyNodes.push(node);
};

Graph.prototype.neighbors = function(node) {
    var ret = [],
        x = node.x,
        y = node.y,
        grid = this.grid;

    // West
    if(grid[x-1] && grid[x-1][y]) {
        ret.push(grid[x-1][y]);
    }

    // East
    if(grid[x+1] && grid[x+1][y]) {
        ret.push(grid[x+1][y]);
    }

    // South
    if(grid[x] && grid[x][y-1]) {
        ret.push(grid[x][y-1]);
    }

    // North
    if(grid[x] && grid[x][y+1]) {
        ret.push(grid[x][y+1]);
    }

    if (this.diagonal) {
        // Southwest
        if(grid[x-1] && grid[x-1][y-1]) {
            ret.push(grid[x-1][y-1]);
        }

        // Southeast
        if(grid[x+1] && grid[x+1][y-1]) {
            ret.push(grid[x+1][y-1]);
        }

        // Northwest
        if(grid[x-1] && grid[x-1][y+1]) {
            ret.push(grid[x-1][y+1]);
        }

        // Northeast
        if(grid[x+1] && grid[x+1][y+1]) {
            ret.push(grid[x+1][y+1]);
        }
    }

    return ret;
};

Graph.prototype.toString = function() {
    var graphString = [],
        nodes = this.grid, // when using grid
        rowDebug, row, y, l;
    for (var x = 0, len = nodes.length; x < len; x++) {
        rowDebug = [];
        row = nodes[x];
        for (y = 0, l = row.length; y < l; y++) {
            rowDebug.push(row[y].weight);
        }
        graphString.push(rowDebug.join(' '));
    }
    return graphString.join('\n');
};

function GridNode(x, y, weight) {
    this.x = x;
    this.y = y;
    this.weight = weight;
}

GridNode.prototype.toString = function() {
    return '[' + this.x + ' ' + this.y + ']';
};

GridNode.prototype.getCost = function(fromNeighbor) {
    // Take diagonal weight into consideration.
    if (fromNeighbor && fromNeighbor.x !== this.x && fromNeighbor.y !== this.y) {
        return this.weight * 1.41421;
    }
    return this.weight;
};

GridNode.prototype.isWall = function() {
    return this.weight === 0;
};

function BinaryHeap(scoreFunction){
    this.content = [];
    this.scoreFunction = scoreFunction;
}

BinaryHeap.prototype = {
    push: function(element) {
        // Add the new element to the end of the array.
        this.content.push(element);

        // Allow it to sink down.
        this.sinkDown(this.content.length - 1);
    },
    pop: function() {
        // Store the first element so we can return it later.
        var result = this.content[0];
        // Get the element at the end of the array.
        var end = this.content.pop();
        // If there are any elements left, put the end element at the
        // start, and let it bubble up.
        if (this.content.length > 0) {
            this.content[0] = end;
            this.bubbleUp(0);
        }
        return result;
    },
    remove: function(node) {
        var i = this.content.indexOf(node);

        // When it is found, the process seen in 'pop' is repeated
        // to fill up the hole.
        var end = this.content.pop();

        if (i !== this.content.length - 1) {
            this.content[i] = end;

            if (this.scoreFunction(end) < this.scoreFunction(node)) {
                this.sinkDown(i);
            }
            else {
                this.bubbleUp(i);
            }
        }
    },
    size: function() {
        return this.content.length;
    },
    rescoreElement: function(node) {
        this.sinkDown(this.content.indexOf(node));
    },
    sinkDown: function(n) {
        // Fetch the element that has to be sunk.
        var element = this.content[n];

        // When at 0, an element can not sink any further.
        while (n > 0) {

            // Compute the parent element's index, and fetch it.
            var parentN = ((n + 1) >> 1) - 1, parent = this.content[parentN]; // jshint ignore:line
            // Swap the elements if the parent is greater.
            if (this.scoreFunction(element) < this.scoreFunction(parent)) {
                this.content[parentN] = element;
                this.content[n] = parent;
                // Update 'n' to continue at the new position.
                n = parentN;
            }
            // Found a parent that is less, no need to sink any further.
            else {
                break;
            }
        }
    },
    bubbleUp: function(n) {
        // Look up the target element and its score.
        var length = this.content.length,
            element = this.content[n],
            elemScore = this.scoreFunction(element);

        while(true) {
            // Compute the indices of the child elements.
            var child2N = (n + 1) << 1, child1N = child2N - 1; // jshint ignore:line
            // This is used to store the new position of the element, if any.
            var swap = null,
                child1Score;
            // If the first child exists (is inside the array)...
            if (child1N < length) {
                // Look it up and compute its score.
                var child1 = this.content[child1N];
                child1Score = this.scoreFunction(child1);

                // If the score is less than our element's, we need to swap.
                if (child1Score < elemScore){
                    swap = child1N;
                }
            }

            // Do the same checks for the other child.
            if (child2N < length) {
                var child2 = this.content[child2N],
                    child2Score = this.scoreFunction(child2);
                if (child2Score < (swap === null ? elemScore : child1Score)) {
                    swap = child2N;
                }
            }

            // If the element needs to be moved, swap it, and continue.
            if (swap !== null) {
                this.content[n] = this.content[swap];
                this.content[swap] = element;
                n = swap;
            }
            // Otherwise, we are done.
            else {
                break;
            }
        }
    }
};

return {
    astar: astar,
    Graph: Graph
};

});

},{}],"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\states\\boot.js":[function(require,module,exports){
var Boot = function () {};

module.exports = Boot;

Boot.prototype = {

  preload: function () {
    this.load.image('preloader', 'assets/preloader.gif');
  },

  create: function () {
    this.game.input.maxPointers = 1;

    if (this.game.device.desktop) {
      //this.game.stage.scale.pageAlignHorizontally = true;
      this.game.scale.scaleMode = Phaser.ScaleManager.RESIZE;
    } else {
      this.game.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL;
      this.game.scale.minWidth =  480;
      this.game.scale.minHeight = 260;
      this.game.scale.maxWidth = 640;
      this.game.scale.maxHeight = 480;
      this.game.scale.forceLandscape = true;
      this.game.scale.pageAlignHorizontally = true;
      this.game.scale.setScreenSize(true);
    }

    this.game.state.start('Preloader');
  }
};

},{}],"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\states\\game.js":[function(require,module,exports){
/*
Main testing environment.
*/

var Renderables = require('../functionAccess/Renderables');
var UIBuilder = require('../ui/UIBuilder');
var Cube = require('../entities/cube');
var ModuleBuilder = require('../entities/ModuleBuilder');
var Utils = require('../utils');
var CubeGroup = require('../entities/cube_group');
var Hackable = require('../entities/Hackable');
var Emitter = require('../effects/Emitter');
var mouseBody; // physics body for mouse
var Mouse = require('../entities/mouse');

var bg, bg2;
var numRoids = 0;
var maxRoids = 50;
var asteroids, asteroidList;
var leftKey, rightKey, cwKey, ccwKey;
var asteroidCG, cubeCG;

var Game = function () {
  this.testentity = null;
};

module.exports = Game;

Game.prototype = {
	
  create: function () {
	this.game.world.setBounds(0, 0, 8000, 4000);
	
	//Create the two background images
    bg = this.game.add.sprite(0, 0, 'earthNight');
	bg2 = this.game.add.sprite(-8000, 0, 'earthNight');
	
	this.game.physics.startSystem(Phaser.Physics.P2JS);
   this.game.physics.p2.setImpactEvents(true);

	cubeCG = this.game.physics.p2.createCollisionGroup();
	asteroidCG = this.game.physics.p2.createCollisionGroup();
	
   this.mouse = new Mouse(this.game, this.input);
   
   this.updateDependents = [];

	//create Renderables class
	this.renderables = new Renderables();
	//create the UIBuilder
	this.uiBuilder = new UIBuilder(this, this.renderables);   
	//create ModuleBuilder and store it in this game state object
	this.moduleBuilder = new ModuleBuilder(this);
	//create and store the core module
	this.coreModule = this.moduleBuilder.build('core', 1200, 1200, true);
	this.cubeWidth = this.coreModule.cube.width;
	this.coreModule.cube.body.setCollisionGroup(cubeCG);
	this.coreModule.cube.body.collides([cubeCG, asteroidCG]);
	this.cubeBuffer = 2;
	var playerGroup = new CubeGroup(this, this.coreModule.cube);
	this.updateDependents.push(playerGroup);
	this.player = playerGroup;
   this.player.isPlayer = true;
   
   this.mouse = new Mouse(this.game, this.input, playerGroup);
	this.player.isPlayer = true;

	//Create the emitter for the binary particle effects
	this.BinaryEmitter = new Emitter(this);
	
	//test hackable object
	this.testHack = new Hackable(this, 1600,1200, 'hackable1', 400);

	this.spaceKey = this.game.input.keyboard.addKey(Phaser.Keyboard.SPACEBAR);
	this.game.input.keyboard.addKeyCapture([this.spaceKey]);

	
	asteroids = this.game.add.group();
	asteroids.enableBody = true;
	asteroids.physicsBodyType = Phaser.Physics.P2JS;
	asteroidList = new Phaser.ArraySet();
	this.generateAsteroids();
	
	leftKey = this.game.input.keyboard.addKey(Phaser.Keyboard.A);
	rightKey = this.game.input.keyboard.addKey(Phaser.Keyboard.D);
	ccwKey = this.game.input.keyboard.addKey(Phaser.Keyboard.Q);
	cwKey = this.game.input.keyboard.addKey(Phaser.Keyboard.E);
	
	//DEBUGGING LISTENERS- allow you to create modules by pressing keys
	//core
	this.placeCoreKey = this.game.input.keyboard.addKey(Phaser.Keyboard.P);
	this.placeCoreKey.onDown.add(this.addCore, this);
	//shield
	this.placeShieldKey = this.game.input.keyboard.addKey(Phaser.Keyboard.O);
    this.placeShieldKey.onDown.add(this.addShield, this);
	//thruster
	this.placeThrusterKey = this.game.input.keyboard.addKey(Phaser.Keyboard.I);
    this.placeThrusterKey.onDown.add(this.addThruster, this);
	//solarPanel
	this.placeSPKey = this.game.input.keyboard.addKey(Phaser.Keyboard.U);
    this.placeSPKey.onDown.add(this.addSP, this);
	//hacker
	this.placeHackKey = this.game.input.keyboard.addKey(Phaser.Keyboard.Y);
	this.placeHackKey.onDown.add(this.addHack, this);
	//gun
	this.placeGunKey = this.game.input.keyboard.addKey(Phaser.Keyboard.T);
    this.placeGunKey.onDown.add(this.addGun, this);
	//END
    
    // Debug controller
    this.debugKey = this.game.input.keyboard.addKey(Phaser.Keyboard.H);
    this.debugKey.onDown.add(this.debug, this);
    this.rootSpawned = false;
    
    this.debugNum = 0;
    this.myRoot = undefined;

	 this.game.camera.setPosition(1000, 1000);
    
    this.levelData = JSON.parse(this.game.cache.getText('level_one'));
    //this.loadData();
    
    this.juicy = this.game.plugins.add(new Phaser.Plugin.Juicy(this));
    this.game.camera.follow(this.coreModule.cube);
  },
  
  loadData: function() {
      var myLevel = this.levelData['level_one'];
      for (var key in myLevel) {
         if (myLevel.hasOwnProperty(key)) {
            var element = myLevel[key];
            if (element.hasOwnProperty('blueprint')) { // enemy type
               var enemyX = element['x_pos'];
               var enemyY = element['y_pos'];
               var enemyGroup = new CubeGroup(this, undefined);
               this.updateDependents.push(enemyGroup);
               var blueprint = element['blueprint'];
               // var practical = [];
               for (var row = 0; row < blueprint.length; row++) {
                  // var newCol = [];
                  for (var col = 0; col < blueprint[row].length; col++) {
                     var type = blueprint[row][col];
                     var newModule = this.moduleBuilder.build(type, enemyX + row * (this.cubeWidth + this.cubeBuffer),
                     enemyY - col * (this.cubeWidth + this.cubeBuffer), false);
					 newModule.cube.body.setCollisionGroup(cubeCG);
					 newModule.cube.body.collides([cubeCG, asteroidCG]);
                     // newCol.push(newModule.cube);
                     var point = new Phaser.Point(row, col);
                     enemyGroup.add(newModule.cube, point);
                  }
                  // practical.push(newCol);
               }
               // TODO: give different types here
               enemyGroup.giveAI('ram', this.player);
            }
         }
      }
  },

  update: function () {    
	if(leftKey.isDown) {
		if(this.coreModule.cube.body.angularVelocity > -9) { 
			this.coreModule.cube.body.angularForce += -5 * Math.pow(this.player.numCubes, 1.65);
		}
	}
	
	if(rightKey.isDown) {
		if(this.coreModule.cube.body.angularVelocity < 9) {
			this.coreModule.cube.body.angularForce += 5 * Math.pow(this.player.numCubes, 1.65);
		}
	}
	
	if(ccwKey.isDown) {
		if(this.mouse.grabbed !== undefined && this.mouse.grabbed.sprite.group === undefined) {
			this.mouse.grabbed.angularForce += -5;
		}
	}
	
	if(cwKey.isDown) {
		if(this.mouse.grabbed !== undefined && this.mouse.grabbed.sprite.group === undefined) {
			this.mouse.grabbed.angularForce += 5;
		}
	}
	
	this.mouse.update();
	this.scrollBG();
   
	for (var i = 0; i < this.updateDependents.length; i++) {
		if (this.updateDependents[i].update) {
			this.updateDependents[i].update();
		}
	}
  },
  
  render: function () {
	this.mouse.render();
	this.renderables.renderAll();
  },
  
	scrollBG: function() {
		bg.x += 0.125;
		if(bg.x >= 8000) {
			bg.x += 0;
		}
		bg2.x += 0.125;
		if(bg2.x >= 8000) {
			bg2.x = 0;
		}
	},
	
	generateAsteroids: function() {
		for(;numRoids < maxRoids; numRoids++) {
			var coinA = this.game.rnd.integerInRange(0,1);
			var coinB = this.game.rnd.integerInRange(0,1);
			var asteroid;
			if(coinA === 1) {
				if(coinB === 1) { //Spawn asteroid above screen
					asteroid = asteroids.create(this.coreModule.cube.x + this.game.rnd.integerInRange(-this.game.camera.width/2, this.game.camera.width/2), this.coreModule.cube.y - this.game.camera.height/2 - this.game.rnd.integerInRange(32, 300), 'asteroid');
				}
				else { //Spawn asteroid below screen
					asteroid = asteroids.create(this.coreModule.cube.x + this.game.rnd.integerInRange(-this.game.camera.width/2, this.game.camera.width/2), this.coreModule.cube.y + this.game.camera.height/2 + this.game.rnd.integerInRange(32, 300), 'asteroid');
				}
			}
			else {
				if(coinB === 1) { //Spawn asteroid to left of screen
					asteroid = asteroids.create(this.coreModule.cube.x - this.game.camera.width/2 - this.game.rnd.integerInRange(32, 300), this.coreModule.cube.y + this.game.rnd.integerInRange(-this.game.camera.height/2, this.game.camera.height/2), 'asteroid');
				}
				else { //Spawn asteroid to right
					asteroid = asteroids.create(this.coreModule.cube.x + this.game.camera.width/2 + this.game.rnd.integerInRange(32, 300), this.coreModule.cube.y + this.game.rnd.integerInRange(-this.game.camera.height/2, this.game.camera.height/2), 'asteroid');
				}
			}
			
			asteroid.body.setCircle(16); //Change the collision detection from an AABB to a circle
			asteroid.body.angularDamping = 0;
			asteroid.body.damping = 0;
			asteroid.body.rotation = this.game.rnd.realInRange(0, 2 * 3.14);
			asteroid.body.force.x = this.game.rnd.integerInRange(-10, 10) * 750;
			asteroid.body.force.y = this.game.rnd.integerInRange(-10, 10) * 750;
			asteroid.body.setCollisionGroup(asteroidCG);
			asteroid.body.collides([asteroidCG, cubeCG]);
			asteroid.body.collideWorldBounds = false;
			asteroid.autoCull = true;
			asteroid.checkWorldBounds = true;
			asteroid.events.onOutOfBounds.add(this.resetAsteroid, asteroid);
			asteroidList.add(asteroid);
		}
	},
	
	resetAsteroid: function() { //Needs to be updated once collision groups are working
		//this.obj.x = 10;
		//this.obj.y = 10;
	},
	
  //DEBUG FUNCTIONS- event functions called from listeners that allow you to create modules with key presses
  addCore: function () { 
	//Attempts to create more core modules here will only return the existing core
	var newModule = this.moduleBuilder.build('core', this.mouse.x, this.mouse.y, true);
	newModule.cube.body.setCollisionGroup(cubeCG);
	newModule.cube.body.collides([cubeCG, asteroidCG]);
  },
  addShield: function () {
	var newModule = this.moduleBuilder.build('shield', this.mouse.x, this.mouse.y, true);
	newModule.cube.body.setCollisionGroup(cubeCG);
	newModule.cube.body.collides([cubeCG, asteroidCG]);
  },
  addThruster: function () {
	var newModule = this.moduleBuilder.build('thruster', this.mouse.x, this.mouse.y, true);
	newModule.cube.body.setCollisionGroup(cubeCG);
	newModule.cube.body.collides([cubeCG, asteroidCG]);
  },
  addSP: function () {
	var newModule = this.moduleBuilder.build('solarPanel', this.mouse.x, this.mouse.y, true);
	newModule.cube.body.setCollisionGroup(cubeCG);
	newModule.cube.body.collides([cubeCG, asteroidCG]);
  },
  addHack: function () {
	var newModule = this.moduleBuilder.build('hacker', this.mouse.x, this.mouse.y, true);
	newModule.cube.body.setCollisionGroup(cubeCG);
	newModule.cube.body.collides([cubeCG, asteroidCG]);
  },
  addGun: function () {
	var newModule = this.moduleBuilder.build('gun', this.mouse.x, this.mouse.y, true);
	newModule.cube.body.setCollisionGroup(cubeCG);
	newModule.cube.body.collides([cubeCG, asteroidCG]);
  },

  debug: function () {
    this.juicy.shake();
  }
};




























},{"../effects/Emitter":"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\effects\\Emitter.js","../entities/Hackable":"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\entities\\Hackable.js","../entities/ModuleBuilder":"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\entities\\ModuleBuilder.js","../entities/cube":"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\entities\\cube.js","../entities/cube_group":"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\entities\\cube_group.js","../entities/mouse":"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\entities\\mouse.js","../functionAccess/Renderables":"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\functionAccess\\Renderables.js","../ui/UIBuilder":"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\ui\\UIBuilder.js","../utils":"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\utils.js"}],"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\states\\menu.js":[function(require,module,exports){
var Menu = function () {
  this.text = null;
};

module.exports = Menu;

Menu.prototype = {

  create: function () {
    var x = this.game.width / 2;
    var y = this.game.height / 2;

    var style = { font: '65px Arial', fill: '#ffffff', align: 'center' };
    this.title = this.game.add.text(this.game.world.centerX, this.game.world.centerY - 250, 'Above The Iron Curtain', style);
    this.newGame = this.game.add.text(this.game.world.centerX, this.game.world.centerY - 150, 'New Simulation', style);
    this.level = this.game.add.text(this.game.world.centerX, this.game.world.centerY - 50, 'Mission Select', style);
    this.controls = this.game.add.text(this.game.world.centerX, this.game.world.centerY + 50, 'Manual', style);
    this.credits = this.game.add.text(this.game.world.centerX, this.game.world.centerY + 150, 'Credits', style);

    this.input.onDown.add(this.onDown, this);
  },

  update: function () {
  },

  onDown: function () {
    this.game.state.start(playerState.currentLevel); // jshint ignore:line
  }
};

},{}],"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\states\\preloader.js":[function(require,module,exports){
var Preloader = function (game) {
  game = null;
  this.asset = null;
  this.ready = false;
};

module.exports = Preloader;

Preloader.prototype = {

  preload: function () {
    this.asset = this.add.sprite(640, 360, 'preloader');
    this.asset.anchor.setTo(0.5, 0.5);

    this.load.onLoadComplete.addOnce(this.onLoadComplete, this);
    this.load.setPreloadSprite(this.asset);
    this.load.image('testsprite', 'assets/test2.png');
	this.load.spritesheet('core', 'assets/coreSheet.png', 64, 64); 
	this.load.spritesheet('thruster', 'assets/thrusterSheet.png', 64, 64);
	this.load.spritesheet('gun', 'assets/gunSheet.png', 64, 64);
	this.load.image('shield', 'assets/shield.png');
	this.load.image('solarPanel', 'assets/solarPanel.png');
	this.load.image('hacker', 'assets/hacker.png');
	this.load.spritesheet('hackable1', 'assets/hackable1.png', 256, 256);
    this.load.atlasJSONHash('connections', 'assets/connections.png', 'assets/connections.json');
	this.load.image('asteroid', 'assets/asteroid.png');
    this.load.atlasJSONHash('connections', 'assets/connections.png', 'assets/connections.json');
	this.load.image('earthNight', 'assets/bg_earthNightSmall.jpg');
    this.load.physics('module_physics', 'assets/module_physics.json');
    this.load.text('level_one', 'assets/level_one.json');
  },

  create: function () {
    this.asset.cropEnabled = false;
  },

  update: function () {
    if (!!this.ready) {
      //this.game.state.start('Menu');
      this.game.state.start(playerState.currentLevel); // jshint ignore:line
    }
  },

  onLoadComplete: function () {
    this.ready = true;
  }
};

},{}],"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\states\\splash.js":[function(require,module,exports){
var Splash = function () {
};

module.exports = Splash;

Splash.prototype = {
  create: function () {
  }
};
},{}],"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\ui\\ProgressBar.js":[function(require,module,exports){
//NOTE: DON'T USE this code to create a ProgressBar. Instead, use the UIBuilder object and call buildProgressBar

var ProgressBar = function(setType, setMaxValue, setGraphics, setRenderables) {
	this.type = setType; //Two types, "growing" (starts at 0, triggers event when full) 
						 //and "shrinking" (starts full, triggers at 0)
	this.bgBorderSize = 2;			//default size of background border
	this.bgBorderColor = 0xAAAAAA;	//default color of background border
	this.bgColor = 0x888888;		//default color of background
	this.paddingHoriz = 5;			//default sum of padding on left and right side inner value bar
	this.paddingVert = 5;			//default sum (i.e. half on each side) of vertical padding of inner value bar
	this.valueBorderSize = 1;		//default size of value border
	this.valueBorderColor = 0x8888FF; //default color of value border
	this.valueColor = 0x000099;		//default color of inner value bar
	this.x = null;
	this.y = null;
	this.width = null;
	this.height = null;
	this.maxValue = setMaxValue;
	this.graphics = setGraphics; //store graphics class (used to draw bar)
	this.renderables = setRenderables;
	
	this.onEvent = function() {}; //overwrite this function to make whatever you want happen when progressBar reaches limit
	
	//switch(this.type) {
	//case 'growing' : 
	if(setType === 'growing') {
		this.value = 0;
		//tryTrigger is called automatically when you add/subtract value, and will trigger the onEvent() function
		this.tryTrigger = function() {
			if(this.value >= this.maxValue) {
				this.onEvent();
			}
		};
		//break;
	}
	else if(setType === 'shrinking') {
	//case 'shrinking' :
		this.value = this.maxValue;
		this.tryTrigger = function() {
			if(this.value <= 0) {
				this.onEvent();
			}
		};
	//}
	}
};

ProgressBar.prototype.constructor = ProgressBar;

ProgressBar.prototype.destroy = function() {
	this.graphics.clear();
	this.renderables.unsubscribe(this);
};

//To subtract value, just use negative numbers as argument i.e. foo.addValue(-5);
ProgressBar.prototype.addValue = function (addThis) {
	this.value += addThis;
	if(this.value > this.maxValue) {
		this.value = this.maxValue;
	}
	if(this.value < 0) {
		this.value = 0;
	}
	this.tryTrigger();
};

//Sets the location where progress bar is rendered
ProgressBar.prototype.setLocation = function(setX, setY) {
	this.x = setX;
	this.y = setY;
};

//Sets the size of the progress bar
ProgressBar.prototype.setSize = function(setWidth, setHeight) {
	this.width = setWidth;
	this.height = setHeight;
};

ProgressBar.prototype.setStyle = function(bgBorderSize, bgBorderColor, bgColor, paddingHoriz, paddingVert, valueBorderSize, valueBorderColor, valueColor) {
	this.bgBorderSize = bgBorderSize;
	this.bgBorderColor = bgBorderColor;
	this.bgColor = bgColor;
	this.paddingHoriz = paddingHoriz;
	this.paddingVert = paddingVert;
	this.valueBorderSize = valueBorderSize;
	this.valueBorderColor = valueBorderColor;
	this.valueColor = valueColor;
};

//update for progress bar, called just before drawing progress bar
//Overwrite this function if desired
ProgressBar.prototype.update = function() {};

//Renders progressBar
ProgressBar.prototype.render = function() {
	this.update();
	this.graphics.clear();
	//Draw background of bar
	this.graphics.lineStyle(this.bgBorderSize, this.bgBorderColor, 1); //sets border color and size
	this.graphics.beginFill(this.bgColor); //sets color of background fill
	this.graphics.drawRect(this.x-this.width/2, this.y-this.height/2, this.width, this.height);
	this.graphics.endFill();
	//Draw value of bar
	var percentage = this.value / this.maxValue;
	var barWidth = this.width - this.paddingHoriz;
	var barHeight = this.height - this.paddingVert;
	this.graphics.lineStyle(this.valueBorderSize, this.valueBorderColor, 1);
	this.graphics.beginFill(this.valueColor);
	this.graphics.drawRect(this.x-(barWidth/2), this.y-(barHeight/2), barWidth*percentage, barHeight);
	this.graphics.endFill();
};

module.exports = ProgressBar;
},{}],"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\ui\\UIBuilder.js":[function(require,module,exports){
var ProgressBar = require('./ProgressBar');

var UIBuilder = function(setGameState, setRenderables) {
	//Ensure that cannot create multiple instances of this class
	if(UIBuilder.prototype.exists) {
		return UIBuilder.prototype.existingReference;
	}
	
	this.gameState = setGameState;
	this.renderables = setRenderables;
	//Create and store a graphics object (used for stuff like drawing rectangles)
	UIBuilder.prototype.exists = true;
	UIBuilder.prototype.existingReference = this;
};

UIBuilder.prototype.constructor = UIBuilder;
//These var's help create the singleton functionality
UIBuilder.prototype.exists = false;
UIBuilder.prototype.existingReference = null;

//Use this function to create a progress bar
//Usage: type: can be "growing" or "shrinking", this will effect if bar starts at 0 and goes up or vis versa
//		 maxValue: sets the max value of the progress bar, i.e. using 100 creates a bar from 0 to 100
//		 x,y: sets location
//		 DON'T FORGET to overwrite the onEvent() function for the progress bar after creating it
//			-onEvent() is automatically called when bar fills/shrinks past limit (depending on bar type)
UIBuilder.prototype.buildProgressBar = function(type, x, y, width, height, maxValue) {
	//create and format new prog bar
	var graphics = this.gameState.game.add.graphics(0,0);
	var newProgBar = new ProgressBar(type, maxValue, graphics, this.renderables);
	newProgBar.setLocation(x,y);
	newProgBar.setSize(width, height);
	//subscribe to 'renderables' so that render() is called automatically
	this.renderables.subscribe(newProgBar);
	return newProgBar;
};

module.exports = UIBuilder;
},{"./ProgressBar":"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\ui\\ProgressBar.js"}],"C:\\Users\\Zachary\\Documents\\!cmpm20\\AboveTheIronCurtain\\src\\js\\utils.js":[function(require,module,exports){
/*
Collection of utility functions.
*/

var Utils = {
    containsObject: function(obj, list) {
        var i;
        for (i = 0; i < list.length; i++) {
            if (list[i] === obj) {
                return true;
            }
        }

        return false;
    },
    distance: function(x1, y1, x2, y2) {
       return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
    }
};

module.exports = Utils;
},{}]},{},["./src/js/main.js"])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlc1xcYnJvd3NlcmlmeVxcbm9kZV9tb2R1bGVzXFxicm93c2VyLXBhY2tcXF9wcmVsdWRlLmpzIiwic3JjL2pzL21haW4uanMiLCJzcmMvanMvZWZmZWN0cy9CaW5hcnlQYXJ0aWNsZS5qcyIsInNyYy9qcy9lZmZlY3RzL0VtaXR0ZXIuanMiLCJzcmMvanMvZW50aXRpZXMvSGFja2FibGUuanMiLCJzcmMvanMvZW50aXRpZXMvTW9kdWxlLmpzIiwic3JjL2pzL2VudGl0aWVzL01vZHVsZUJ1aWxkZXIuanMiLCJzcmMvanMvZW50aXRpZXMvY3ViZS5qcyIsInNyYy9qcy9lbnRpdGllcy9jdWJlX2dyb3VwLmpzIiwic3JjL2pzL2VudGl0aWVzL2VuZW15X2FpLmpzIiwic3JjL2pzL2VudGl0aWVzL21vdXNlLmpzIiwic3JjL2pzL2Z1bmN0aW9uQWNjZXNzL1JlbmRlcmFibGVzLmpzIiwic3JjL2pzL2xpYnMvamF2YXNjcmlwdC1hc3Rhci9hc3Rhci5qcyIsInNyYy9qcy9zdGF0ZXMvYm9vdC5qcyIsInNyYy9qcy9zdGF0ZXMvZ2FtZS5qcyIsInNyYy9qcy9zdGF0ZXMvbWVudS5qcyIsInNyYy9qcy9zdGF0ZXMvcHJlbG9hZGVyLmpzIiwic3JjL2pzL3N0YXRlcy9zcGxhc2guanMiLCJzcmMvanMvdWkvUHJvZ3Jlc3NCYXIuanMiLCJzcmMvanMvdWkvVUlCdWlsZGVyLmpzIiwic3JjL2pzL3V0aWxzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgZ2FtZSA9IG5ldyBQaGFzZXIuR2FtZSh3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2gsIFBoYXNlci5BVVRPLCAnYXRpYy1nYW1lJyk7XHJcblxyXG53aW5kb3cucGxheWVyU3RhdGUgPSB7XHJcbiAgICBjdXJyZW50TGV2ZWw6ICdHYW1lJ1xyXG59O1xyXG5cclxuZ2FtZS5zdGF0ZS5hZGQoJ0Jvb3QnLCByZXF1aXJlKCcuL3N0YXRlcy9ib290JykpO1xyXG5nYW1lLnN0YXRlLmFkZCgnU3BsYXNoJywgcmVxdWlyZSgnLi9zdGF0ZXMvc3BsYXNoJykpO1xyXG5nYW1lLnN0YXRlLmFkZCgnUHJlbG9hZGVyJywgcmVxdWlyZSgnLi9zdGF0ZXMvcHJlbG9hZGVyJykpO1xyXG5nYW1lLnN0YXRlLmFkZCgnTWVudScsIHJlcXVpcmUoJy4vc3RhdGVzL21lbnUnKSk7XHJcbmdhbWUuc3RhdGUuYWRkKCdHYW1lJywgcmVxdWlyZSgnLi9zdGF0ZXMvZ2FtZScpKTtcclxuXHJcbmdhbWUuc3RhdGUuc3RhcnQoJ0Jvb3QnKTsiLCJ2YXIgQmluYXJ5UGFydGljbGUgPSBmdW5jdGlvbihnYW1lLCB0YXJnZXRPYmosIHgsIHksIHRhck9mZnNldFgsIHRhck9mZnNldFkpIHtcclxuXHR2YXIgc3R5bGUgPSB7Zm9udDogJzIwcHggQXZhbnQgR2FyZGUnLCBmaWxsOiAnI0VFRUUzMycsIGFsaWduOiAnY2VudGVyJ307XHJcblx0dmFyIGJ5dGVTeW1ib2wgPSBNYXRoLnJhbmRvbSgpID49IDAuNSA/ICcxJyA6ICcwJztcclxuXHRQaGFzZXIuVGV4dC5jYWxsKHRoaXMsIGdhbWUsIHgsIHksIGJ5dGVTeW1ib2wsIHN0eWxlKTtcclxuXHRnYW1lLmFkZC5leGlzdGluZyh0aGlzKTtcclxuXHR0aGlzLnRhcmdldE9iaiA9IHRhcmdldE9iajtcclxuXHR0aGlzLnNwZWVkID0gMy42O1xyXG5cdHRoaXMudGFyT2Zmc2V0WCA9IHRhck9mZnNldFg7XHJcblx0dGhpcy50YXJPZmZzZXRZID0gdGFyT2Zmc2V0WTtcclxuXHRjb25zb2xlLmxvZygncmFuJyk7XHJcbn07XHJcblxyXG5CaW5hcnlQYXJ0aWNsZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFBoYXNlci5UZXh0LnByb3RvdHlwZSk7XHJcbkJpbmFyeVBhcnRpY2xlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEJpbmFyeVBhcnRpY2xlO1xyXG5cclxuQmluYXJ5UGFydGljbGUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdC8vR2V0IGRlbHRhIHZlY3RvciB0byB0YXJnZXQgb2JqZWN0XHJcblx0dmFyIGRlbHRhID0gW3RoaXMudGFyZ2V0T2JqLnggKyB0aGlzLnRhck9mZnNldFggLSB0aGlzLngsIHRoaXMudGFyZ2V0T2JqLnkgKyB0aGlzLnRhck9mZnNldFkgLSB0aGlzLnldO1xyXG5cdC8vR2V0IGRpc3RhbmNlIGFuZCBjaGVjayBpZiB3ZSd2ZSByZWFjaGVkIHRhcmdldCBkaXN0YW5jZVxyXG5cdHZhciBkaXN0ID0gTWF0aC5zcXJ0KE1hdGgucG93KGRlbHRhWzBdLCAyKSArIE1hdGgucG93KGRlbHRhWzFdLCAyKSk7XHJcblx0aWYoZGlzdCA8PSB0aGlzLnNwZWVkKSB7XHJcblx0XHR0aGlzLmRlc3Ryb3koKTtcclxuXHRcdHJldHVybjtcclxuXHR9XHJcblx0Ly9Ob3JtYWxpemUgZGVsdGEgdmVjdG9yXHJcblx0ZGVsdGEgPSBbZGVsdGFbMF0vZGlzdCwgZGVsdGFbMV0vZGlzdF07XHJcblx0Ly9VcGRhdGUgcG9zaXRpb25cclxuXHR0aGlzLnggPSB0aGlzLnggKyB0aGlzLnNwZWVkKmRlbHRhWzBdO1xyXG5cdHRoaXMueSA9IHRoaXMueSArIHRoaXMuc3BlZWQqZGVsdGFbMV07XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEJpbmFyeVBhcnRpY2xlOyIsInZhciBCaW5hcnlQYXJ0aWNsZSA9IHJlcXVpcmUoJy4vQmluYXJ5UGFydGljbGUnKTtcclxuXHJcbnZhciBFbWl0dGVyID0gZnVuY3Rpb24oZ2FtZVN0YXRlKSB7XHJcblx0dGhpcy5nYW1lU3RhdGUgPSBnYW1lU3RhdGU7XHJcbn07XHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEVtaXR0ZXI7XHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5lbWl0QmluYXJ5ID0gZnVuY3Rpb24gKHRhcmdldE9iaiwgeCwgeSwgc3BhY2luZykge1xyXG5cdHZhciBvZmZzZXRYID0gKE1hdGgucmFuZG9tKCktMC41KSpzcGFjaW5nO1xyXG5cdHZhciBvZmZzZXRZID0gKE1hdGgucmFuZG9tKCktMC41KSpzcGFjaW5nO1xyXG5cdHZhciBuZXdQYXJ0aWNsZSA9IG5ldyBCaW5hcnlQYXJ0aWNsZSh0aGlzLmdhbWVTdGF0ZS5nYW1lLCB0YXJnZXRPYmosIHgsIHksIG9mZnNldFgsIG9mZnNldFkpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBFbWl0dGVyOyIsIi8qXHJcbkRlZmluZXMgYSBoYWNrYWJsZSBvYmplY3QuXHJcbiovXHJcblxyXG52YXIgSGFja2FibGUgPSBmdW5jdGlvbiAoZ2FtZVN0YXRlLCB4LCB5LCBzcHJpdGUsIGhhY2tEaXN0YW5jZSkge1xyXG4gICBQaGFzZXIuU3ByaXRlLmNhbGwodGhpcywgZ2FtZVN0YXRlLmdhbWUsIHgsIHksIHNwcml0ZSk7XHJcbiAgIGdhbWVTdGF0ZS5nYW1lLmFkZC5leGlzdGluZyh0aGlzKTtcclxuXHQvL3N0b3JlIGdhbWVTdGF0ZVxyXG5cdHRoaXMuZ2FtZVN0YXRlID0gZ2FtZVN0YXRlO1xyXG5cdC8vc2V0IGlzSGFja2VkIHRvIGZhbHNlXHJcblx0dGhpcy5pc0hhY2tlZCA9IGZhbHNlO1xyXG5cdC8vYWRkIGhhY2tCYXJcclxuXHR0aGlzLmhhY2tCYXIgPSBnYW1lU3RhdGUudWlCdWlsZGVyLmJ1aWxkUHJvZ3Jlc3NCYXIoJ2dyb3dpbmcnLCAxNTAwLCAxMjAwLCAxMDAsIDEwLCAgMjAwKTtcclxuXHR0aGlzLmhhY2tCYXIuc2V0U3R5bGUoMCwgMHhGRkZGRkYsIDB4MzYzNjM2LCAwLCAwLCAwLCAweEZGRkZGRiwgMHgyMDIwQ0MpO1xyXG5cdHRoaXMuaGFja0Jhci5oYWNrYWJsZSA9IHRoaXM7XHJcblx0dGhpcy5oYWNrQmFyLm9uRXZlbnQgPSBmdW5jdGlvbigpIHtcclxuXHRcdHRoaXMuaGFja2FibGUuZnJhbWUgPSAxO1xyXG5cdFx0dGhpcy5oYWNrYWJsZS5pc0hhY2tlZCA9IHRydWU7XHJcblx0XHR0aGlzLmRlc3Ryb3koKTtcclxuXHR9O1xyXG5cdHRoaXMudGFnID0gJ25ldXRyYWxPYmonO1x0Ly9UYWcgaXMgdXNlZCB0byBpZGVudGlmeSBvYmplY3QgdHlwZSBkdXJpbmcgY29sbGlzaW9uIGNoZWNraW5nXHJcblx0dGhpcy5oYWNrRGlzdGFuY2UgPSBoYWNrRGlzdGFuY2U7XHJcblx0dmFyIHNjYWxlID0gMC41O1xyXG4gICB0aGlzLnNjYWxlLnggPSBzY2FsZTtcclxuICAgdGhpcy5zY2FsZS55ID0gc2NhbGU7XHJcbiAgIHRoaXMuYW5jaG9yLnNldFRvKDAuNSwgMC41KTtcclxuICAgZ2FtZVN0YXRlLmdhbWUucGh5c2ljcy5wMi5lbmFibGUodGhpcyk7XHJcbiAgIHRoaXMuYm9keS5vbkJlZ2luQ29udGFjdC5hZGQodGhpcy5jdWJlQ29sbGlkZSwgdGhpcyk7XHJcbiAgIHRoaXMuYm9keS5kYW1waW5nID0gMC45O1xyXG4gICB0aGlzLmJvZHkuYW5ndWxhckRhbXBpbmcgPSAwLjk7XHJcbn07XHJcblxyXG5IYWNrYWJsZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFBoYXNlci5TcHJpdGUucHJvdG90eXBlKTtcclxuSGFja2FibGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSGFja2FibGU7XHJcblxyXG4vKipcclxuICogQXV0b21hdGljYWxseSBjYWxsZWQgYnkgV29ybGQudXBkYXRlXHJcbiAqL1xyXG5IYWNrYWJsZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKSB7XHJcblx0dGhpcy5oYWNrQmFyLnNldExvY2F0aW9uKHRoaXMueCwgdGhpcy55IC0gNzApO1xyXG5cdC8vY2hlY2sgaWYgZ2V0dGluZyBoYWNrZWRcclxuXHRpZighdGhpcy5pc0hhY2tlZCkge1xyXG5cdFx0aWYodGhpcy5nYW1lU3RhdGUucGxheWVyLmhhY2tlck1vZHVsZXMubGVuZ3RoID4gMCkge1xyXG5cdFx0XHR2YXIgZGlzdDtcclxuXHRcdFx0dmFyIGhhY2tlcjtcclxuXHRcdFx0Ly9Mb29wIHRocm91Z2ggYWxsIGhhY2tlciBtb2R1bGVzIG9uIHRoZSBwbGF5ZXIncyBjdWJzYXRcclxuXHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMuZ2FtZVN0YXRlLnBsYXllci5oYWNrZXJNb2R1bGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0aGFja2VyID0gdGhpcy5nYW1lU3RhdGUucGxheWVyLmhhY2tlck1vZHVsZXNbaV07XHJcblx0XHRcdFx0ZGlzdCA9IE1hdGguc3FydCggTWF0aC5wb3codGhpcy54IC0gaGFja2VyLmN1YmUueCwgMikgKyBNYXRoLnBvdyh0aGlzLnkgLSBoYWNrZXIuY3ViZS55LCAyKSApO1xyXG5cdFx0XHRcdGlmKGRpc3QgPCB0aGlzLmhhY2tEaXN0YW5jZSkge1xyXG5cdFx0XHRcdFx0Ly9JZiBoYWNrZXIgaXMgaW4gcmFuZ2UsIGluY3JlYXNlIGhhY2sgdmFsdWUgYW5kIHRyeSB0byBlbWl0IGJpbmFyeSBwYXJ0aWNsZVxyXG5cdFx0XHRcdFx0dGhpcy5oYWNrQmFyLmFkZFZhbHVlKDAuMDUpO1xyXG5cdFx0XHRcdFx0aGFja2VyLmNvdW50Kys7XHJcblx0XHRcdFx0XHRpZihoYWNrZXIuY291bnQgPj0gaGFja2VyLmN5Y2xlKSB7XHJcblx0XHRcdFx0XHRcdGhhY2tlci5jb3VudCA9IDA7XHJcblx0XHRcdFx0XHRcdHRoaXMuZ2FtZVN0YXRlLkJpbmFyeUVtaXR0ZXIuZW1pdEJpbmFyeSh0aGlzLCBoYWNrZXIuY3ViZS54LCBoYWNrZXIuY3ViZS55LCA2MCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG59O1xyXG5cclxuXHJcbkhhY2thYmxlLnByb3RvdHlwZS5jdWJlQ29sbGlkZSA9IGZ1bmN0aW9uKG90aGVyKSB7XHJcbi8qICAgaWYgKHRoaXMuZ3JvdXAgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgIH1cclxuICAgdGhpcy5ncm91cC5oYW5kbGVDb2xsaXNpb24odGhpcywgb3RoZXIuc3ByaXRlKTsqL1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBIYWNrYWJsZTsiLCIvL0Rvbid0IHVzZSB0aGlzIGZ1bmN0aW9uIHRvIGNyZWF0ZSBtb2R1bGVzLCBpbnN0ZWFkIHVzZSBtb2R1bGVCdWlsZGVyKClcclxudmFyIE1vZHVsZSA9IGZ1bmN0aW9uKHNldFR5cGUsIHNldEN1YmUpIHtcclxuXHR0aGlzLnR5cGUgPSBzZXRUeXBlO1xyXG5cdHRoaXMuY3ViZSA9IHNldEN1YmU7XHJcbiAgIHNldEN1YmUubW9kdWxlID0gdGhpcztcclxufTtcclxuXHJcbk1vZHVsZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNb2R1bGU7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE1vZHVsZTsiLCJ2YXIgQ3ViZSA9IHJlcXVpcmUoJy4vY3ViZScpO1xyXG52YXIgTW9kdWxlID0gcmVxdWlyZSgnLi9Nb2R1bGUnKTtcclxuXHJcbnZhciB0aHJ1c3RBbXQgPSA1MDAwO1xyXG5cclxuLy9Vc2UgdGhpcyB0byBjcmVhdGUgYSBtb2R1bGVCdWlsZGVyLSBvbmx5IG5lZWQgdG8gY3JlYXRlIG9uZSBpbnN0YW5jZSBvZiBpdFxyXG52YXIgTW9kdWxlQnVpbGRlciA9IGZ1bmN0aW9uKHNldEdhbWVTdGF0ZSwgc2V0Q29sR3JvdXApIHtcclxuXHQvL0Vuc3VyZSB0aGF0IGNhbm5vdCBjcmVhdGUgbXVsdGlwbGUgaW5zdGFuY2VzIG9mIHRoaXMgY2xhc3NcclxuXHRpZihNb2R1bGVCdWlsZGVyLnByb3RvdHlwZS5leGlzdHMpIHtcclxuXHRcdHJldHVybiBNb2R1bGVCdWlsZGVyLnByb3RvdHlwZS5leGlzdGluZ1JlZmVyZW5jZTtcclxuXHR9XHJcblx0XHRcclxuXHR0aGlzLmdhbWVTdGF0ZSA9IHNldEdhbWVTdGF0ZTtcclxuICAgdGhpcy5jb2xHcm91cCA9IHNldENvbEdyb3VwO1xyXG5cdC8vIHRoaXMuY29yZUV4aXN0cyA9IGZhbHNlO1x0Ly9yZWNvcmRzIGlmIGNvcmUgaGFzIGJlZW4gY3JlYXRlZFxyXG5cdHRoaXMuY29yZSA9IG51bGw7XHRcdFx0Ly9zdG9yZXMgY29yZSB3aGVuIGl0IGlzIGNyZWF0ZWRcclxuXHQvL3ZhciBzcGFjZSA9IHRoaXMuZ2FtZVN0YXRlLmlucHV0LmtleWJvYXJkLmFkZEtleShQaGFzZXIuS2V5Ym9hcmQuU1BBQ0VCQVIpO1xyXG5cdE1vZHVsZUJ1aWxkZXIucHJvdG90eXBlLmV4aXN0cyA9IHRydWU7XHJcblx0TW9kdWxlQnVpbGRlci5wcm90b3R5cGUuZXhpc3RpbmdSZWZlcmVuY2UgPSB0aGlzO1xyXG59O1xyXG5cclxuTW9kdWxlQnVpbGRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNb2R1bGVCdWlsZGVyO1xyXG5cclxuLy9UaGVzZSB2YXIncyBoZWxwIGNyZWF0ZSB0aGUgc2luZ2xldG9uIGZ1bmN0aW9uYWxpdHlcclxuTW9kdWxlQnVpbGRlci5wcm90b3R5cGUuZXhpc3RzID0gZmFsc2U7XHJcbk1vZHVsZUJ1aWxkZXIucHJvdG90eXBlLmV4aXN0aW5nUmVmZXJlbmNlID0gbnVsbDtcclxuXHJcbi8qKiBNb2R1bGUgZnVuY3Rpb25zICoqL1xyXG5mdW5jdGlvbiBzb2xhclBhbmVsR2l2ZVRhcmdldCh0YXJnZXQpIHtcclxuICAgaWYgKHRoaXMuY3ViZS5ncm91cCAmJiB0YXJnZXQuY3ViZS5ncm91cCAmJiB0aGlzLmN1YmUuZ3JvdXAgIT09IHRhcmdldC5jdWJlLmdyb3VwIHx8IHRoaXMgPT09IHRhcmdldCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgIH1cclxuICAgdmFyIG91ckdyb3VwID0gdGhpcy5jdWJlLmdyb3VwO1xyXG4gICB2YXIgbmV3Q29ubmVjdGlvbiA9IHtzdGFydDogdGhpcy5jdWJlLCBlbmQ6IHRhcmdldC5jdWJlfTtcclxuICAgdGhpcy5jdWJlLm15Q29ubmVjdGlvbiA9IG5ld0Nvbm5lY3Rpb247XHJcbiAgIHRhcmdldC5jdWJlLm15Q29ubmVjdGlvbiA9IG5ld0Nvbm5lY3Rpb247XHJcbiAgIG91ckdyb3VwLmRpc3BsYXlDb25uZWN0aW9uKHRoaXMuY3ViZS5teUNvbm5lY3Rpb24pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzb2xhclBhbmVsTW91c2VPdmVyKCkge1xyXG4gICBpZiAoIXRoaXMuY3ViZS5teUNvbm5lY3Rpb24gfHwgIXRoaXMuY3ViZS5ncm91cCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgIH1cclxuICAgdGhpcy5jdWJlLmdyb3VwLmRpc3BsYXlDb25uZWN0aW9uKHRoaXMuY3ViZS5teUNvbm5lY3Rpb24pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzb2xhclBhbmVsT25SZW1vdmUoKSB7XHJcbiAgIGlmICghdGhpcy5jdWJlLm15Q29ubmVjdGlvbiB8fCAhdGhpcy5jdWJlLm15Q29ubmVjdGlvbi5lbmQpIHtcclxuICAgICAgY29uc29sZS5sb2coJ3NvbGFyUGFuZWxPblJlbW92ZSgpIGhhZCBhbiBlcnJvcicpO1xyXG4gICB9XHJcbiAgIHRoaXMuY3ViZS5teUNvbm5lY3Rpb24uZW5kLm15Q29ubmVjdGlvbiA9IHVuZGVmaW5lZDtcclxuICAgdGhpcy5jdWJlLm15Q29ubmVjdGlvbiA9IHVuZGVmaW5lZDtcclxufVxyXG5cclxuZnVuY3Rpb24gYmVnaW5BY3QoKSB7XHJcbiAgIHRoaXMuYWN0ID0gdHJ1ZTtcclxuICAgdGhpcy5jdWJlLmZyYW1lID0gMTtcclxufVxyXG5cclxuZnVuY3Rpb24gZW5kQWN0KCkge1xyXG4gICB0aGlzLmFjdCA9IGZhbHNlO1xyXG4gICB0aGlzLmN1YmUuZnJhbWUgPSAwO1xyXG59XHJcblxyXG5mdW5jdGlvbiB0aHJ1c3RlclVwZGF0ZSgpIHtcclxuICAgaWYgKHRoaXMuaGFsdFRpbWUgJiYgdGhpcy5oYWx0VGltZSA+IDApIHtcclxuICAgICAgdGhpcy5oYWx0VGltZSAtPSB0aGlzLmN1YmUuZ2FtZS50aW1lLmVsYXBzZWQ7XHJcbiAgICAgIHRoaXMuY3ViZS5mcmFtZSA9IDA7XHJcbiAgIH0gZWxzZSBpZiAodGhpcy5hY3QgJiYgdGhpcy5jdWJlLm15Q29ubmVjdGlvbikge1xyXG4gICAgICB0aGlzLmN1YmUuYm9keS5mb3JjZS54ID0gdGhydXN0QW10ICogTWF0aC5jb3ModGhpcy5jdWJlLnJvdGF0aW9uIC0gTWF0aC5QSSAvIDIpO1xyXG4gICAgICB0aGlzLmN1YmUuYm9keS5mb3JjZS55ID0gdGhydXN0QW10ICogTWF0aC5zaW4odGhpcy5jdWJlLnJvdGF0aW9uIC0gTWF0aC5QSSAvIDIpO1xyXG5cdCAgaWYodGhpcy5jdWJlLmZyYW1lID09PSAxKSB7XHJcblx0XHR0aGlzLmN1YmUuZnJhbWUgPSAyO1xyXG5cdCAgfVxyXG5cdCAgZWxzZSB7XHJcblx0XHR0aGlzLmN1YmUuZnJhbWUgPSAxO1xyXG5cdCAgfVxyXG4gICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHRocnVzdGVySGFsdCgpIHtcclxuICAgdGhpcy5oYWx0VGltZSA9IDE1MDA7XHJcbn1cclxuXHJcbi8qKiBFbmQgbW9kdWxlIGZ1bmN0aW9ucyAqKi9cclxuXHJcbi8vY2FsbCB0aGlzIGZ1bmN0aW9uIGZyb20gTW9kdWxlQnVpbGRlciB0byBjb25zdHJ1Y3QgbW9kdWxlc1xyXG4vL1RZUEVTOiAnY29yZScgJ3NoaWVsZCcgJ3RocnVzdGVyJyAnc29sYXJQYW5uZWwnICdoYWNrZXInXHJcbk1vZHVsZUJ1aWxkZXIucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24odHlwZSwgeCwgeSwgZm9yUGxheWVyKSB7XHJcblx0Ly9DaGVjayBpZiBjb3JlIGhhcyBiZWVuIGNyZWF0ZWRcclxuXHRpZih0eXBlID09PSAnY29yZScgJiYgdGhpcy5jb3JlRXhpc3RzKSB7XHJcblx0XHQvL2lmIHNvLCByZXR1cm4gZXhpc3RpbmcgY29yZSBiL2MgaXMgc2luZ2xldG9uXHJcblx0XHQvL2IvYyBvZiB0aGlzLCBjYW4gY2FsbCBNb2R1bGVCdWlsZGVyLmJ1aWxkKCdjb3JlJykgdG8gYWNjZXNzIHJlZmVyZW5jZSB0byBleGlzdGluZyBjb3JlXHJcblx0XHRyZXR1cm4gdGhpcy5jb3JlO1xyXG5cdH1cclxuXHRcclxuXHQvL0NyZWF0ZSBjdWJlIG9iamVjdCB0byBiZSBzdG9yZWQgd2l0aGluIG1vZHVsZVxyXG5cdC8vU3ByaXRlIG5hbWVzIGZvciBtb2R1bGVzIGFyZSBkaXJlY3RseSBtYXBwZWQgdG8gbW9kdWxlIG5hbWVzLCBzbyBqdXN0IHBhc3MgJ3R5cGUnIGFzIHNwcml0ZSBuYW1lXHJcblx0dmFyIG5ld0N1YmUgPSBuZXcgQ3ViZSh0aGlzLmdhbWVTdGF0ZSwgeCwgeSwgdHlwZSk7XHJcbiAgICB2YXIgc2NhbGUgPSAwLjU7XHJcbiAgICBuZXdDdWJlLm5hbWUgPSB0aGlzLmdhbWVTdGF0ZS5kZWJ1Z051bSsrO1xyXG4gICAgbmV3Q3ViZS5zY2FsZS5zZXRUbyhzY2FsZSwgc2NhbGUpO1xyXG4gICAgbmV3Q3ViZS5hbmNob3Iuc2V0VG8oMC41LCAwLjUpO1xyXG4gICAgdGhpcy5nYW1lU3RhdGUuZ2FtZS5waHlzaWNzLnAyLmVuYWJsZShuZXdDdWJlKTtcclxuICAgIG5ld0N1YmUuYm9keS5vbkJlZ2luQ29udGFjdC5hZGQobmV3Q3ViZS5jdWJlQ29sbGlkZSwgbmV3Q3ViZSk7XHJcblx0bmV3Q3ViZS5ib2R5LmNvbGxpZGVXb3JsZEJvdW5kcyA9IGZhbHNlO1xyXG4gICAgbmV3Q3ViZS5ib2R5LmRhbXBpbmcgPSAwLjk7XHJcbiAgICBuZXdDdWJlLmJvZHkuYW5ndWxhckRhbXBpbmcgPSAwLjk7XHJcbiAgICBpZiAoIXRoaXMuZ2FtZVN0YXRlLnJvb3RTcGF3bmVkKSB7XHJcbiAgICAgICBuZXdDdWJlLnJvb3QgPSB0cnVlO1xyXG4gICAgICAgdGhpcy5nYW1lU3RhdGUucm9vdFNwYXduZWQgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgdmFyIGNJbmRpY2F0b3IgPSB0aGlzLmdhbWVTdGF0ZS5hZGQuc3ByaXRlKDAsIDAsICdjb25uZWN0aW9ucycsICdjb25uZWN0aW9uX2xpbmUucG5nJyk7XHJcbiAgIGNJbmRpY2F0b3IuYW5jaG9yLnNldFRvKDAuNSwgMC41KTtcclxuICAgY0luZGljYXRvci5hbmltYXRpb25zLmFkZCgnZW5kJywgWydjb25uZWN0aW9uX2VuZC5wbmcnXSwgNjAsIHRydWUpO1xyXG4gICBjSW5kaWNhdG9yLmFuaW1hdGlvbnMuYWRkKCdsaW5lJywgWydjb25uZWN0aW9uX2xpbmUucG5nJ10sIDYwLCB0cnVlKTtcclxuICAgY0luZGljYXRvci5hbmltYXRpb25zLmFkZCgncmlnaHQnLCBbJ2Nvbm5lY3Rpb25fcmlnaHQucG5nJ10sIDYwLCB0cnVlKTtcclxuICAgbmV3Q3ViZS5hZGRDaGlsZChjSW5kaWNhdG9yKTtcclxuICAgbmV3Q3ViZS5jSW5kaWNhdG9yID0gY0luZGljYXRvcjtcclxuICAgY0luZGljYXRvci5hbHBoYSA9IDA7XHJcblx0XHJcblx0Ly9DcmVhdGUgbW9kdWxlIHRvIHdyYXAgYXJvdW5kIGN1YmUgY2xhc3NcclxuXHR2YXIgbmV3TW9kdWxlID0gbmV3IE1vZHVsZSh0eXBlLCBuZXdDdWJlKTtcclxuXHRcdFxyXG5cdC8vVE9ETzogZWRpdCBzcGVjaWFsIG1vZHVsZSBhdHJpYnV0ZXMgYmFzZWQgb24gJ3R5cGUnXHJcblx0aWYodHlwZSA9PT0gJ2hhY2tlcicpIHtcclxuXHRcdG5ld01vZHVsZS5jeWNsZSA9IDY7XHJcblx0XHRuZXdNb2R1bGUuY291bnQgPSAwO1xyXG5cdH1cclxuXHRcclxuXHQvL1N0b3JlIG1vZHVsZSBpZiBpdCBpcyBjb3JlXHJcblx0aWYodHlwZSA9PT0gJ2NvcmUnKVxyXG5cdHtcclxuXHRcdG5ld01vZHVsZS5jdWJlLmFuaW1hdGlvbnMuYWRkKCdjb3JlJywgWzAsMSwyXSwgMjAsIHRydWUpO1xyXG5cdFx0bmV3TW9kdWxlLmN1YmUuYW5pbWF0aW9ucy5wbGF5KCdjb3JlJyk7XHJcblx0XHR0aGlzLmNvcmUgPSBuZXdNb2R1bGU7XHJcblx0XHR0aGlzLmNvcmVFeGlzdHMgPSB0cnVlO1xyXG5cdH1cclxuICAgLy8gc29sYXIgcGFuZWwgdGVzdGluZ1xyXG4gICBpZiAodHlwZSA9PT0gJ3NvbGFyUGFuZWwnKSB7XHJcbiAgICAgIG5ld01vZHVsZS5naXZlVGFyZ2V0ID0gc29sYXJQYW5lbEdpdmVUYXJnZXQ7XHJcbiAgICAgIG5ld01vZHVsZS5tb3VzZU92ZXIgPSBzb2xhclBhbmVsTW91c2VPdmVyO1xyXG4gICAgICBuZXdNb2R1bGUub25SZW1vdmUgPSBzb2xhclBhbmVsT25SZW1vdmU7XHJcbiAgIH1cclxuICAgXHJcbiAgIC8vVGhydXN0ZXIgbW9kdWxlIGV2ZW50c1xyXG5cdGlmKHR5cGUgPT09ICd0aHJ1c3RlcicpIHtcclxuICAgICAgaWYgKGZvclBsYXllcikge1xyXG4gICAgICAgICB2YXIgc3BhY2UgPSB0aGlzLmdhbWVTdGF0ZS5pbnB1dC5rZXlib2FyZC5hZGRLZXkoUGhhc2VyLktleWJvYXJkLlNQQUNFQkFSKTsgXHJcbiAgICAgICAgIHRoaXMuZ2FtZVN0YXRlLmlucHV0LmtleWJvYXJkLmFkZEtleUNhcHR1cmUoW3NwYWNlXSk7XHJcbiAgICAgICAgIC8vIHNwYWNlLm9uRG93bi5hZGQoYXBwbHlUaHJ1c3QsIG5ld01vZHVsZSk7XHJcbiAgICAgICAgIHNwYWNlLm9uRG93bi5hZGQoYmVnaW5BY3QsIG5ld01vZHVsZSk7XHJcbiAgICAgICAgIHNwYWNlLm9uVXAuYWRkKGVuZEFjdCwgbmV3TW9kdWxlKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgLy8gbmV3TW9kdWxlLnRocnVzdCA9IGZhbHNlO1xyXG4gICAgICAgICBuZXdNb2R1bGUuYmVnaW5BY3QgPSBiZWdpbkFjdDtcclxuICAgICAgICAgbmV3TW9kdWxlLmVuZEFjdCA9IGVuZEFjdDtcclxuICAgICAgfVxyXG4gICAgICBuZXdNb2R1bGUudXBkYXRlID0gdGhydXN0ZXJVcGRhdGU7XHJcbiAgICAgIG5ld01vZHVsZS50aHJ1c3RlckhhbHQgPSB0aHJ1c3RlckhhbHQ7XHJcblx0fVxyXG5cdC8vUmV0dXJuIHRoZSBtb2R1bGUgb2JqZWN0XHJcblx0cmV0dXJuIG5ld01vZHVsZTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTW9kdWxlQnVpbGRlcjtcclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuIiwiLypcclxuRGVmaW5lcyBhIGN1YmUuXHJcbiovXHJcblxyXG52YXIgQ3ViZSA9IGZ1bmN0aW9uIChnYW1lU3RhdGUsIHgsIHksIHNwcml0ZSkge1xyXG4gICAgUGhhc2VyLlNwcml0ZS5jYWxsKHRoaXMsIGdhbWVTdGF0ZS5nYW1lLCB4LCB5LCBzcHJpdGUpO1xyXG5cdCB0aGlzLnRhZyA9ICdtb2R1bGUnO1x0Ly90YWcgaXMgdXNlZCB0byBkZXRlY3Qgb2JqZWN0IHR5cGUgZHVyaW5nIGNvbGxpc2lvbiBjaGVja2luZ1xyXG4gICAgdGhpcy5nYW1lID0gZ2FtZVN0YXRlLmdhbWU7XHJcbiAgICB0aGlzLmdhbWUuYWRkLmV4aXN0aW5nKHRoaXMpO1xyXG4gICAgdGhpcy5ncm91cCA9IHVuZGVmaW5lZDtcclxuICAgIHRoaXMubW9kdWxlID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5pbmRpY2F0b3JGYWRlID0gMC4wMjtcclxuICAgIHRoaXMuaGVhbHRoQmFyID0gZ2FtZVN0YXRlLnVpQnVpbGRlci5idWlsZFByb2dyZXNzQmFyKCdzaHJpbmtpbmcnLCAwLCAwLCAyMCwgNCwgMyk7XHJcblx0dGhpcy5oZWFsdGhCYXIuc2V0U3R5bGUoMCwgMHhGRkZGRkYsIDB4MzYzNjM2LCAwLCAwLCAwLCAweEZGRkZGRiwgMHgyMENDMjApO1xyXG5cdHRoaXMuaGVhbHRoQmFyLmN1YmUgPSB0aGlzO1xyXG5cdC8vc2V0IHVwZGF0ZSBmdW5jdGlvbiBvZiBoZWFsdGggYmFyXHJcblx0dGhpcy5oZWFsdGhCYXIudXBkYXRlID0gZnVuY3Rpb24oKSB7XHJcblx0XHR0aGlzLnNldExvY2F0aW9uKHRoaXMuY3ViZS54LCB0aGlzLmN1YmUueSsxMCk7XHJcblx0fTtcclxuXHQvL29uRXZlbnQgY2FsbGVkIHdoZW4gY3ViZSBydW5zIG91dCBvZiBoZWFsdGhcclxuXHR0aGlzLmhlYWx0aEJhci5vbkV2ZW50ID0gZnVuY3Rpb24oKSB7XHJcblx0XHR0aGlzLmR5aW5nID0gdHJ1ZTtcclxuXHRcdHRoaXMubGlmZSA9IDUwO1xyXG5cdFx0Ly8gdGhpcy5ncm91cC5jb3VudEN1YmVzKCk7XHJcblx0XHR0aGlzLmRlc3Ryb3koKTtcclxuXHR9O1xyXG5cdHRoaXMuY29uc3RyYWludHMgPSBbXTtcclxufTtcclxuXHJcbkN1YmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShQaGFzZXIuU3ByaXRlLnByb3RvdHlwZSk7XHJcbkN1YmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ3ViZTtcclxuXHJcbi8qKlxyXG4gKiBBdXRvbWF0aWNhbGx5IGNhbGxlZCBieSBXb3JsZC51cGRhdGVcclxuICovXHJcbkN1YmUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICBpZiAodGhpcy5jSW5kaWNhdG9yICYmIHRoaXMuY0luZGljYXRvci5hbHBoYSA+IDApIHtcclxuICAgICAgdGhpcy5jSW5kaWNhdG9yLmFscGhhIC09IHRoaXMuaW5kaWNhdG9yRmFkZTtcclxuICAgfVxyXG4gICBpZiAodGhpcy5tb2R1bGUudXBkYXRlKSB7XHJcbiAgICAgIHRoaXMubW9kdWxlLnVwZGF0ZSgpO1xyXG4gICB9XHJcbiAgIGlmICh0aGlzLmR5aW5nKSB7XHJcbiAgICAgIHRoaXMubGlmZSAtPSB0aGlzLmdhbWUudGltZS5lbGFwc2VkO1xyXG4gICAgICBpZiAodGhpcy5saWZlIDwgMCkge1xyXG4gICAgICAgICB0aGlzLmR5aW5nID0gZmFsc2U7XHJcbiAgICAgICAgIHRoaXMuZ3JvdXAuZGVzdHJveUN1YmUodGhpcyk7XHJcbiAgICAgIH1cclxuICAgfVxyXG59O1xyXG5cclxuQ3ViZS5wcm90b3R5cGUuY3ViZUNvbGxpZGUgPSBmdW5jdGlvbihvdGhlcikge1xyXG4gICBpZiAoIXRoaXMuZ3JvdXAgfHwgIW90aGVyIHx8ICFvdGhlci5zcHJpdGUgfHwgb3RoZXIuc3ByaXRlLmtleSA9PT0gJ2FzdGVyb2lkJykge1xyXG4gICAgICByZXR1cm47XHJcbiAgIH1cclxuXHR0aGlzLmdyb3VwLmhhbmRsZUNvbGxpc2lvbih0aGlzLCBvdGhlci5zcHJpdGUpO1xyXG5cdHRoaXMuZ3JvdXAuY291bnRDdWJlcygpO1xyXG59O1xyXG5cclxuQ3ViZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuICAgdmFyIHN0cmluZyA9ICcnO1xyXG4gICBzdHJpbmcgKz0gdGhpcy5jb25jYXQoJ25hbWUnLCB0aGlzLm5hbWUpO1xyXG4gICByZXR1cm4gc3RyaW5nO1xyXG59O1xyXG5cclxuQ3ViZS5wcm90b3R5cGUuY29uY2F0ID0gZnVuY3Rpb24oc3RyaW5nLCB2YWwpIHtcclxuICAgcmV0dXJuIHN0cmluZyArICc6ICcgKyB2YWwgKyAnXFxuJztcclxufTtcclxuQ3ViZS5wcm90b3R5cGUuZGlzcGxheUluZGljYXRvciA9IGZ1bmN0aW9uKCkge1xyXG4gIHRoaXMuY0luZGljYXRvci5hbHBoYSA9IDE7IFxyXG59O1xyXG5cclxuQ3ViZS5wcm90b3R5cGUudGFrZURhbWFnZSA9IGZ1bmN0aW9uKGFtdCkge1xyXG4gICB0aGlzLmhlYWx0aEJhci5hZGRWYWx1ZSgtYW10KTtcclxufTtcclxuXHJcbkN1YmUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICBpZiAoIXRoaXMuZ3JvdXApIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICB9XHJcbiAgIHRoaXMuZ3JvdXAucmVtb3ZlKHRoaXMpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDdWJlO1xyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbiIsInZhciBBc3RhciA9IHJlcXVpcmUoJy4uL2xpYnMvamF2YXNjcmlwdC1hc3Rhci9hc3RhcicpO1xyXG52YXIgRW5lbXlBSSA9IHJlcXVpcmUoJy4vZW5lbXlfYWknKTtcclxuXHJcbi8qXHJcbkRlZmluZXMgYSBjdWJlIGdyb3VwLlxyXG4qL1xyXG5cclxudmFyIEN1YmVHcm91cCA9IGZ1bmN0aW9uIChnYW1lLCByb290KSB7XHJcbiAgIHRoaXMuZ2FtZSA9IGdhbWU7XHJcbiAgIHRoaXMucm9vdCA9IHJvb3Q7XHJcbiAgIHRoaXMuY3ViZXMgPSBbXTtcclxuICAgdmFyIGNvbCA9IFtdO1xyXG4gICBjb2wucHVzaCh0aGlzLnJvb3QpO1xyXG4gICB0aGlzLmN1YmVzLnB1c2goY29sKTtcclxuICAgaWYgKHRoaXMucm9vdCkge1xyXG4gICAgICB0aGlzLnJvb3QuZ3JvdXAgPSB0aGlzO1xyXG4gICB9XHJcbiAgIHRoaXMuRElSID0ge05PUlRIOiAwLCBFQVNUOiAxLCBTT1VUSDogMiwgV0VTVDogM307XHJcbiAgIHRoaXMub2Zmc2V0ID0gMjtcclxuXHR0aGlzLmhhY2tlck1vZHVsZXMgPSBbXTtcdC8vbGlzdCBvZiBoYWNrZXIgbW9kdWxlcyBpbiB0aGlzIGdyb3VwXHJcblxyXG4gICB0aGlzLm51bUN1YmVzID0gMTtcclxuICAgdGhpcy5ib3VuY2VCYWNrRm9yY2UgPSAzMDtcclxuICAgdGhpcy5taW5SYW1WZWwgPSAzMDA7XHJcbn07XHJcblxyXG5DdWJlR3JvdXAucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ3ViZUdyb3VwO1xyXG5cclxuLyoqXHJcbiAqIEF1dG9tYXRpY2FsbHkgY2FsbGVkIGJ5IFdvcmxkLnVwZGF0ZVxyXG4gKi9cclxuQ3ViZUdyb3VwLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpIHtcclxuICAgaWYgKHRoaXMuQUkpIHtcclxuICAgICAgdGhpcy5BSS51cGRhdGUoKTtcclxuICAgfVxyXG59O1xyXG5cclxuQ3ViZUdyb3VwLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24oZnVuKSB7XHJcbiAgIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IHRoaXMuY3ViZXNXaWR0aCgpOyByb3crKykge1xyXG4gICAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCB0aGlzLmN1YmVzSGVpZ2h0KCk7IGNvbCsrKSB7XHJcbiAgICAgICAgIHZhciBjdWJlID0gdGhpcy5jdWJlc1tyb3ddW2NvbF07XHJcbiAgICAgICAgIGlmIChjdWJlICYmIGN1YmUuaGFzT3duUHJvcGVydHkoZnVuKSkge1xyXG4gICAgICAgICAgICAvLyBpZiBjdWJlcyBuZWVkIGZ1bmN0aW9ucyBjYWxsZWRcclxuICAgICAgICAgfSBlbHNlIGlmIChjdWJlICYmIGN1YmUubW9kdWxlICYmIGN1YmUubW9kdWxlLmhhc093blByb3BlcnR5KGZ1bikpIHtcclxuICAgICAgICAgICAgdmFyIGZuID0gY3ViZS5tb2R1bGVbZnVuXTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICBmbi5jYWxsKGN1YmUubW9kdWxlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgfVxyXG59O1xyXG5cclxuQ3ViZUdyb3VwLnByb3RvdHlwZS5naXZlQUkgPSBmdW5jdGlvbih0eXBlLCBwbGF5ZXIpIHtcclxuICAgdGhpcy5BSSA9IG5ldyBFbmVteUFJKHRoaXMuZ2FtZSwgdGhpcywgdHlwZSwgcGxheWVyKTtcclxufTtcclxuXHJcbkN1YmVHcm91cC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oY3ViZSwgcG9pbnQpIHtcclxuICBpZiAoIXRoaXMucm9vdCAmJiBjdWJlLm1vZHVsZS50eXBlID09PSAnY29yZScpIHtcclxuICAgICB0aGlzLnJvb3QgPSBjdWJlO1xyXG4gIH1cclxuICBjdWJlLmdyb3VwID0gdGhpcztcclxuICB0aGlzLnNldChjdWJlLCBwb2ludCk7XHJcbiAgdGhpcy5jcmVhdGVDb25zdHJhaW50cyhjdWJlLCBwb2ludCk7XHJcbiAgLy8gdGhpcy5kaXNwbGF5Q3ViZXMoKTtcclxufTtcclxuXHJcbkN1YmVHcm91cC5wcm90b3R5cGUuaGFuZGxlQ29sbGlzaW9uID0gZnVuY3Rpb24ob3JpZ2luLCBvdGhlcikge1xyXG4gICAvLyBzdG9wIGlmIG90aGVyIGRvZXMgbm90IGV4aXN0LCBlaXRoZXIgaXMgbm90IGEgY3ViZSwgYm90aCBhcmUgaW4gc2FtZSBncm91cFxyXG5cdGlmIChvdGhlciA9PT0gbnVsbCB8fCBvcmlnaW4ucHJvdG90eXBlICE9PSBvdGhlci5wcm90b3R5cGUgfHwgb3JpZ2luLmdyb3VwID09PSBvdGhlci5ncm91cCB8fCBvdGhlci50YWcgIT09ICdtb2R1bGUnKSB7XHJcblx0XHRyZXR1cm47XHJcblx0fVxyXG4gICBpZiAob3RoZXIuZ3JvdXAgJiYgb3RoZXIuZ3JvdXAgIT09IHRoaXMgJiYgb3JpZ2luLnJhbURlbGF5IDw9IDApIHtcclxuICAgICAgLy8gY29uc29sZS5sb2cob3JpZ2luLm5hbWUsICdyYW1taW5nIGRhbWFnZSEnKTtcclxuICAgICAgb3RoZXIudGFrZURhbWFnZSgxKTtcclxuICAgICAgb3JpZ2luLnJlc2V0UmFtRGVsYXkoKTtcclxuICAgfSBlbHNlIGlmICghb3RoZXIuZ3JvdXAgJiYgdGhpcy5pc1BsYXllcikge1x0XHRcclxuXHRcdC8vQ2hlY2sgaWYgb25lIG9mIHRoZXNlIHR3byBpcyBhIGhhY2tlciBtb2R1bGUsIGlmIHNvIGFkZCBpdCB0byB0aGUgb3RoZXIncyBoYWNrZXJNb2R1bGVzIGxpc3RcclxuXHQgICBpZighb3JpZ2luLmdyb3VwKSB7XHJcblx0XHRcdGlmKG9yaWdpbi5tb2R1bGUudHlwZSA9PT0gJ2hhY2tlcicpIHtcclxuXHRcdFx0XHRvdGhlci5ncm91cC5oYWNrZXJNb2R1bGVzLnB1c2gob3JpZ2luLm1vZHVsZSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdGlmKCFvdGhlci5ncm91cCkge1xyXG5cdFx0XHRpZihvdGhlci5tb2R1bGUudHlwZSA9PT0gJ2hhY2tlcicpIHtcclxuXHRcdFx0XHRvcmlnaW4uZ3JvdXAuaGFja2VyTW9kdWxlcy5wdXNoKG90aGVyLm1vZHVsZSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHZhciByZWxTaWRlID0gdGhpcy5yZWxhdGl2ZVNpZGUob3JpZ2luLmJvZHksIG90aGVyLmJvZHkpO1xyXG5cdFx0dmFyIG9yaWdpbkxvYyA9IHRoaXMuZmluZChvcmlnaW4pO1xyXG5cdFx0dmFyIG90aGVyTG9jID0gdGhpcy5hZGp1c3Qob3JpZ2luTG9jLCByZWxTaWRlKTtcclxuXHRcdHRoaXMuc2V0KG90aGVyLCBvdGhlckxvYyk7XHJcblx0XHRvdGhlckxvYyA9IHRoaXMuZmluZChvdGhlcik7IC8vIHVwZGF0ZSBwb3NpdGlvbiBzaW5jZSBzZXQgY2FuIHNoaWZ0IGdyaWRcclxuXHRcdGlmICghb3RoZXJMb2MpIHtcclxuXHRcdFx0Ly8gY29uc29sZS5sb2coJ2hhbmRsZSBjb2xsaXNpb24gZmFpbGVkIHRvIGZpbmQgcG9zaXRpb24gZm9yIGdvb2QgYXBwbGljYW50Jyk7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHRcdHRoaXMuY3JlYXRlQ29uc3RyYWludHMob3RoZXIsIG90aGVyTG9jKTtcclxuXHR9XHJcbn07XHJcblxyXG5DdWJlR3JvdXAucHJvdG90eXBlLmNyZWF0ZUNvbnN0cmFpbnRzID0gZnVuY3Rpb24obWUsIHBvaW50KSB7XHJcbiAgIC8vIHRoaXMuZGlzcGxheUN1YmVzKCk7XHJcbiAgIHZhciBteU5vcnRoID0gdGhpcy5nZXQodGhpcy5hZGp1c3QocG9pbnQsIHRoaXMuRElSLk5PUlRIKSk7XHJcbiAgIHZhciBteUVhc3QgPSB0aGlzLmdldCh0aGlzLmFkanVzdChwb2ludCwgdGhpcy5ESVIuRUFTVCkpO1xyXG4gICB2YXIgbXlTb3V0aCA9IHRoaXMuZ2V0KHRoaXMuYWRqdXN0KHBvaW50LCB0aGlzLkRJUi5TT1VUSCkpO1xyXG4gICB2YXIgbXlXZXN0ID0gdGhpcy5nZXQodGhpcy5hZGp1c3QocG9pbnQsIHRoaXMuRElSLldFU1QpKTtcclxuICAgdmFyIGNvbnN0cmFpbnQ7XHJcbiAgIGlmIChteU5vcnRoKSB7XHJcbiAgICAgIGNvbnN0cmFpbnQgPSB0aGlzLmdhbWUucGh5c2ljcy5wMi5jcmVhdGVMb2NrQ29uc3RyYWludChtZS5ib2R5LCBteU5vcnRoLmJvZHksIFswLCBtZS53aWR0aCArIHRoaXMub2Zmc2V0XSk7IC8vIG1lIC0gbm9ydGhcclxuICAgICAgbWUuY29uc3RyYWludHMucHVzaChjb25zdHJhaW50KTtcclxuICAgICAgbXlOb3J0aC5jb25zdHJhaW50cy5wdXNoKGNvbnN0cmFpbnQpO1xyXG4gICB9XHJcbiAgIGlmIChteUVhc3QpIHtcclxuICAgICAgY29uc3RyYWludCA9IHRoaXMuZ2FtZS5waHlzaWNzLnAyLmNyZWF0ZUxvY2tDb25zdHJhaW50KG1lLmJvZHksIG15RWFzdC5ib2R5LCBbLW1lLndpZHRoIC0gdGhpcy5vZmZzZXQsIDBdKTsgLy8gbWUgLSBlYXN0XHJcbiAgICAgIG1lLmNvbnN0cmFpbnRzLnB1c2goY29uc3RyYWludCk7XHJcbiAgICAgIG15RWFzdC5jb25zdHJhaW50cy5wdXNoKGNvbnN0cmFpbnQpO1xyXG4gICB9XHJcbiAgIGlmIChteVNvdXRoKSB7XHJcbiAgICAgIGNvbnN0cmFpbnQgPSB0aGlzLmdhbWUucGh5c2ljcy5wMi5jcmVhdGVMb2NrQ29uc3RyYWludChteVNvdXRoLmJvZHksIG1lLmJvZHksIFswLCBtZS53aWR0aCArIHRoaXMub2Zmc2V0XSk7IC8vIHNvdXRoIC0gbWVcclxuICAgICAgbWUuY29uc3RyYWludHMucHVzaChjb25zdHJhaW50KTtcclxuICAgICAgbXlTb3V0aC5jb25zdHJhaW50cy5wdXNoKGNvbnN0cmFpbnQpO1xyXG4gICB9XHJcbiAgIGlmIChteVdlc3QpIHtcclxuICAgICAgY29uc3RyYWludCA9IHRoaXMuZ2FtZS5waHlzaWNzLnAyLmNyZWF0ZUxvY2tDb25zdHJhaW50KG15V2VzdC5ib2R5LCBtZS5ib2R5LCBbLW1lLndpZHRoIC0gdGhpcy5vZmZzZXQsIDBdKTsgLy8gd2VzdCAtIG1lXHJcbiAgICAgIG1lLmNvbnN0cmFpbnRzLnB1c2goY29uc3RyYWludCk7XHJcbiAgICAgIG15V2VzdC5jb25zdHJhaW50cy5wdXNoKGNvbnN0cmFpbnQpO1xyXG4gICB9XHJcbn07XHJcblxyXG5DdWJlR3JvdXAucHJvdG90eXBlLnJlbGF0aXZlU2lkZSA9IGZ1bmN0aW9uKHRoaXNCb2R5LCBvdGhlckJvZHkpIHtcclxuICB2YXIgdGhpc1BvaW50ID0gbmV3IFBoYXNlci5Qb2ludCh0aGlzQm9keS54LCB0aGlzQm9keS55KTtcclxuICB2YXIgb3RoZXJQb2ludCA9IG5ldyBQaGFzZXIuUG9pbnQob3RoZXJCb2R5LngsIG90aGVyQm9keS55KTtcclxuICB2YXIgYW5nbGVUb090aGVyID0gdGhpcy5hbmdsZUJldHdlZW5Qb2ludHModGhpc1BvaW50LCBvdGhlclBvaW50KTtcclxuICB2YXIgZGlmZkFuZ2xlID0gTWF0aC5hYnMoTWF0aC5hYnMoYW5nbGVUb090aGVyKSAtIE1hdGguYWJzKHRoaXNCb2R5LnJvdGF0aW9uKSk7XHJcbiAgIGlmIChkaWZmQW5nbGUgPCAxIC8gNCAqIE1hdGguUEkgfHwgZGlmZkFuZ2xlID4gNyAvIDQgKiBNYXRoLlBJKSB7IC8vIG5vcnRoXHJcbiAgICAgcmV0dXJuIHRoaXMuRElSLk5PUlRIO1xyXG4gIH0gZWxzZSBpZiAoZGlmZkFuZ2xlID49IDEgLyA0ICogTWF0aC5QSSAmJiBkaWZmQW5nbGUgPCAzIC8gNCAqIE1hdGguUEkpIHsgLy8gZWFzdFxyXG4gICAgIHJldHVybiB0aGlzLkRJUi5FQVNUO1xyXG4gIH0gZWxzZSBpZiAoZGlmZkFuZ2xlID49IDMgLyA0ICogTWF0aC5QSSAmJiBkaWZmQW5nbGUgPCA1IC8gNCAqIE1hdGguUEkpIHsgLy8gc291dGhcclxuICAgICByZXR1cm4gdGhpcy5ESVIuU09VVEg7XHJcbiAgfSBlbHNlIGlmIChkaWZmQW5nbGUgPj0gNSAvIDQgKiBNYXRoLlBJICYmIGRpZmZBbmdsZSA8IDcgLyA0ICogTWF0aC5QSSkgeyAvLyB3ZXN0XHJcbiAgICAgcmV0dXJuIHRoaXMuRElSLldFU1Q7XHJcbiAgfVxyXG59O1xyXG5cclxuQ3ViZUdyb3VwLnByb3RvdHlwZS5hbmdsZUJldHdlZW5Qb2ludHMgPSBmdW5jdGlvbih0aGlzUG9pbnQsIG90aGVyUG9pbnQpIHtcclxuICB2YXIgYW5nbGVUb090aGVyID0gUGhhc2VyLlBvaW50LmFuZ2xlKHRoaXNQb2ludCwgb3RoZXJQb2ludCk7XHJcbiAgaWYgKGFuZ2xlVG9PdGhlciA8IDApIHsgLy8gZml4IGR1bWIgcGFydCBvZiBQaGFzZXIuUG9pbnQuYW5nbGUoKVxyXG4gICAgIGFuZ2xlVG9PdGhlciA9IDIgKiBNYXRoLlBJICsgYW5nbGVUb090aGVyO1xyXG4gIH1cclxuICBhbmdsZVRvT3RoZXIgPSAoYW5nbGVUb090aGVyICsgMy8yICogTWF0aC5QSSkgJSAoMiAqIE1hdGguUEkpOyAvLyByb3RhdGUgOTAgZCBjbG9ja3dpc2VcclxuICAgcmV0dXJuIGFuZ2xlVG9PdGhlcjtcclxufTtcclxuXHJcbkN1YmVHcm91cC5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uKGN1YmUpIHtcclxuICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgdGhpcy5jdWJlc1dpZHRoKCk7IHJvdysrKSB7XHJcbiAgICAgIGZvciAodmFyIGNvbCA9IDA7IGNvbCA8IHRoaXMuY3ViZXNIZWlnaHQoKTsgY29sKyspIHtcclxuICAgICAgICAgaWYgKHRoaXMuY3ViZXNbcm93XVtjb2xdID09PSBjdWJlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUGhhc2VyLlBvaW50KHJvdywgY29sKTtcclxuICAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgIH1cclxuICAgcmV0dXJuIHVuZGVmaW5lZDtcclxufTtcclxuXHJcbkN1YmVHcm91cC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24ocG9pbnQpIHtcclxuICBpZiAoIXBvaW50IHx8IHRoaXMub3V0T2ZCb3VuZHMocG9pbnQpKSB7XHJcbiAgICAgIHJldHVybjtcclxuICB9XHJcbiAgcmV0dXJuIHRoaXMuY3ViZXNbcG9pbnQueF1bcG9pbnQueV07XHJcbn07XHJcblxyXG5DdWJlR3JvdXAucHJvdG90eXBlLmN1YmVzV2lkdGggPSBmdW5jdGlvbigpIHtcclxuICAgcmV0dXJuIHRoaXMuY3ViZXMubGVuZ3RoO1xyXG59O1xyXG5cclxuQ3ViZUdyb3VwLnByb3RvdHlwZS5jdWJlc0hlaWdodCA9IGZ1bmN0aW9uKCkge1xyXG4gICByZXR1cm4gdGhpcy5jdWJlc1swXS5sZW5ndGg7XHJcbn07XHJcblxyXG5DdWJlR3JvdXAucHJvdG90eXBlLmFkZFRvcFJvdyA9IGZ1bmN0aW9uKCkge1xyXG4gICBmb3IgKHZhciByb3cgPSAwOyByb3cgPCB0aGlzLmN1YmVzV2lkdGgoKTsgcm93KyspIHtcclxuICAgICAgdGhpcy5jdWJlc1tyb3ddLnB1c2godW5kZWZpbmVkKTtcclxuICAgfVxyXG59O1xyXG5cclxuQ3ViZUdyb3VwLnByb3RvdHlwZS5hZGRSaWdodENvbCA9IGZ1bmN0aW9uKCkge1xyXG4gICB2YXIgbmV3Q29sID0gW107XHJcbiAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jdWJlc0hlaWdodCgpOyBpKyspIHtcclxuICAgICAgbmV3Q29sLnB1c2godW5kZWZpbmVkKTtcclxuICAgfVxyXG4gICB0aGlzLmN1YmVzLnB1c2gobmV3Q29sKTtcclxufTtcclxuXHJcbkN1YmVHcm91cC5wcm90b3R5cGUuYWRkQm90Um93ID0gZnVuY3Rpb24oKSB7XHJcbiAgIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IHRoaXMuY3ViZXNXaWR0aCgpOyByb3crKykge1xyXG4gICAgICB0aGlzLmN1YmVzW3Jvd10udW5zaGlmdCh1bmRlZmluZWQpO1xyXG4gICB9XHJcbn07XHJcblxyXG5DdWJlR3JvdXAucHJvdG90eXBlLmFkZExlZnRDb2wgPSBmdW5jdGlvbigpIHtcclxuICAgdmFyIG5ld0NvbCA9IG5ldyBBcnJheSh0aGlzLmN1YmVzSGVpZ2h0KCkpO1xyXG4gICB0aGlzLmN1YmVzLnVuc2hpZnQobmV3Q29sKTtcclxufTtcclxuXHJcbkN1YmVHcm91cC5wcm90b3R5cGUuZ2V0Q3ViZSA9IGZ1bmN0aW9uKHBvaW50KSB7XHJcbiAgIGlmICghcG9pbnQgfHwgdGhpcy5vdXRPZkJvdW5kcyhwb2ludCkpIHtcclxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgfVxyXG4gICByZXR1cm4gdGhpcy5jdWJlc1twb2ludC54XVtwb2ludC55XTtcclxufTtcclxuXHJcbkN1YmVHcm91cC5wcm90b3R5cGUuYWRqdXN0ID0gZnVuY3Rpb24ocG9pbnQsIGRpcikge1xyXG4gIGlmICghcG9pbnQpIHtcclxuICAgICByZXR1cm47XHJcbiAgfVxyXG4gIHZhciBuZXdQb2ludCA9IG5ldyBQaGFzZXIuUG9pbnQocG9pbnQueCwgcG9pbnQueSk7XHJcbiAgc3dpdGNoIChkaXIpIHtcclxuICAgICAgY2FzZSB0aGlzLkRJUi5OT1JUSDpcclxuICAgICAgbmV3UG9pbnQueSsrO1xyXG4gICAgICBicmVhaztcclxuICAgICAgY2FzZSB0aGlzLkRJUi5FQVNUOlxyXG4gICAgICBuZXdQb2ludC54Kys7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIHRoaXMuRElSLlNPVVRIOlxyXG4gICAgICBuZXdQb2ludC55LS07XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIHRoaXMuRElSLldFU1Q6XHJcbiAgICAgIG5ld1BvaW50LngtLTtcclxuICAgICAgYnJlYWs7XHJcbiAgIH1cclxuICAgcmV0dXJuIG5ld1BvaW50O1xyXG59O1xyXG5cclxuQ3ViZUdyb3VwLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihjdWJlLCBwb2ludCkge1xyXG4gICBpZiAoIXBvaW50KSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdzZXQgZ2l2ZW4gdW5kZWZpbmVkIHBvaW50Jyk7XHJcbiAgICAgIHJldHVybjtcclxuICAgfVxyXG4gICBpZiAocG9pbnQueCA8IDApIHtcclxuICAgICAgdGhpcy5hZGRMZWZ0Q29sKCk7XHJcbiAgICAgIHBvaW50LnggPSAwO1xyXG4gICB9IGVsc2UgaWYgKHBvaW50LnggPj0gdGhpcy5jdWJlc1dpZHRoKCkpIHtcclxuICAgICAgdGhpcy5hZGRSaWdodENvbCgpO1xyXG4gICAgICBwb2ludC54ID0gdGhpcy5jdWJlc1dpZHRoKCkgLSAxO1xyXG4gICB9IGVsc2UgaWYgKHBvaW50LnkgPCAwKSB7XHJcbiAgICAgIHRoaXMuYWRkQm90Um93KCk7XHJcbiAgICAgIHBvaW50LnkgPSAwO1xyXG4gICB9IGVsc2UgaWYgKHBvaW50LnkgPj0gdGhpcy5jdWJlc0hlaWdodCgpKSB7XHJcbiAgICAgIHRoaXMuYWRkVG9wUm93KCk7XHJcbiAgICAgIHBvaW50LnkgPSB0aGlzLmN1YmVzSGVpZ2h0KCkgLSAxO1xyXG4gICB9XHJcbiAgIGlmICh0aGlzLmdldChwb2ludCkpIHtcclxuICAgICAgLy8gY29uc29sZS5sb2coJ3RyaWVkIHRvIHNldCB0byBmaWxsZWQgcG9zaXRpb24nKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICB9XHJcbiAgIHRoaXMuY3ViZXNbcG9pbnQueF1bcG9pbnQueV0gPSBjdWJlO1xyXG4gICBjdWJlLmdyb3VwID0gdGhpcztcclxufTtcclxuXHJcbkN1YmVHcm91cC5wcm90b3R5cGUub3V0T2ZCb3VuZHMgPSBmdW5jdGlvbihwb2ludCkge1xyXG4gICBpZiAoIXBvaW50KSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdvdXQgb2YgYm91bmRzIGdpdmVuIHVuZGVmaW5lZCBwb2ludCcpO1xyXG4gICAgICByZXR1cm47XHJcbiAgIH1cclxuICAgaWYgKHBvaW50LnggPCAwIHx8IHBvaW50LnggPj0gdGhpcy5jdWJlc1dpZHRoKCkgfHwgcG9pbnQueSA8IDAgfHwgcG9pbnQueSA+PSB0aGlzLmN1YmVzSGVpZ2h0KCkpIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgIH1cclxuICAgcmV0dXJuIGZhbHNlO1xyXG59O1xyXG5cclxuQ3ViZUdyb3VwLnByb3RvdHlwZS5kaXNwbGF5Q3ViZXMgPSBmdW5jdGlvbigpIHtcclxuICAgY29uc29sZS5sb2coJz09PT09PT09PT09PT09PT0nKTtcclxuICAgdmFyIG91dHB1dCA9ICdEaXNwbGF5IEN1YmVzXFxuJztcclxuICAgdmFyIHJvdyA9IDA7XHJcbiAgIHZhciBjb2wgPSB0aGlzLmN1YmVzSGVpZ2h0KCkgLSAxO1xyXG4gICB3aGlsZSAoY29sID49IDApIHtcclxuICAgICAgd2hpbGUgKHJvdyA8IHRoaXMuY3ViZXNXaWR0aCgpKSB7XHJcbiAgICAgICAgIHZhciBjdWJlID0gdGhpcy5jdWJlc1tyb3ddW2NvbF07XHJcbiAgICAgICAgIGlmIChjdWJlKSB7XHJcbiAgICAgICAgICAgIG91dHB1dCArPSAnIyAnO1xyXG4gICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBvdXRwdXQgKz0gJ18gJztcclxuICAgICAgICAgfVxyXG4gICAgICAgICByb3crKztcclxuICAgICAgfVxyXG4gICAgICByb3cgPSAwO1xyXG4gICAgICBjb2wtLTtcclxuICAgICAgb3V0cHV0ICs9ICdcXG4nO1xyXG4gICB9XHJcbiAgIGNvbnNvbGUubG9nKG91dHB1dCk7XHJcbiAgIGNvbnNvbGUubG9nKCctLS0tLS0tLS0tLS0tLS0nKTtcclxufTtcclxuXHJcbkN1YmVHcm91cC5wcm90b3R5cGUuZGlzcGxheUNvbm5lY3Rpb24gPSBmdW5jdGlvbihjb25uZWN0aW9uKSB7XHJcbiAgIHZhciBncmFwaCA9IG5ldyBBc3Rhci5HcmFwaCh0aGlzLmN1YmVzVG9HcmFwaCgpKTtcclxuICAgdmFyIHN0YXJ0UG9pbnQgPSB0aGlzLmZpbmQoY29ubmVjdGlvbi5zdGFydCk7XHJcbiAgIHZhciBlbmRQb2ludCA9IHRoaXMuZmluZChjb25uZWN0aW9uLmVuZCk7XHJcbiAgIGlmICghc3RhcnRQb2ludCB8fCAhZW5kUG9pbnQpIHtcclxuICAgICAgY29uc29sZS5sb2coJ2Rpc3BsYXlDb25uZWN0aW9uIGZhaWxlZCB0byBnZXQgcG9pbnRzJyk7XHJcbiAgICAgIHJldHVybjtcclxuICAgfVxyXG4gICB2YXIgc3RhcnQgPSBncmFwaC5ncmlkW3N0YXJ0UG9pbnQueF1bc3RhcnRQb2ludC55XTtcclxuICAgdmFyIGVuZCA9IGdyYXBoLmdyaWRbZW5kUG9pbnQueF1bZW5kUG9pbnQueV07XHJcbiAgIHZhciByZXN1bHQgPSBBc3Rhci5hc3Rhci5zZWFyY2goZ3JhcGgsIHN0YXJ0LCBlbmQpO1xyXG4gICByZXN1bHQudW5zaGlmdChzdGFydCk7XHJcbiAgIHZhciBwcmV2aW91cztcclxuICAgZm9yKHZhciBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xyXG4gICAgICB2YXIgY3VyUG9pbnQgPSBuZXcgUGhhc2VyLlBvaW50KHJlc3VsdFtpXS54LCByZXN1bHRbaV0ueSk7XHJcbiAgICAgIHZhciBjdXIgPSB0aGlzLmdldChjdXJQb2ludCk7XHJcbiAgICAgIHZhciBpbmRpY2F0b3IgPSBjdXIuY0luZGljYXRvcjtcclxuICAgICAgdmFyIGRpcjtcclxuICAgICAgdmFyIHByZXZQb2ludDtcclxuICAgICAgdmFyIG5leHRQb2ludDtcclxuICAgICAgaWYgKCFwcmV2aW91cykge1xyXG4gICAgICAgICBpbmRpY2F0b3IuYW5pbWF0aW9ucy5wbGF5KCdlbmQnKTtcclxuICAgICAgICAgbmV4dFBvaW50ID0gbmV3IFBoYXNlci5Qb2ludChyZXN1bHRbaSsxXS54LCByZXN1bHRbaSsxXS55KTtcclxuICAgICAgICAgZGlyID0gdGhpcy5kaXJCZXR3ZWVuKGN1clBvaW50LCBuZXh0UG9pbnQpO1xyXG4gICAgICAgICBpbmRpY2F0b3Iucm90YXRpb24gPSB0aGlzLmRpclRvQW5nbGUoZGlyKTtcclxuICAgICAgfSBlbHNlIGlmIChpID09PSByZXN1bHQubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICBpbmRpY2F0b3IuYW5pbWF0aW9ucy5wbGF5KCdlbmQnKTtcclxuICAgICAgICAgcHJldlBvaW50ID0gbmV3IFBoYXNlci5Qb2ludChwcmV2aW91cy54LCBwcmV2aW91cy55KTtcclxuICAgICAgICAgZGlyID0gdGhpcy5kaXJCZXR3ZWVuKGN1clBvaW50LCBwcmV2UG9pbnQpO1xyXG4gICAgICAgICBpbmRpY2F0b3Iucm90YXRpb24gPSB0aGlzLmRpclRvQW5nbGUoZGlyKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgaW5kaWNhdG9yLmFuaW1hdGlvbnMucGxheSgnbGluZScpO1xyXG4gICAgICAgICBwcmV2UG9pbnQgPSBuZXcgUGhhc2VyLlBvaW50KHByZXZpb3VzLngsIHByZXZpb3VzLnkpO1xyXG4gICAgICAgICB2YXIgcHJldkRpciA9IHRoaXMuZGlyQmV0d2VlbihjdXJQb2ludCwgcHJldlBvaW50KTtcclxuICAgICAgICAgbmV4dFBvaW50ID0gbmV3IFBoYXNlci5Qb2ludChyZXN1bHRbaSsxXS54LCByZXN1bHRbaSsxXS55KTtcclxuICAgICAgICAgdmFyIG5leHREaXIgPSB0aGlzLmRpckJldHdlZW4oY3VyUG9pbnQsIG5leHRQb2ludCk7XHJcbiAgICAgICAgIHRoaXMubWFuYWdlSW5kaWNhdG9yKGluZGljYXRvciwgcHJldkRpciwgbmV4dERpcik7XHJcbiAgICAgIH1cclxuICAgICAgcHJldmlvdXMgPSByZXN1bHRbaV07XHJcbiAgICAgIGN1ci5kaXNwbGF5SW5kaWNhdG9yKCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5DdWJlR3JvdXAucHJvdG90eXBlLm1hbmFnZUluZGljYXRvciA9IGZ1bmN0aW9uKGluZGljYXRvciwgcHJldkRpciwgbmV4dERpcikge1xyXG4gIGluZGljYXRvci5zY2FsZS5zZXRUbyhNYXRoLmFicyhpbmRpY2F0b3Iuc2NhbGUueCksIGluZGljYXRvci5zY2FsZS55KTtcclxuICBpZiAocHJldkRpciA9PT0gdGhpcy5ESVIuTk9SVEggJiYgbmV4dERpciA9PT0gdGhpcy5ESVIuU09VVEgpIHsgLy8gMlxyXG4gICAgICBpbmRpY2F0b3Iucm90YXRpb24gPSBNYXRoLlBJO1xyXG4gICB9IGVsc2UgaWYgKHByZXZEaXIgPT09IHRoaXMuRElSLlNPVVRIICYmIG5leHREaXIgPT09IHRoaXMuRElSLk5PUlRIKSB7IC8vIDFcclxuICAgICAgaW5kaWNhdG9yLnJvdGF0aW9uID0gMDtcclxuICAgfSBlbHNlIGlmIChwcmV2RGlyID09PSB0aGlzLkRJUi5FQVNUICYmIG5leHREaXIgPT09IHRoaXMuRElSLldFU1QpIHsgLy8gNFxyXG4gICAgICBpbmRpY2F0b3Iucm90YXRpb24gPSAxIC8gMiAqIE1hdGguUEk7XHJcbiAgIH0gZWxzZSBpZiAocHJldkRpciA9PT0gdGhpcy5ESVIuV0VTVCAmJiBuZXh0RGlyID09PSB0aGlzLkRJUi5FQVNUKSB7IC8vIDNcclxuICAgICAgaW5kaWNhdG9yLnJvdGF0aW9uID0gMyAvIDIgICogTWF0aC5QSTtcclxuICAgfSBlbHNlIHtcclxuICAgICAgaW5kaWNhdG9yLmFuaW1hdGlvbnMucGxheSgncmlnaHQnKTtcclxuICAgICAgaWYgKHByZXZEaXIgPT09IHRoaXMuRElSLlNPVVRIICYmIG5leHREaXIgPT09IHRoaXMuRElSLkVBU1QpIHsgLy8gNVxyXG4gICAgICAgICBpbmRpY2F0b3Iucm90YXRpb24gPSAwO1xyXG4gICAgICB9IGVsc2UgaWYgKHByZXZEaXIgPT09IHRoaXMuRElSLldFU1QgJiYgbmV4dERpciA9PT0gdGhpcy5ESVIuU09VVEgpIHsgLy8gNlxyXG4gICAgICAgICBpbmRpY2F0b3Iucm90YXRpb24gPSAxIC8gMiAqIE1hdGguUEk7XHJcbiAgICAgIH0gZWxzZSBpZiAocHJldkRpciA9PT0gdGhpcy5ESVIuTk9SVEggJiYgbmV4dERpciA9PT0gdGhpcy5ESVIuV0VTVCkgeyAvLyA3XHJcbiAgICAgICAgIGluZGljYXRvci5yb3RhdGlvbiA9IE1hdGguUEk7XHJcbiAgICAgIH0gZWxzZSBpZiAocHJldkRpciA9PT0gdGhpcy5ESVIuRUFTVCAmJiBuZXh0RGlyID09PSB0aGlzLkRJUi5OT1JUSCkgeyAvLyA4XHJcbiAgICAgICAgIGluZGljYXRvci5yb3RhdGlvbiA9IDMgLyAyICogTWF0aC5QSTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgaW5kaWNhdG9yLnNjYWxlLnNldFRvKC1NYXRoLmFicyhpbmRpY2F0b3Iuc2NhbGUueCksIGluZGljYXRvci5zY2FsZS55KTtcclxuICAgICAgICAgaWYgKHByZXZEaXIgPT09IHRoaXMuRElSLlNPVVRIICYmIG5leHREaXIgPT09IHRoaXMuRElSLldFU1QpIHsgLy8gOVxyXG4gICAgICAgICAgICBpbmRpY2F0b3Iucm90YXRpb24gPSAwO1xyXG4gICAgICAgICB9IGVsc2UgaWYgKHByZXZEaXIgPT09IHRoaXMuRElSLldFU1QgJiYgbmV4dERpciA9PT0gdGhpcy5ESVIuTk9SVEgpIHsgLy8gMTBcclxuICAgICAgICAgICAgaW5kaWNhdG9yLnJvdGF0aW9uID0gMSAvIDIgKiBNYXRoLlBJO1xyXG4gICAgICAgICB9IGVsc2UgaWYgKHByZXZEaXIgPT09IHRoaXMuRElSLk5PUlRIICYmIG5leHREaXIgPT09IHRoaXMuRElSLkVBU1QpIHsgLy8gMTFcclxuICAgICAgICAgICAgaW5kaWNhdG9yLnJvdGF0aW9uID0gTWF0aC5QSTtcclxuICAgICAgICAgfSBlbHNlIGlmIChwcmV2RGlyID09PSB0aGlzLkRJUi5FQVNUICYmIG5leHREaXIgPT09IHRoaXMuRElSLlNPVVRIKSB7IC8vIDEyXHJcbiAgICAgICAgICAgIGluZGljYXRvci5yb3RhdGlvbiA9IDMgLyAyICogTWF0aC5QSTtcclxuICAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgIH0gXHJcbn07XHJcblxyXG5DdWJlR3JvdXAucHJvdG90eXBlLmN1YmVzVG9HcmFwaCA9IGZ1bmN0aW9uKCkge1xyXG4gIHZhciBncmFwaCA9IFtdO1xyXG4gIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IHRoaXMuY3ViZXNXaWR0aCgpOyByb3crKykge1xyXG4gICAgIHZhciBuZXdDb2wgPSBbXTtcclxuICAgICAgZm9yICh2YXIgY29sID0gMDsgY29sIDwgdGhpcy5jdWJlc0hlaWdodCgpOyBjb2wrKykge1xyXG4gICAgICAgICBpZiAodGhpcy5jdWJlc1tyb3ddW2NvbF0pIHtcclxuICAgICAgICAgICAgbmV3Q29sLnB1c2goMSk7XHJcbiAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG5ld0NvbC5wdXNoKDApO1xyXG4gICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgZ3JhcGgucHVzaChuZXdDb2wpO1xyXG4gICB9XHJcbiAgIHJldHVybiBncmFwaDtcclxufTtcclxuXHJcbkN1YmVHcm91cC5wcm90b3R5cGUuZGlyQmV0d2VlbiA9IGZ1bmN0aW9uKGEsIGIpIHtcclxuICAgdmFyIGRlbHRhWCA9IGEueCAtIGIueDtcclxuICAgdmFyIGRlbHRhWSA9IGEueSAtIGIueTtcclxuICAgaWYgKGRlbHRhWCA+IDApIHtcclxuICAgICAgcmV0dXJuIHRoaXMuRElSLldFU1Q7XHJcbiAgIH1cclxuICAgaWYgKGRlbHRhWCA8IDApIHtcclxuICAgICAgcmV0dXJuIHRoaXMuRElSLkVBU1Q7XHJcbiAgIH1cclxuICAgaWYgKGRlbHRhWSA+IDApIHtcclxuICAgICAgcmV0dXJuIHRoaXMuRElSLlNPVVRIO1xyXG4gICB9XHJcbiAgIGlmIChkZWx0YVkgPCAwKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLkRJUi5OT1JUSDtcclxuICAgfVxyXG4gICByZXR1cm4gdGhpcy5ESVIuTk9SVEg7XHJcbn07XHJcblxyXG5DdWJlR3JvdXAucHJvdG90eXBlLmRpclRvQW5nbGUgPSBmdW5jdGlvbihkaXIpIHtcclxuICBzd2l0Y2ggKGRpcikge1xyXG4gICBjYXNlIHRoaXMuRElSLk5PUlRIOlxyXG4gICByZXR1cm4gTWF0aC5QSTtcclxuICAgY2FzZSB0aGlzLkRJUi5FQVNUOlxyXG4gICByZXR1cm4gMyAvIDIgKiBNYXRoLlBJO1xyXG4gICBjYXNlIHRoaXMuRElSLlNPVVRIOlxyXG4gICByZXR1cm4gMDtcclxuICAgY2FzZSB0aGlzLkRJUi5XRVNUOlxyXG4gICByZXR1cm4gMSAvIDIgKiBNYXRoLlBJO1xyXG4gIH0gIFxyXG59O1xyXG5cclxuQ3ViZUdyb3VwLnByb3RvdHlwZS5kZXN0cm95Q3ViZSA9IGZ1bmN0aW9uKGN1YmUpIHtcclxuICAvLyBjb25zb2xlLmxvZygnZGVzdHJveUN1YmUnKTtcclxuICB2YXIgbG9jID0gdGhpcy5maW5kKGN1YmUpO1xyXG4gIGlmICghbG9jKSB7XHJcbiAgICAgY29uc29sZS5sb2coJ2F0dGVtcHQgdG8gZGVzdHJveSBjdWJlIG5vdCBpbiBncm91cCcpO1xyXG4gICAgIHJldHVybjtcclxuICB9XHJcbiAgLy8gcmVtb3ZlIGN1YmUgZnJvbSBncm91cFxyXG4gIHRoaXMucmVtb3ZlKGN1YmUpO1xyXG4gIC8vIGRlc3Ryb3kgY3ViZVxyXG4gIGN1YmUua2lsbCh0cnVlKTtcclxufTtcclxuXHJcbkN1YmVHcm91cC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oY3ViZSkge1xyXG4gICAvLyBjb25zb2xlLmxvZygncmVtb3ZlJyk7XHJcbiAgIGlmICh0aGlzLnJvb3QgPT09IGN1YmUpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICB9XHJcbiAgIC8vIHJlbW92ZSBjdWJlIGZyb20gYXJyYXlcclxuICAgdmFyIHJvdywgY29sO1xyXG4gICBmb3IgKHJvdyA9IDA7IHJvdyA8IHRoaXMuY3ViZXNXaWR0aCgpOyByb3crKykge1xyXG4gICAgICBmb3IgKGNvbCA9IDA7IGNvbCA8IHRoaXMuY3ViZXNIZWlnaHQoKTsgY29sKyspIHtcclxuICAgICAgICAgaWYgKHRoaXMuY3ViZXNbcm93XVtjb2xdID09PSBjdWJlKSB7XHJcbiAgICAgICAgICAgIC8vIHRoaXMuY3ViZXNbcm93XVtjb2xdLmdyb3VwID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB0aGlzLmN1YmVzW3Jvd11bY29sXSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgIH1cclxuICAgICAgfVxyXG4gICB9XHJcbiAgIC8vIHJlbW92ZSBjb25zdHJhaW50cyBmcm9tIGN1YmVcclxuICAgdGhpcy5yZW1vdmVDb25zdHJhaW50cyhjdWJlKTtcclxuICAgY3ViZS5ncm91cCA9IHVuZGVmaW5lZDtcclxuICAgaWYgKGN1YmUubW9kdWxlICYmIGN1YmUubW9kdWxlLmhhc093blByb3BlcnR5KCdvblJlbW92ZScpKSB7XHJcbiAgICAgIGN1YmUubW9kdWxlLm9uUmVtb3ZlKCk7XHJcbiAgIH1cclxuICAgLy8gdGVzdCBmb3IgZXhpbGVzXHJcbiAgIGZvciAocm93ID0gMDsgcm93IDwgdGhpcy5jdWJlc1dpZHRoKCk7IHJvdysrKSB7XHJcbiAgICAgIGZvciAoY29sID0gMDsgY29sIDwgdGhpcy5jdWJlc0hlaWdodCgpOyBjb2wrKykge1xyXG4gICAgICAgICB2YXIgZXhpbGUgPSB0aGlzLmN1YmVzW3Jvd11bY29sXTtcclxuICAgICAgICAgaWYgKGV4aWxlICYmIHRoaXMuaXNFeGlsZShleGlsZSkpIHtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmUoZXhpbGUpO1xyXG4gICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgfVxyXG4gICAvLyB0aGlzLmRpc3BsYXlDdWJlcygpO1xyXG59O1xyXG5cclxuQ3ViZUdyb3VwLnByb3RvdHlwZS5yZW1vdmVOZWlnaGJvcnNDb25zdHJhaW50ID0gZnVuY3Rpb24oY29uc3RyYWludCwgY3ViZSkge1xyXG4gICAvLyBjb25zb2xlLmxvZygncmVtb3ZlTmVpZ2hib3JzQ29uc3RyYWludCcpO1xyXG4gICB2YXIgbmVpZ2hib3JzID0gdGhpcy5nZXROZWlnaGJvcnMoY3ViZSk7XHJcbiAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmVpZ2hib3JzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHZhciBuZWlnaGJvciA9IG5laWdoYm9yc1tpXTtcclxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBuZWlnaGJvci5jb25zdHJhaW50cy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICBpZiAobmVpZ2hib3IuY29uc3RyYWludHNbal0gPT09IGNvbnN0cmFpbnQpIHtcclxuICAgICAgICAgICAgbmVpZ2hib3IuY29uc3RyYWludHMuc3BsaWNlKGosIDEpO1xyXG4gICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgfVxyXG59O1xyXG5cclxuQ3ViZUdyb3VwLnByb3RvdHlwZS5nZXROZWlnaGJvcnMgPSBmdW5jdGlvbihjdWJlKSB7XHJcbiAgIHZhciBsb2MgPSB0aGlzLmZpbmQoY3ViZSk7XHJcbiAgIHZhciBub3J0aCA9IHRoaXMuZ2V0KHRoaXMuYWRqdXN0KGxvYywgdGhpcy5ESVIuTk9SVEgpKTtcclxuICAgdmFyIGVhc3QgPSB0aGlzLmdldCh0aGlzLmFkanVzdChsb2MsIHRoaXMuRElSLkVBU1QpKTtcclxuICAgdmFyIHNvdXRoID0gdGhpcy5nZXQodGhpcy5hZGp1c3QobG9jLCB0aGlzLkRJUi5TT1VUSCkpO1xyXG4gICB2YXIgd2VzdCA9IHRoaXMuZ2V0KHRoaXMuYWRqdXN0KGxvYywgdGhpcy5ESVIuV0VTVCkpO1xyXG4gICB2YXIgbmVpZ2hib3JzID0gW107XHJcbiAgIGlmIChub3J0aCkge1xyXG4gICAgICBuZWlnaGJvcnMucHVzaChub3J0aCk7XHJcbiAgIH1cclxuICAgaWYgKGVhc3QpIHtcclxuICAgICAgbmVpZ2hib3JzLnB1c2goZWFzdCk7XHJcbiAgIH1cclxuICAgaWYgKHNvdXRoKSB7XHJcbiAgICAgIG5laWdoYm9ycy5wdXNoKHNvdXRoKTtcclxuICAgfVxyXG4gICBpZiAod2VzdCkge1xyXG4gICAgICBuZWlnaGJvcnMucHVzaCh3ZXN0KTtcclxuICAgfVxyXG4gICByZXR1cm4gbmVpZ2hib3JzO1xyXG59O1xyXG5cclxuQ3ViZUdyb3VwLnByb3RvdHlwZS5yZW1vdmVDb25zdHJhaW50cyA9IGZ1bmN0aW9uKGN1YmUpIHtcclxuICAgLy8gY29uc29sZS5sb2coJ3JlbW92ZUNvbnN0cmFpbnRzJyk7XHJcbiAgIHdoaWxlIChjdWJlLmNvbnN0cmFpbnRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgdGhpcy5yZW1vdmVOZWlnaGJvcnNDb25zdHJhaW50KGN1YmUuY29uc3RyYWludHNbMF0sIGN1YmUpO1xyXG4gICAgICB0aGlzLmdhbWUucGh5c2ljcy5wMi5yZW1vdmVDb25zdHJhaW50KGN1YmUuY29uc3RyYWludHNbMF0pO1xyXG4gICAgICBjdWJlLmNvbnN0cmFpbnRzLnNwbGljZSgwLCAxKTtcclxuICAgfVxyXG59O1xyXG5cclxuLy8gb25seSB1c2VkIHRvIHRlc3QgQXN0YXJcclxuQ3ViZUdyb3VwLnByb3RvdHlwZS50ZXN0UGF0aCA9IGZ1bmN0aW9uKCkge1xyXG4gIHZhciBncmFwaCA9IG5ldyBBc3Rhci5HcmFwaChbXHJcbiAgICAgICAgWzEsMSwxLDFdLFxyXG4gICAgICAgIFswLDEsMSwwXSxcclxuICAgICAgICBbMCwwLDAsMV1cclxuICAgIF0pO1xyXG4gICB2YXIgc3RhcnQgPSBncmFwaC5ncmlkWzBdWzBdO1xyXG4gICB2YXIgZW5kID0gZ3JhcGguZ3JpZFsyXVszXTtcclxuICAgdmFyIHJlc3VsdCA9IEFzdGFyLmFzdGFyLnNlYXJjaChncmFwaCwgc3RhcnQsIGVuZCk7XHJcbiAgIHJlc3VsdC51bnNoaWZ0KHN0YXJ0KTtcclxuICAgZm9yKHZhciBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xyXG4gICAgICBjb25zb2xlLmxvZyhyZXN1bHRbaV0ueCwgcmVzdWx0W2ldLnkpO1xyXG4gICAgfSBcclxufTtcclxuXHJcbkN1YmVHcm91cC5wcm90b3R5cGUuaXNFeGlsZSA9IGZ1bmN0aW9uKGN1YmUpIHtcclxuICAgaWYgKGN1YmUgPT09IHRoaXMucm9vdCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgIH1cclxuICAgdmFyIGdyYXBoID0gbmV3IEFzdGFyLkdyYXBoKHRoaXMuY3ViZXNUb0dyYXBoKCkpO1xyXG4gICB2YXIgc3RhcnRQb2ludCA9IHRoaXMuZmluZCh0aGlzLnJvb3QpO1xyXG4gICB2YXIgZW5kUG9pbnQgPSB0aGlzLmZpbmQoY3ViZSk7XHJcbiAgIHZhciBzdGFydCA9IGdyYXBoLmdyaWRbc3RhcnRQb2ludC54XVtzdGFydFBvaW50LnldO1xyXG4gICB2YXIgZW5kID0gZ3JhcGguZ3JpZFtlbmRQb2ludC54XVtlbmRQb2ludC55XTtcclxuICAgdmFyIHJlc3VsdCA9IEFzdGFyLmFzdGFyLnNlYXJjaChncmFwaCwgc3RhcnQsIGVuZCk7XHJcbiAgIC8vIGlmIG5vIHBhdGggaXMgZm91bmQsIHRoZSBjdWJlIGlzIGFuIGV4aWxlXHJcbiAgIGlmIChyZXN1bHQubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICB9XHJcbiAgIHJldHVybiBmYWxzZTtcclxufTtcclxuXHJcbkN1YmVHcm91cC5wcm90b3R5cGUuY291bnRDdWJlcyA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciByb3csIGNvbDtcclxuXHR2YXIgbnVtICA9IDA7XHJcblx0Zm9yIChyb3cgPSAwOyByb3cgPCB0aGlzLmN1YmVzV2lkdGgoKTsgcm93KyspIHtcclxuXHRcdGZvciAoY29sID0gMDsgY29sIDwgdGhpcy5jdWJlc0hlaWdodCgpOyBjb2wrKykge1xyXG5cdFx0XHRpZiAodGhpcy5jdWJlc1tyb3ddW2NvbF0gIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdG51bSsrO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cdC8vY29uc29sZS5sb2cobnVtKTtcclxuXHR0aGlzLm51bUN1YmVzID0gbnVtO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDdWJlR3JvdXA7XHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG4iLCJ2YXIgVXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy5qcycpO1xyXG5cclxudmFyIEVuZW15QUkgPSBmdW5jdGlvbihnYW1lLCBncm91cCwgdHlwZSwgcGxheWVyR3JvdXApIHtcclxuICAgdGhpcy5nYW1lID0gZ2FtZTtcclxuICAgdGhpcy5ncm91cCA9IGdyb3VwO1xyXG4gICB0aGlzLnR5cGUgPSB0eXBlO1xyXG4gICB0aGlzLnBsYXllckdyb3VwID0gcGxheWVyR3JvdXA7XHJcbiAgIHRoaXMucGxheWVyID0gdGhpcy5wbGF5ZXJHcm91cC5yb290O1xyXG4gICB0aGlzLnJhbURpc3QgPSA1MDA7XHJcbiAgIHRoaXMucm90YXRpb25Gb3JjZSA9IDUwO1xyXG4gICB0aGlzLmZhY2luZ0FsbG93YW5jZSA9IE1hdGguUEkgLyAxNTtcclxuICAgdGhpcy50aHJ1c3RlcnNGaXJpbmcgPSBmYWxzZTtcclxuICAgdGhpcy5ndW5zRmlyaW5nID0gZmFsc2U7XHJcbiAgIHN3aXRjaCAodGhpcy50eXBlKSB7XHJcbiAgICAgIGNhc2UgJ3JhbSc6XHJcbiAgICAgIHRoaXMuYWxsb2NhdGVUbygndGhydXN0ZXInKTtcclxuICAgICAgYnJlYWs7XHJcbiAgIH1cclxufTtcclxuXHJcbkVuZW15QUkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRW5lbXlBSTtcclxuXHJcbkVuZW15QUkucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICBzd2l0Y2ggKHRoaXMudHlwZSkge1xyXG4gICAgICBjYXNlICdyYW0nOlxyXG4gICAgICB0aGlzLnJhbVVwZGF0ZSgpO1xyXG4gICAgICBicmVhaztcclxuICAgICAgY2FzZSAnc2hvb3QnOlxyXG4gICAgICB0aGlzLnNob290VXBkYXRlKCk7XHJcbiAgIH1cclxufTtcclxuXHJcbkVuZW15QUkucHJvdG90eXBlLnJhbVVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICBpZiAoIXRoaXMuZ3JvdXAucm9vdCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgIH1cclxuICAgdmFyIHJvb3QgPSB0aGlzLmdyb3VwLnJvb3Q7XHJcbiAgIHZhciBteVBvcyA9IG5ldyBQaGFzZXIuUG9pbnQocm9vdC54LCByb290LnkpO1xyXG4gICB2YXIgcGxheWVyUG9zID0gbmV3IFBoYXNlci5Qb2ludCh0aGlzLnBsYXllci54LCB0aGlzLnBsYXllci55KTtcclxuICAgdmFyIGRpc3QgPSBVdGlscy5kaXN0YW5jZShteVBvcy54LCBteVBvcy55LCBwbGF5ZXJQb3MueCwgcGxheWVyUG9zLnkpO1xyXG4gICBpZiAoZGlzdCA8PSB0aGlzLnJhbURpc3QpIHtcclxuICAgICAgdmFyIGFuZ2xlVG8gPSB0aGlzLmFuZ2xlVG8obXlQb3MsIHBsYXllclBvcyk7XHJcbiAgICAgIHZhciBkaWZmQW5nbGUgPSBhbmdsZVRvIC0gcm9vdC5ib2R5LnJvdGF0aW9uO1xyXG4gICAgICBpZiAoZGlmZkFuZ2xlID4gMCkge1xyXG4gICAgICAgICByb290LmJvZHkuYW5ndWxhckZvcmNlID0gdGhpcy5yb3RhdGlvbkZvcmNlO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgICByb290LmJvZHkuYW5ndWxhckZvcmNlID0gLXRoaXMucm90YXRpb25Gb3JjZTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoTWF0aC5hYnMoZGlmZkFuZ2xlKSA8PSB0aGlzLmZhY2luZ0FsbG93YW5jZSAmJiAhdGhpcy50aHJ1c3RlcnNGaXJpbmcpIHtcclxuICAgICAgICAgdGhpcy5ncm91cC5jYWxsKCdiZWdpbkFjdCcpO1xyXG4gICAgICAgICB0aGlzLnRocnVzdGVyc0ZpcmluZyA9IHRydWU7XHJcbiAgICAgICAgIHRoaXMuYWxsb2NhdGVUbygndGhydXN0ZXInKTtcclxuICAgICAgfSBlbHNlIGlmIChNYXRoLmFicyhkaWZmQW5nbGUpID4gdGhpcy5mYWNpbmdBbGxvd2FuY2UgJiYgdGhpcy50aHJ1c3RlcnNGaXJpbmcpe1xyXG4gICAgICAgICB0aGlzLmdyb3VwLmNhbGwoJ2VuZEFjdCcpO1xyXG4gICAgICAgICB0aGlzLnRocnVzdGVyc0ZpcmluZyA9IGZhbHNlO1xyXG4gICAgICB9XHJcbiAgIH1cclxufTtcclxuXHJcbkVuZW15QUkucHJvdG90eXBlLnNob290VXBkYXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgIGlmICghdGhpcy5ncm91cC5yb290KSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgfVxyXG4gICB2YXIgcm9vdCA9IHRoaXMuZ3JvdXAucm9vdDtcclxuICAgdmFyIG15UG9zID0gbmV3IFBoYXNlci5Qb2ludChyb290LngsIHJvb3QueSk7XHJcbiAgIHZhciBwbGF5ZXJQb3MgPSBuZXcgUGhhc2VyLlBvaW50KHRoaXMucGxheWVyLngsIHRoaXMucGxheWVyLnkpO1xyXG4gICB2YXIgZGlzdCA9IFV0aWxzLmRpc3RhbmNlKG15UG9zLngsIG15UG9zLnksIHBsYXllclBvcy54LCBwbGF5ZXJQb3MueSk7XHJcbiAgIGlmIChkaXN0IDw9IHRoaXMucmFtRGlzdCkge1xyXG4gICAgICB2YXIgYW5nbGVUbyA9IHRoaXMuYW5nbGVUbyhteVBvcywgcGxheWVyUG9zKTtcclxuICAgICAgdmFyIGRpZmZBbmdsZSA9IGFuZ2xlVG8gLSByb290LmJvZHkucm90YXRpb247XHJcbiAgICAgIGlmIChkaWZmQW5nbGUgPiAwKSB7XHJcbiAgICAgICAgIHJvb3QuYm9keS5hbmd1bGFyRm9yY2UgPSB0aGlzLnJvdGF0aW9uRm9yY2U7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgIHJvb3QuYm9keS5hbmd1bGFyRm9yY2UgPSAtdGhpcy5yb3RhdGlvbkZvcmNlO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChNYXRoLmFicyhkaWZmQW5nbGUpIDw9IHRoaXMuZmFjaW5nQWxsb3dhbmNlICYmICF0aGlzLmd1bnNGaXJpbmcpIHtcclxuICAgICAgICAgdGhpcy5ncm91cC5jYWxsKCdiZWdpbkFjdCcpO1xyXG4gICAgICAgICB0aGlzLmd1bnNGaXJpbmcgPSB0cnVlO1xyXG4gICAgICAgICB0aGlzLmFsbG9jYXRlVG8oJ2d1bicpO1xyXG4gICAgICB9IGVsc2UgaWYgKE1hdGguYWJzKGRpZmZBbmdsZSkgPiB0aGlzLmZhY2luZ0FsbG93YW5jZSAmJiB0aGlzLmd1bnNGaXJpbmcpe1xyXG4gICAgICAgICB0aGlzLmdyb3VwLmNhbGwoJ2VuZEFjdCcpO1xyXG4gICAgICAgICB0aGlzLmd1bnNGaXJpbmcgPSBmYWxzZTtcclxuICAgICAgfVxyXG4gICB9XHJcbn07XHJcblxyXG5FbmVteUFJLnByb3RvdHlwZS5hbGxvY2F0ZVRvID0gZnVuY3Rpb24odHlwZSkge1xyXG4gICB2YXIgcGFuZWxzID0gW107XHJcbiAgIHZhciB0eXBlcyA9IFtdO1xyXG4gICBmb3IgKHZhciByb3cgPSAwOyByb3cgPCB0aGlzLmdyb3VwLmN1YmVzV2lkdGgoKTsgcm93KyspIHtcclxuICAgICAgZm9yICh2YXIgY29sID0gMDsgY29sIDwgdGhpcy5ncm91cC5jdWJlc0hlaWdodCgpOyBjb2wrKykge1xyXG4gICAgICAgICB2YXIgY3ViZSA9IHRoaXMuZ3JvdXAuY3ViZXNbcm93XVtjb2xdO1xyXG4gICAgICAgICBpZiAoY3ViZSAmJiBjdWJlLm1vZHVsZSkge1xyXG4gICAgICAgICAgICBpZiAoY3ViZS5tb2R1bGUudHlwZSA9PT0gJ3NvbGFyUGFuZWwnICYmICFjdWJlLm15Q29ubmVjdGlvbikge1xyXG4gICAgICAgICAgICAgICBwYW5lbHMucHVzaChjdWJlLm1vZHVsZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY3ViZS5tb2R1bGUudHlwZSA9PT0gdHlwZSAmJiAhY3ViZS5teUNvbm5lY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgdHlwZXMucHVzaChjdWJlLm1vZHVsZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgIH1cclxuICAgdmFyIGkgPSAwO1xyXG4gICB3aGlsZSAoaSA8IHR5cGVzLmxlbmd0aCAmJiBpIDwgcGFuZWxzLmxlbmd0aCkge1xyXG4gICAgICB2YXIgdGFyUGFuZWwgPSBwYW5lbHNbaV07XHJcbiAgICAgIHZhciB0YXJUeXBlID0gdHlwZXNbaV07XHJcbiAgICAgIHZhciBuZXdDb25uZWN0aW9uID0ge3N0YXJ0OiB0YXJQYW5lbC5jdWJlLCBlbmQ6IHRhclR5cGUuY3ViZX07XHJcbiAgICAgIHRhclBhbmVsLmN1YmUubXlDb25uZWN0aW9uID0gbmV3Q29ubmVjdGlvbjtcclxuICAgICAgdGFyVHlwZS5jdWJlLm15Q29ubmVjdGlvbiA9IG5ld0Nvbm5lY3Rpb247XHJcbiAgICAgIHRoaXMuZ3JvdXAuZGlzcGxheUNvbm5lY3Rpb24odGFyUGFuZWwuY3ViZS5teUNvbm5lY3Rpb24pO1xyXG4gICAgICBpKys7XHJcbiAgIH1cclxufTtcclxuXHJcbkVuZW15QUkucHJvdG90eXBlLmFuZ2xlVG8gPSBmdW5jdGlvbihmcm9tLCB0bykge1xyXG4gIHZhciBhbmdsZVRvT3RoZXIgPSBQaGFzZXIuUG9pbnQuYW5nbGUoZnJvbSwgdG8pO1xyXG4gIGlmIChhbmdsZVRvT3RoZXIgPCAwKSB7IC8vIGZpeCBkdW1iIHBhcnQgb2YgUGhhc2VyLlBvaW50LmFuZ2xlKClcclxuICAgICBhbmdsZVRvT3RoZXIgPSAyICogTWF0aC5QSSArIGFuZ2xlVG9PdGhlcjtcclxuICB9XHJcbiAgYW5nbGVUb090aGVyID0gKGFuZ2xlVG9PdGhlciArIDMvMiAqIE1hdGguUEkpICUgKDIgKiBNYXRoLlBJKTsgLy8gcm90YXRlIDkwIGQgY2xvY2t3aXNlXHJcbiAgcmV0dXJuIGFuZ2xlVG9PdGhlcjtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRW5lbXlBSTtcclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbiIsInZhciBVdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzLmpzJyk7XHJcblxyXG52YXIgTW91c2UgPSBmdW5jdGlvbihnYW1lLCBpbnB1dCwgcGxheWVyR3JvdXApIHtcclxuICAgdGhpcy5nYW1lID0gZ2FtZTtcclxuICAgdGhpcy5pbnB1dCA9IGlucHV0O1xyXG5cdHRoaXMuYm9keSA9IG5ldyBwMi5Cb2R5KCk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxyXG4gICB0aGlzLmdhbWUucGh5c2ljcy5wMi53b3JsZC5hZGRCb2R5KHRoaXMuYm9keSk7XHJcbiAgIC8vIHRoaXMuZ2FtZS5waHlzaWNzLnAyLmVuYWJsZSh0aGlzKTtcclxuICAgXHJcbiAgIHRoaXMuaW5wdXQub25Eb3duLmFkZCh0aGlzLmNsaWNrLCB0aGlzKTtcclxuICAgdGhpcy5pbnB1dC5vblVwLmFkZCh0aGlzLnJlbGVhc2UsIHRoaXMpO1xyXG4gICB0aGlzLmlucHV0LmFkZE1vdmVDYWxsYmFjayh0aGlzLm1vdmUsIHRoaXMpO1xyXG4gICB0aGlzLnggPSAwO1xyXG4gICB0aGlzLnkgPSAwO1xyXG4gICBcclxuICAgdGhpcy5ncmFiYmVkID0gdW5kZWZpbmVkO1xyXG4gICB0aGlzLmxhc3RDbGlja2VkID0gdW5kZWZpbmVkO1xyXG4gICB0aGlzLmxpbmUgPSBuZXcgUGhhc2VyLkxpbmUoMCwgMCwgMCwgMCk7XHJcbiAgIFxyXG4gICB0aGlzLnJlbW92ZVRocmVzaG9sZCA9IDQwMDsgLy8gdGltZSBpbiBtaWxsaXNlY29uZHNcclxuICAgdGhpcy5yZW1vdmVUaW1lID0gMDsgLy8gdGltZSB0aWxsIHRocmVzaG9sZFxyXG4gICBcclxuICAgdGhpcy5wbGF5ZXJHcm91cCA9IHBsYXllckdyb3VwO1xyXG59O1xyXG5cclxuTW91c2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTW91c2U7XHJcblxyXG5Nb3VzZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgIGlmICh0aGlzLmdyYWJiZWQpIHtcclxuICAgICAgdmFyIGFuZ2xlID0gTWF0aC5hdGFuMih0aGlzLmdyYWJiZWQuc3ByaXRlLnkgLSAodGhpcy5pbnB1dC5wb3NpdGlvbi55ICsgdGhpcy5nYW1lLmNhbWVyYS55KSwgdGhpcy5ncmFiYmVkLnNwcml0ZS54IC0gKHRoaXMuaW5wdXQucG9zaXRpb24ueCsgdGhpcy5nYW1lLmNhbWVyYS54KSkgKyBNYXRoLlBJO1xyXG4gICAgICB2YXIgZGlzdCA9IFV0aWxzLmRpc3RhbmNlKHRoaXMuZ3JhYmJlZC5zcHJpdGUueCwgdGhpcy5ncmFiYmVkLnNwcml0ZS55LCAodGhpcy5pbnB1dC5wb3NpdGlvbi54KyB0aGlzLmdhbWUuY2FtZXJhLngpLCAodGhpcy5pbnB1dC5wb3NpdGlvbi55ICsgdGhpcy5nYW1lLmNhbWVyYS55KSk7XHJcbiAgICAgIHZhciB3ZWlnaHQgPSAxMDtcclxuICAgICAgaWYgKCF0aGlzLmdyYWJiZWQuc3ByaXRlLmdyb3VwKSB7XHJcbiAgICAgICAgIHRoaXMuZ3JhYmJlZC5mb3JjZS54ID0gTWF0aC5jb3MoYW5nbGUpICogZGlzdCAqIHdlaWdodDtcclxuICAgICAgICAgdGhpcy5ncmFiYmVkLmZvcmNlLnkgPSBNYXRoLnNpbihhbmdsZSkgKiBkaXN0ICogd2VpZ2h0O1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMubGluZS5zZXRUbyh0aGlzLmdyYWJiZWQuc3ByaXRlLngsIHRoaXMuZ3JhYmJlZC5zcHJpdGUueSwgKHRoaXMuaW5wdXQucG9zaXRpb24ueCsgdGhpcy5nYW1lLmNhbWVyYS54KSwgKHRoaXMuaW5wdXQucG9zaXRpb24ueSArIHRoaXMuZ2FtZS5jYW1lcmEueSkpO1xyXG4gICAgICB0aGlzLnJlbW92ZVRpbWUgKz0gdGhpcy5nYW1lLnRpbWUuZWxhcHNlZDtcclxuICAgICAgaWYodGhpcy5ncmFiYmVkLnNwcml0ZS50YWcgPT09ICdtb2R1bGUnKSB7XHJcblx0XHQgIGlmICh0aGlzLnJlbW92ZVRpbWUgPj0gdGhpcy5yZW1vdmVUaHJlc2hvbGQgJiYgdGhpcy5ncmFiYmVkLnNwcml0ZS5rZXkgIT09ICdhc3Rlcm9pZCcpIHtcclxuXHRcdFx0IHRoaXMuZ3JhYmJlZC5zcHJpdGUucmVtb3ZlKCk7XHJcblx0XHRcdCB0aGlzLnJlbW92ZVRpbWUgPSAwO1xyXG5cdFx0ICB9XHJcblx0ICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgdGhpcy5saW5lLnNldFRvKDAsIDAsIDAsIDApO1xyXG4gICAgfVxyXG4gICAgdmFyIHBvaW50ID0gbmV3IFBoYXNlci5Qb2ludCh0aGlzLngsIHRoaXMueSk7XHJcbiAgICB2YXIgYm9kaWVzID0gdGhpcy5nYW1lLnBoeXNpY3MucDIuaGl0VGVzdChwb2ludCk7XHJcbiAgICBpZiAoYm9kaWVzLmxlbmd0aClcclxuICAgIHtcclxuICAgICAgICB2YXIgaG92ZXIgPSBib2RpZXNbMF0ucGFyZW50O1xyXG4gICAgICAgIGlmIChob3Zlci5zcHJpdGUubW9kdWxlICYmIGhvdmVyLnNwcml0ZS5tb2R1bGUubW91c2VPdmVyKSB7XHJcbiAgICAgICAgICAgaG92ZXIuc3ByaXRlLm1vZHVsZS5tb3VzZU92ZXIoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG5Nb3VzZS5wcm90b3R5cGUuY2xpY2sgPSBmdW5jdGlvbihwb2ludGVyKSB7XHJcbiAgIHZhciBwb2ludCA9IG5ldyBQaGFzZXIuUG9pbnQocG9pbnRlci54ICsgdGhpcy5nYW1lLmNhbWVyYS54LCBwb2ludGVyLnkgKyB0aGlzLmdhbWUuY2FtZXJhLnkpO1xyXG4gICB2YXIgYm9kaWVzID0gdGhpcy5nYW1lLnBoeXNpY3MucDIuaGl0VGVzdChwb2ludCk7XHJcbiAgIGlmIChib2RpZXMubGVuZ3RoKVxyXG4gICB7XHJcbiAgICAgdmFyIHRlbXAgPSBib2RpZXNbMF0ucGFyZW50O1xyXG4gICAgIGlmICh0ZW1wLnNwcml0ZSAmJiB0ZW1wLnNwcml0ZS5tb2R1bGUgJiYgdGVtcC5zcHJpdGUubW9kdWxlLnR5cGUgPT09ICdjb3JlJykge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICB9XHJcbiAgICAgaWYgKHRlbXAuc3ByaXRlICYmIHRlbXAuc3ByaXRlLmdyb3VwICYmIHRlbXAuc3ByaXRlLmdyb3VwICE9PSB0aGlzLnBsYXllckdyb3VwKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgIH1cclxuICAgICB0aGlzLnJlbW92ZVRpbWUgPSAwO1xyXG4gICAgIHRoaXMuZ3JhYmJlZCA9IHRlbXA7XHJcbiAgICAgLy8gY29uc29sZS5sb2codGhpcy5ncmFiYmVkLnNwcml0ZS5uYW1lKTtcclxuICAgICBpZiAodGhpcy5ncmFiYmVkLnNwcml0ZS5tb2R1bGUgJiYgdGhpcy5ncmFiYmVkLnNwcml0ZS5tb2R1bGUuaGFzT3duUHJvcGVydHkoJ21vdXNlRG93bicpKSB7XHJcbiAgICAgICAgdGhpcy5ncmFiYmVkLnNwcml0ZS5tb2R1bGUubW91c2VEb3duKCk7XHJcbiAgICAgfVxyXG4gICAgIGlmICh0aGlzLmxhc3RDbGlja2VkICYmIHRoaXMubGFzdENsaWNrZWQuc3ByaXRlICYmIHRoaXMubGFzdENsaWNrZWQuc3ByaXRlLm1vZHVsZSAmJlxyXG4gICAgIHRoaXMubGFzdENsaWNrZWQuc3ByaXRlLm1vZHVsZS5naXZlVGFyZ2V0KSB7XHJcbiAgICAgICAgdGhpcy5sYXN0Q2xpY2tlZC5zcHJpdGUubW9kdWxlLmdpdmVUYXJnZXQodGhpcy5ncmFiYmVkLnNwcml0ZS5tb2R1bGUpO1xyXG4gICAgIH1cclxuICAgICB0aGlzLmxhc3RDbGlja2VkID0gdGVtcDtcclxuICAgfVxyXG59O1xyXG4gIFxyXG4gTW91c2UucHJvdG90eXBlLnJlbGVhc2UgPSBmdW5jdGlvbigpIHtcclxuICAgaWYgKHRoaXMuZ3JhYmJlZCkge1xyXG4gICAgIHRoaXMuZ3JhYmJlZCA9IHVuZGVmaW5lZDtcclxuICAgfVxyXG59O1xyXG4gIFxyXG5Nb3VzZS5wcm90b3R5cGUubW92ZSA9IGZ1bmN0aW9uKHBvaW50ZXIpIHtcclxuICAgLy8gcDIgdXNlcyBkaWZmZXJlbnQgY29vcmRpbmF0ZSBzeXN0ZW0sIHNvIGNvbnZlcnQgdGhlIHBvaW50ZXIgcG9zaXRpb24gdG8gcDIncyBjb29yZGluYXRlIHN5c3RlbVxyXG4gICB0aGlzLmJvZHkucG9zaXRpb25bMF0gPSB0aGlzLmdhbWUucGh5c2ljcy5wMi5weG1pKHBvaW50ZXIucG9zaXRpb24ueCk7XHJcbiAgIHRoaXMuYm9keS5wb3NpdGlvblsxXSA9IHRoaXMuZ2FtZS5waHlzaWNzLnAyLnB4bWkocG9pbnRlci5wb3NpdGlvbi55KTtcclxuICAgdGhpcy54ID0gcG9pbnRlci5wb3NpdGlvbi54ICsgdGhpcy5nYW1lLmNhbWVyYS54O1xyXG4gICB0aGlzLnkgPSBwb2ludGVyLnBvc2l0aW9uLnkgKyB0aGlzLmdhbWUuY2FtZXJhLnk7XHJcbn07XHJcblxyXG5Nb3VzZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oKSB7XHJcbiAgIHRoaXMuZ2FtZS5kZWJ1Zy5nZW9tKHRoaXMubGluZSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE1vdXNlO1xyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbiIsInZhciBSZW5kZXJhYmxlcyA9IGZ1bmN0aW9uKCkge1xyXG5cdGlmKFJlbmRlcmFibGVzLnByb3RvdHlwZS5leGlzdHMpIHtcclxuXHRcdHJldHVybiBSZW5kZXJhYmxlcy5wcm90b3R5cGUuZXhpc3RpbmdSZWZlcmVuY2U7XHJcblx0fVxyXG5cdFxyXG5cdHRoaXMubGlzdCA9IFtdO1xyXG5cdFJlbmRlcmFibGVzLnByb3RvdHlwZS5leGlzdHMgPSB0cnVlO1xyXG5cdFJlbmRlcmFibGVzLnByb3RvdHlwZS5leGlzdGluZ1JlZmVyZW5jZSA9IHRoaXM7XHJcbn07XHJcblxyXG5SZW5kZXJhYmxlcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSZW5kZXJhYmxlcztcclxuLy9UaGVzZSB2YXIncyBoZWxwIGNyZWF0ZSB0aGUgc2luZ2xldG9uIGZ1bmN0aW9uYWxpdHlcclxuUmVuZGVyYWJsZXMucHJvdG90eXBlLmV4aXN0cyA9IGZhbHNlO1xyXG5SZW5kZXJhYmxlcy5wcm90b3R5cGUuZXhpc3RpbmdSZWZlcmVuY2UgPSBudWxsO1xyXG5cclxuUmVuZGVyYWJsZXMucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uKHN1YnNjcmliZXIpIHtcclxuXHR0aGlzLmxpc3QucHVzaChzdWJzY3JpYmVyKTtcclxufTtcclxuXHJcblJlbmRlcmFibGVzLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uKHVuc3Vic2NyaWJlcikge1xyXG5cdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxpc3QubGVuZ3RoOyBpKyspIHtcclxuXHRcdGlmKHRoaXMubGlzdFtpXSA9PT0gdW5zdWJzY3JpYmVyKSB7XHJcblx0XHRcdHRoaXMubGlzdFtpXSA9IGZhbHNlO1xyXG5cdFx0fVxyXG5cdH1cclxufTtcclxuXHJcblJlbmRlcmFibGVzLnByb3RvdHlwZS5yZW5kZXJBbGwgPSBmdW5jdGlvbigpIHtcclxuXHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5saXN0Lmxlbmd0aDsgaSsrKSB7XHJcblx0XHRpZih0aGlzLmxpc3RbaV0gPT09IGZhbHNlKSB7XHJcblx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5saXN0W2ldLnJlbmRlcigpO1xyXG5cdH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVuZGVyYWJsZXM7IiwiLy8gamF2YXNjcmlwdC1hc3RhciAwLjQuMFxyXG4vLyBodHRwOi8vZ2l0aHViLmNvbS9iZ3JpbnMvamF2YXNjcmlwdC1hc3RhclxyXG4vLyBGcmVlbHkgZGlzdHJpYnV0YWJsZSB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcbi8vIEltcGxlbWVudHMgdGhlIGFzdGFyIHNlYXJjaCBhbGdvcml0aG0gaW4gamF2YXNjcmlwdCB1c2luZyBhIEJpbmFyeSBIZWFwLlxyXG4vLyBJbmNsdWRlcyBCaW5hcnkgSGVhcCAod2l0aCBtb2RpZmljYXRpb25zKSBmcm9tIE1hcmlqbiBIYXZlcmJla2UuXHJcbi8vIGh0dHA6Ly9lbG9xdWVudGphdmFzY3JpcHQubmV0L2FwcGVuZGl4Mi5odG1sXHJcblxyXG4oZnVuY3Rpb24oZGVmaW5pdGlvbikge1xyXG4gICAgLyogZ2xvYmFsIG1vZHVsZSwgZGVmaW5lICovXHJcbiAgICBpZih0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBkZWZpbml0aW9uKCk7XHJcbiAgICB9IGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICAgICAgZGVmaW5lKFtdLCBkZWZpbml0aW9uKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdmFyIGV4cG9ydHMgPSBkZWZpbml0aW9uKCk7XHJcbiAgICAgICAgd2luZG93LmFzdGFyID0gZXhwb3J0cy5hc3RhcjtcclxuICAgICAgICB3aW5kb3cuR3JhcGggPSBleHBvcnRzLkdyYXBoO1xyXG4gICAgfVxyXG59KShmdW5jdGlvbigpIHtcclxuXHJcbmZ1bmN0aW9uIHBhdGhUbyhub2RlKXtcclxuICAgIHZhciBjdXJyID0gbm9kZSxcclxuICAgICAgICBwYXRoID0gW107XHJcbiAgICB3aGlsZShjdXJyLnBhcmVudCkge1xyXG4gICAgICAgIHBhdGgucHVzaChjdXJyKTtcclxuICAgICAgICBjdXJyID0gY3Vyci5wYXJlbnQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcGF0aC5yZXZlcnNlKCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEhlYXAoKSB7XHJcbiAgICByZXR1cm4gbmV3IEJpbmFyeUhlYXAoZnVuY3Rpb24obm9kZSkge1xyXG4gICAgICAgIHJldHVybiBub2RlLmY7XHJcbiAgICB9KTtcclxufVxyXG5cclxudmFyIGFzdGFyID0ge1xyXG4gICAgLyoqXHJcbiAgICAqIFBlcmZvcm0gYW4gQSogU2VhcmNoIG9uIGEgZ3JhcGggZ2l2ZW4gYSBzdGFydCBhbmQgZW5kIG5vZGUuXHJcbiAgICAqIEBwYXJhbSB7R3JhcGh9IGdyYXBoXHJcbiAgICAqIEBwYXJhbSB7R3JpZE5vZGV9IHN0YXJ0XHJcbiAgICAqIEBwYXJhbSB7R3JpZE5vZGV9IGVuZFxyXG4gICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXHJcbiAgICAqIEBwYXJhbSB7Ym9vbH0gW29wdGlvbnMuY2xvc2VzdF0gU3BlY2lmaWVzIHdoZXRoZXIgdG8gcmV0dXJuIHRoZVxyXG4gICAgICAgICAgICAgICBwYXRoIHRvIHRoZSBjbG9zZXN0IG5vZGUgaWYgdGhlIHRhcmdldCBpcyB1bnJlYWNoYWJsZS5cclxuICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuaGV1cmlzdGljXSBIZXVyaXN0aWMgZnVuY3Rpb24gKHNlZVxyXG4gICAgKiAgICAgICAgICBhc3Rhci5oZXVyaXN0aWNzKS5cclxuICAgICovXHJcbiAgICBzZWFyY2g6IGZ1bmN0aW9uKGdyYXBoLCBzdGFydCwgZW5kLCBvcHRpb25zKSB7XHJcbiAgICAgICAgZ3JhcGguY2xlYW5EaXJ0eSgpO1xyXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgICAgIHZhciBoZXVyaXN0aWMgPSBvcHRpb25zLmhldXJpc3RpYyB8fCBhc3Rhci5oZXVyaXN0aWNzLm1hbmhhdHRhbixcclxuICAgICAgICAgICAgY2xvc2VzdCA9IG9wdGlvbnMuY2xvc2VzdCB8fCBmYWxzZTtcclxuXHJcbiAgICAgICAgdmFyIG9wZW5IZWFwID0gZ2V0SGVhcCgpLFxyXG4gICAgICAgICAgICBjbG9zZXN0Tm9kZSA9IHN0YXJ0OyAvLyBzZXQgdGhlIHN0YXJ0IG5vZGUgdG8gYmUgdGhlIGNsb3Nlc3QgaWYgcmVxdWlyZWRcclxuXHJcbiAgICAgICAgc3RhcnQuaCA9IGhldXJpc3RpYyhzdGFydCwgZW5kKTtcclxuXHJcbiAgICAgICAgb3BlbkhlYXAucHVzaChzdGFydCk7XHJcblxyXG4gICAgICAgIHdoaWxlKG9wZW5IZWFwLnNpemUoKSA+IDApIHtcclxuXHJcbiAgICAgICAgICAgIC8vIEdyYWIgdGhlIGxvd2VzdCBmKHgpIHRvIHByb2Nlc3MgbmV4dC4gIEhlYXAga2VlcHMgdGhpcyBzb3J0ZWQgZm9yIHVzLlxyXG4gICAgICAgICAgICB2YXIgY3VycmVudE5vZGUgPSBvcGVuSGVhcC5wb3AoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEVuZCBjYXNlIC0tIHJlc3VsdCBoYXMgYmVlbiBmb3VuZCwgcmV0dXJuIHRoZSB0cmFjZWQgcGF0aC5cclxuICAgICAgICAgICAgaWYoY3VycmVudE5vZGUgPT09IGVuZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhdGhUbyhjdXJyZW50Tm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIE5vcm1hbCBjYXNlIC0tIG1vdmUgY3VycmVudE5vZGUgZnJvbSBvcGVuIHRvIGNsb3NlZCwgcHJvY2VzcyBlYWNoIG9mIGl0cyBuZWlnaGJvcnMuXHJcbiAgICAgICAgICAgIGN1cnJlbnROb2RlLmNsb3NlZCA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICAvLyBGaW5kIGFsbCBuZWlnaGJvcnMgZm9yIHRoZSBjdXJyZW50IG5vZGUuXHJcbiAgICAgICAgICAgIHZhciBuZWlnaGJvcnMgPSBncmFwaC5uZWlnaGJvcnMoY3VycmVudE5vZGUpO1xyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlsID0gbmVpZ2hib3JzLmxlbmd0aDsgaSA8IGlsOyArK2kpIHtcclxuICAgICAgICAgICAgICAgIHZhciBuZWlnaGJvciA9IG5laWdoYm9yc1tpXTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAobmVpZ2hib3IuY2xvc2VkIHx8IG5laWdoYm9yLmlzV2FsbCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTm90IGEgdmFsaWQgbm9kZSB0byBwcm9jZXNzLCBza2lwIHRvIG5leHQgbmVpZ2hib3IuXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVGhlIGcgc2NvcmUgaXMgdGhlIHNob3J0ZXN0IGRpc3RhbmNlIGZyb20gc3RhcnQgdG8gY3VycmVudCBub2RlLlxyXG4gICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBjaGVjayBpZiB0aGUgcGF0aCB3ZSBoYXZlIGFycml2ZWQgYXQgdGhpcyBuZWlnaGJvciBpcyB0aGUgc2hvcnRlc3Qgb25lIHdlIGhhdmUgc2VlbiB5ZXQuXHJcbiAgICAgICAgICAgICAgICB2YXIgZ1Njb3JlID0gY3VycmVudE5vZGUuZyArIG5laWdoYm9yLmdldENvc3QoY3VycmVudE5vZGUpLFxyXG4gICAgICAgICAgICAgICAgICAgIGJlZW5WaXNpdGVkID0gbmVpZ2hib3IudmlzaXRlZDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIWJlZW5WaXNpdGVkIHx8IGdTY29yZSA8IG5laWdoYm9yLmcpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRm91bmQgYW4gb3B0aW1hbCAoc28gZmFyKSBwYXRoIHRvIHRoaXMgbm9kZS4gIFRha2Ugc2NvcmUgZm9yIG5vZGUgdG8gc2VlIGhvdyBnb29kIGl0IGlzLlxyXG4gICAgICAgICAgICAgICAgICAgIG5laWdoYm9yLnZpc2l0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIG5laWdoYm9yLnBhcmVudCA9IGN1cnJlbnROb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgIG5laWdoYm9yLmggPSBuZWlnaGJvci5oIHx8IGhldXJpc3RpYyhuZWlnaGJvciwgZW5kKTtcclxuICAgICAgICAgICAgICAgICAgICBuZWlnaGJvci5nID0gZ1Njb3JlO1xyXG4gICAgICAgICAgICAgICAgICAgIG5laWdoYm9yLmYgPSBuZWlnaGJvci5nICsgbmVpZ2hib3IuaDtcclxuICAgICAgICAgICAgICAgICAgICBncmFwaC5tYXJrRGlydHkobmVpZ2hib3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjbG9zZXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBuZWlnaGJvdXIgaXMgY2xvc2VyIHRoYW4gdGhlIGN1cnJlbnQgY2xvc2VzdE5vZGUgb3IgaWYgaXQncyBlcXVhbGx5IGNsb3NlIGJ1dCBoYXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYSBjaGVhcGVyIHBhdGggdGhhbiB0aGUgY3VycmVudCBjbG9zZXN0IG5vZGUgdGhlbiBpdCBiZWNvbWVzIHRoZSBjbG9zZXN0IG5vZGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5laWdoYm9yLmggPCBjbG9zZXN0Tm9kZS5oIHx8IChuZWlnaGJvci5oID09PSBjbG9zZXN0Tm9kZS5oICYmIG5laWdoYm9yLmcgPCBjbG9zZXN0Tm9kZS5nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VzdE5vZGUgPSBuZWlnaGJvcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFiZWVuVmlzaXRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQdXNoaW5nIHRvIGhlYXAgd2lsbCBwdXQgaXQgaW4gcHJvcGVyIHBsYWNlIGJhc2VkIG9uIHRoZSAnZicgdmFsdWUuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5IZWFwLnB1c2gobmVpZ2hib3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxyZWFkeSBzZWVuIHRoZSBub2RlLCBidXQgc2luY2UgaXQgaGFzIGJlZW4gcmVzY29yZWQgd2UgbmVlZCB0byByZW9yZGVyIGl0IGluIHRoZSBoZWFwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5IZWFwLnJlc2NvcmVFbGVtZW50KG5laWdoYm9yKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChjbG9zZXN0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwYXRoVG8oY2xvc2VzdE5vZGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gTm8gcmVzdWx0IHdhcyBmb3VuZCAtIGVtcHR5IGFycmF5IHNpZ25pZmllcyBmYWlsdXJlIHRvIGZpbmQgcGF0aC5cclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9LFxyXG4gICAgLy8gU2VlIGxpc3Qgb2YgaGV1cmlzdGljczogaHR0cDovL3RoZW9yeS5zdGFuZm9yZC5lZHUvfmFtaXRwL0dhbWVQcm9ncmFtbWluZy9IZXVyaXN0aWNzLmh0bWxcclxuICAgIGhldXJpc3RpY3M6IHtcclxuICAgICAgICBtYW5oYXR0YW46IGZ1bmN0aW9uKHBvczAsIHBvczEpIHtcclxuICAgICAgICAgICAgdmFyIGQxID0gTWF0aC5hYnMocG9zMS54IC0gcG9zMC54KTtcclxuICAgICAgICAgICAgdmFyIGQyID0gTWF0aC5hYnMocG9zMS55IC0gcG9zMC55KTtcclxuICAgICAgICAgICAgcmV0dXJuIGQxICsgZDI7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBkaWFnb25hbDogZnVuY3Rpb24ocG9zMCwgcG9zMSkge1xyXG4gICAgICAgICAgICB2YXIgRCA9IDE7XHJcbiAgICAgICAgICAgIHZhciBEMiA9IE1hdGguc3FydCgyKTtcclxuICAgICAgICAgICAgdmFyIGQxID0gTWF0aC5hYnMocG9zMS54IC0gcG9zMC54KTtcclxuICAgICAgICAgICAgdmFyIGQyID0gTWF0aC5hYnMocG9zMS55IC0gcG9zMC55KTtcclxuICAgICAgICAgICAgcmV0dXJuIChEICogKGQxICsgZDIpKSArICgoRDIgLSAoMiAqIEQpKSAqIE1hdGgubWluKGQxLCBkMikpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBjbGVhbk5vZGU6ZnVuY3Rpb24obm9kZSl7XHJcbiAgICAgICAgbm9kZS5mID0gMDtcclxuICAgICAgICBub2RlLmcgPSAwO1xyXG4gICAgICAgIG5vZGUuaCA9IDA7XHJcbiAgICAgICAgbm9kZS52aXNpdGVkID0gZmFsc2U7XHJcbiAgICAgICAgbm9kZS5jbG9zZWQgPSBmYWxzZTtcclxuICAgICAgICBub2RlLnBhcmVudCA9IG51bGw7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuKiBBIGdyYXBoIG1lbW9yeSBzdHJ1Y3R1cmVcclxuKiBAcGFyYW0ge0FycmF5fSBncmlkSW4gMkQgYXJyYXkgb2YgaW5wdXQgd2VpZ2h0c1xyXG4qIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cclxuKiBAcGFyYW0ge2Jvb2x9IFtvcHRpb25zLmRpYWdvbmFsXSBTcGVjaWZpZXMgd2hldGhlciBkaWFnb25hbCBtb3ZlcyBhcmUgYWxsb3dlZFxyXG4qL1xyXG5mdW5jdGlvbiBHcmFwaChncmlkSW4sIG9wdGlvbnMpIHtcclxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgdGhpcy5ub2RlcyA9IFtdO1xyXG4gICAgdGhpcy5kaWFnb25hbCA9ICEhb3B0aW9ucy5kaWFnb25hbDtcclxuICAgIHRoaXMuZ3JpZCA9IFtdO1xyXG4gICAgZm9yICh2YXIgeCA9IDA7IHggPCBncmlkSW4ubGVuZ3RoOyB4KyspIHtcclxuICAgICAgICB0aGlzLmdyaWRbeF0gPSBbXTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgeSA9IDAsIHJvdyA9IGdyaWRJblt4XTsgeSA8IHJvdy5sZW5ndGg7IHkrKykge1xyXG4gICAgICAgICAgICB2YXIgbm9kZSA9IG5ldyBHcmlkTm9kZSh4LCB5LCByb3dbeV0pO1xyXG4gICAgICAgICAgICB0aGlzLmdyaWRbeF1beV0gPSBub2RlO1xyXG4gICAgICAgICAgICB0aGlzLm5vZGVzLnB1c2gobm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdGhpcy5pbml0KCk7XHJcbn1cclxuXHJcbkdyYXBoLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLmRpcnR5Tm9kZXMgPSBbXTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ub2Rlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGFzdGFyLmNsZWFuTm9kZSh0aGlzLm5vZGVzW2ldKTtcclxuICAgIH1cclxufTtcclxuXHJcbkdyYXBoLnByb3RvdHlwZS5jbGVhbkRpcnR5ID0gZnVuY3Rpb24oKSB7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGlydHlOb2Rlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGFzdGFyLmNsZWFuTm9kZSh0aGlzLmRpcnR5Tm9kZXNbaV0pO1xyXG4gICAgfVxyXG4gICAgdGhpcy5kaXJ0eU5vZGVzID0gW107XHJcbn07XHJcblxyXG5HcmFwaC5wcm90b3R5cGUubWFya0RpcnR5ID0gZnVuY3Rpb24obm9kZSkge1xyXG4gICAgdGhpcy5kaXJ0eU5vZGVzLnB1c2gobm9kZSk7XHJcbn07XHJcblxyXG5HcmFwaC5wcm90b3R5cGUubmVpZ2hib3JzID0gZnVuY3Rpb24obm9kZSkge1xyXG4gICAgdmFyIHJldCA9IFtdLFxyXG4gICAgICAgIHggPSBub2RlLngsXHJcbiAgICAgICAgeSA9IG5vZGUueSxcclxuICAgICAgICBncmlkID0gdGhpcy5ncmlkO1xyXG5cclxuICAgIC8vIFdlc3RcclxuICAgIGlmKGdyaWRbeC0xXSAmJiBncmlkW3gtMV1beV0pIHtcclxuICAgICAgICByZXQucHVzaChncmlkW3gtMV1beV0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEVhc3RcclxuICAgIGlmKGdyaWRbeCsxXSAmJiBncmlkW3grMV1beV0pIHtcclxuICAgICAgICByZXQucHVzaChncmlkW3grMV1beV0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFNvdXRoXHJcbiAgICBpZihncmlkW3hdICYmIGdyaWRbeF1beS0xXSkge1xyXG4gICAgICAgIHJldC5wdXNoKGdyaWRbeF1beS0xXSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTm9ydGhcclxuICAgIGlmKGdyaWRbeF0gJiYgZ3JpZFt4XVt5KzFdKSB7XHJcbiAgICAgICAgcmV0LnB1c2goZ3JpZFt4XVt5KzFdKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5kaWFnb25hbCkge1xyXG4gICAgICAgIC8vIFNvdXRod2VzdFxyXG4gICAgICAgIGlmKGdyaWRbeC0xXSAmJiBncmlkW3gtMV1beS0xXSkge1xyXG4gICAgICAgICAgICByZXQucHVzaChncmlkW3gtMV1beS0xXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBTb3V0aGVhc3RcclxuICAgICAgICBpZihncmlkW3grMV0gJiYgZ3JpZFt4KzFdW3ktMV0pIHtcclxuICAgICAgICAgICAgcmV0LnB1c2goZ3JpZFt4KzFdW3ktMV0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gTm9ydGh3ZXN0XHJcbiAgICAgICAgaWYoZ3JpZFt4LTFdICYmIGdyaWRbeC0xXVt5KzFdKSB7XHJcbiAgICAgICAgICAgIHJldC5wdXNoKGdyaWRbeC0xXVt5KzFdKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIE5vcnRoZWFzdFxyXG4gICAgICAgIGlmKGdyaWRbeCsxXSAmJiBncmlkW3grMV1beSsxXSkge1xyXG4gICAgICAgICAgICByZXQucHVzaChncmlkW3grMV1beSsxXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXQ7XHJcbn07XHJcblxyXG5HcmFwaC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciBncmFwaFN0cmluZyA9IFtdLFxyXG4gICAgICAgIG5vZGVzID0gdGhpcy5ncmlkLCAvLyB3aGVuIHVzaW5nIGdyaWRcclxuICAgICAgICByb3dEZWJ1Zywgcm93LCB5LCBsO1xyXG4gICAgZm9yICh2YXIgeCA9IDAsIGxlbiA9IG5vZGVzLmxlbmd0aDsgeCA8IGxlbjsgeCsrKSB7XHJcbiAgICAgICAgcm93RGVidWcgPSBbXTtcclxuICAgICAgICByb3cgPSBub2Rlc1t4XTtcclxuICAgICAgICBmb3IgKHkgPSAwLCBsID0gcm93Lmxlbmd0aDsgeSA8IGw7IHkrKykge1xyXG4gICAgICAgICAgICByb3dEZWJ1Zy5wdXNoKHJvd1t5XS53ZWlnaHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBncmFwaFN0cmluZy5wdXNoKHJvd0RlYnVnLmpvaW4oJyAnKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZ3JhcGhTdHJpbmcuam9pbignXFxuJyk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBHcmlkTm9kZSh4LCB5LCB3ZWlnaHQpIHtcclxuICAgIHRoaXMueCA9IHg7XHJcbiAgICB0aGlzLnkgPSB5O1xyXG4gICAgdGhpcy53ZWlnaHQgPSB3ZWlnaHQ7XHJcbn1cclxuXHJcbkdyaWROb2RlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuICdbJyArIHRoaXMueCArICcgJyArIHRoaXMueSArICddJztcclxufTtcclxuXHJcbkdyaWROb2RlLnByb3RvdHlwZS5nZXRDb3N0ID0gZnVuY3Rpb24oZnJvbU5laWdoYm9yKSB7XHJcbiAgICAvLyBUYWtlIGRpYWdvbmFsIHdlaWdodCBpbnRvIGNvbnNpZGVyYXRpb24uXHJcbiAgICBpZiAoZnJvbU5laWdoYm9yICYmIGZyb21OZWlnaGJvci54ICE9PSB0aGlzLnggJiYgZnJvbU5laWdoYm9yLnkgIT09IHRoaXMueSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLndlaWdodCAqIDEuNDE0MjE7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy53ZWlnaHQ7XHJcbn07XHJcblxyXG5HcmlkTm9kZS5wcm90b3R5cGUuaXNXYWxsID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy53ZWlnaHQgPT09IDA7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBCaW5hcnlIZWFwKHNjb3JlRnVuY3Rpb24pe1xyXG4gICAgdGhpcy5jb250ZW50ID0gW107XHJcbiAgICB0aGlzLnNjb3JlRnVuY3Rpb24gPSBzY29yZUZ1bmN0aW9uO1xyXG59XHJcblxyXG5CaW5hcnlIZWFwLnByb3RvdHlwZSA9IHtcclxuICAgIHB1c2g6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcclxuICAgICAgICAvLyBBZGQgdGhlIG5ldyBlbGVtZW50IHRvIHRoZSBlbmQgb2YgdGhlIGFycmF5LlxyXG4gICAgICAgIHRoaXMuY29udGVudC5wdXNoKGVsZW1lbnQpO1xyXG5cclxuICAgICAgICAvLyBBbGxvdyBpdCB0byBzaW5rIGRvd24uXHJcbiAgICAgICAgdGhpcy5zaW5rRG93bih0aGlzLmNvbnRlbnQubGVuZ3RoIC0gMSk7XHJcbiAgICB9LFxyXG4gICAgcG9wOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAvLyBTdG9yZSB0aGUgZmlyc3QgZWxlbWVudCBzbyB3ZSBjYW4gcmV0dXJuIGl0IGxhdGVyLlxyXG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmNvbnRlbnRbMF07XHJcbiAgICAgICAgLy8gR2V0IHRoZSBlbGVtZW50IGF0IHRoZSBlbmQgb2YgdGhlIGFycmF5LlxyXG4gICAgICAgIHZhciBlbmQgPSB0aGlzLmNvbnRlbnQucG9wKCk7XHJcbiAgICAgICAgLy8gSWYgdGhlcmUgYXJlIGFueSBlbGVtZW50cyBsZWZ0LCBwdXQgdGhlIGVuZCBlbGVtZW50IGF0IHRoZVxyXG4gICAgICAgIC8vIHN0YXJ0LCBhbmQgbGV0IGl0IGJ1YmJsZSB1cC5cclxuICAgICAgICBpZiAodGhpcy5jb250ZW50Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgdGhpcy5jb250ZW50WzBdID0gZW5kO1xyXG4gICAgICAgICAgICB0aGlzLmJ1YmJsZVVwKDApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfSxcclxuICAgIHJlbW92ZTogZnVuY3Rpb24obm9kZSkge1xyXG4gICAgICAgIHZhciBpID0gdGhpcy5jb250ZW50LmluZGV4T2Yobm9kZSk7XHJcblxyXG4gICAgICAgIC8vIFdoZW4gaXQgaXMgZm91bmQsIHRoZSBwcm9jZXNzIHNlZW4gaW4gJ3BvcCcgaXMgcmVwZWF0ZWRcclxuICAgICAgICAvLyB0byBmaWxsIHVwIHRoZSBob2xlLlxyXG4gICAgICAgIHZhciBlbmQgPSB0aGlzLmNvbnRlbnQucG9wKCk7XHJcblxyXG4gICAgICAgIGlmIChpICE9PSB0aGlzLmNvbnRlbnQubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRbaV0gPSBlbmQ7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5zY29yZUZ1bmN0aW9uKGVuZCkgPCB0aGlzLnNjb3JlRnVuY3Rpb24obm9kZSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2lua0Rvd24oaSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJ1YmJsZVVwKGkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHNpemU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQubGVuZ3RoO1xyXG4gICAgfSxcclxuICAgIHJlc2NvcmVFbGVtZW50OiBmdW5jdGlvbihub2RlKSB7XHJcbiAgICAgICAgdGhpcy5zaW5rRG93bih0aGlzLmNvbnRlbnQuaW5kZXhPZihub2RlKSk7XHJcbiAgICB9LFxyXG4gICAgc2lua0Rvd246IGZ1bmN0aW9uKG4pIHtcclxuICAgICAgICAvLyBGZXRjaCB0aGUgZWxlbWVudCB0aGF0IGhhcyB0byBiZSBzdW5rLlxyXG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5jb250ZW50W25dO1xyXG5cclxuICAgICAgICAvLyBXaGVuIGF0IDAsIGFuIGVsZW1lbnQgY2FuIG5vdCBzaW5rIGFueSBmdXJ0aGVyLlxyXG4gICAgICAgIHdoaWxlIChuID4gMCkge1xyXG5cclxuICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgcGFyZW50IGVsZW1lbnQncyBpbmRleCwgYW5kIGZldGNoIGl0LlxyXG4gICAgICAgICAgICB2YXIgcGFyZW50TiA9ICgobiArIDEpID4+IDEpIC0gMSwgcGFyZW50ID0gdGhpcy5jb250ZW50W3BhcmVudE5dOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcclxuICAgICAgICAgICAgLy8gU3dhcCB0aGUgZWxlbWVudHMgaWYgdGhlIHBhcmVudCBpcyBncmVhdGVyLlxyXG4gICAgICAgICAgICBpZiAodGhpcy5zY29yZUZ1bmN0aW9uKGVsZW1lbnQpIDwgdGhpcy5zY29yZUZ1bmN0aW9uKHBhcmVudCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udGVudFtwYXJlbnROXSA9IGVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnRbbl0gPSBwYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgJ24nIHRvIGNvbnRpbnVlIGF0IHRoZSBuZXcgcG9zaXRpb24uXHJcbiAgICAgICAgICAgICAgICBuID0gcGFyZW50TjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBGb3VuZCBhIHBhcmVudCB0aGF0IGlzIGxlc3MsIG5vIG5lZWQgdG8gc2luayBhbnkgZnVydGhlci5cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBidWJibGVVcDogZnVuY3Rpb24obikge1xyXG4gICAgICAgIC8vIExvb2sgdXAgdGhlIHRhcmdldCBlbGVtZW50IGFuZCBpdHMgc2NvcmUuXHJcbiAgICAgICAgdmFyIGxlbmd0aCA9IHRoaXMuY29udGVudC5sZW5ndGgsXHJcbiAgICAgICAgICAgIGVsZW1lbnQgPSB0aGlzLmNvbnRlbnRbbl0sXHJcbiAgICAgICAgICAgIGVsZW1TY29yZSA9IHRoaXMuc2NvcmVGdW5jdGlvbihlbGVtZW50KTtcclxuXHJcbiAgICAgICAgd2hpbGUodHJ1ZSkge1xyXG4gICAgICAgICAgICAvLyBDb21wdXRlIHRoZSBpbmRpY2VzIG9mIHRoZSBjaGlsZCBlbGVtZW50cy5cclxuICAgICAgICAgICAgdmFyIGNoaWxkMk4gPSAobiArIDEpIDw8IDEsIGNoaWxkMU4gPSBjaGlsZDJOIC0gMTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXHJcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdXNlZCB0byBzdG9yZSB0aGUgbmV3IHBvc2l0aW9uIG9mIHRoZSBlbGVtZW50LCBpZiBhbnkuXHJcbiAgICAgICAgICAgIHZhciBzd2FwID0gbnVsbCxcclxuICAgICAgICAgICAgICAgIGNoaWxkMVNjb3JlO1xyXG4gICAgICAgICAgICAvLyBJZiB0aGUgZmlyc3QgY2hpbGQgZXhpc3RzIChpcyBpbnNpZGUgdGhlIGFycmF5KS4uLlxyXG4gICAgICAgICAgICBpZiAoY2hpbGQxTiA8IGxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgLy8gTG9vayBpdCB1cCBhbmQgY29tcHV0ZSBpdHMgc2NvcmUuXHJcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQxID0gdGhpcy5jb250ZW50W2NoaWxkMU5dO1xyXG4gICAgICAgICAgICAgICAgY2hpbGQxU2NvcmUgPSB0aGlzLnNjb3JlRnVuY3Rpb24oY2hpbGQxKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgc2NvcmUgaXMgbGVzcyB0aGFuIG91ciBlbGVtZW50J3MsIHdlIG5lZWQgdG8gc3dhcC5cclxuICAgICAgICAgICAgICAgIGlmIChjaGlsZDFTY29yZSA8IGVsZW1TY29yZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgc3dhcCA9IGNoaWxkMU47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIERvIHRoZSBzYW1lIGNoZWNrcyBmb3IgdGhlIG90aGVyIGNoaWxkLlxyXG4gICAgICAgICAgICBpZiAoY2hpbGQyTiA8IGxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkMiA9IHRoaXMuY29udGVudFtjaGlsZDJOXSxcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZDJTY29yZSA9IHRoaXMuc2NvcmVGdW5jdGlvbihjaGlsZDIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkMlNjb3JlIDwgKHN3YXAgPT09IG51bGwgPyBlbGVtU2NvcmUgOiBjaGlsZDFTY29yZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBzd2FwID0gY2hpbGQyTjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gSWYgdGhlIGVsZW1lbnQgbmVlZHMgdG8gYmUgbW92ZWQsIHN3YXAgaXQsIGFuZCBjb250aW51ZS5cclxuICAgICAgICAgICAgaWYgKHN3YXAgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udGVudFtuXSA9IHRoaXMuY29udGVudFtzd2FwXTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udGVudFtzd2FwXSA9IGVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICBuID0gc3dhcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIHdlIGFyZSBkb25lLlxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxucmV0dXJuIHtcclxuICAgIGFzdGFyOiBhc3RhcixcclxuICAgIEdyYXBoOiBHcmFwaFxyXG59O1xyXG5cclxufSk7XHJcbiIsInZhciBCb290ID0gZnVuY3Rpb24gKCkge307XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEJvb3Q7XHJcblxyXG5Cb290LnByb3RvdHlwZSA9IHtcclxuXHJcbiAgcHJlbG9hZDogZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy5sb2FkLmltYWdlKCdwcmVsb2FkZXInLCAnYXNzZXRzL3ByZWxvYWRlci5naWYnKTtcclxuICB9LFxyXG5cclxuICBjcmVhdGU6IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMuZ2FtZS5pbnB1dC5tYXhQb2ludGVycyA9IDE7XHJcblxyXG4gICAgaWYgKHRoaXMuZ2FtZS5kZXZpY2UuZGVza3RvcCkge1xyXG4gICAgICAvL3RoaXMuZ2FtZS5zdGFnZS5zY2FsZS5wYWdlQWxpZ25Ib3Jpem9udGFsbHkgPSB0cnVlO1xyXG4gICAgICB0aGlzLmdhbWUuc2NhbGUuc2NhbGVNb2RlID0gUGhhc2VyLlNjYWxlTWFuYWdlci5SRVNJWkU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLmdhbWUuc2NhbGUuc2NhbGVNb2RlID0gUGhhc2VyLlNjYWxlTWFuYWdlci5TSE9XX0FMTDtcclxuICAgICAgdGhpcy5nYW1lLnNjYWxlLm1pbldpZHRoID0gIDQ4MDtcclxuICAgICAgdGhpcy5nYW1lLnNjYWxlLm1pbkhlaWdodCA9IDI2MDtcclxuICAgICAgdGhpcy5nYW1lLnNjYWxlLm1heFdpZHRoID0gNjQwO1xyXG4gICAgICB0aGlzLmdhbWUuc2NhbGUubWF4SGVpZ2h0ID0gNDgwO1xyXG4gICAgICB0aGlzLmdhbWUuc2NhbGUuZm9yY2VMYW5kc2NhcGUgPSB0cnVlO1xyXG4gICAgICB0aGlzLmdhbWUuc2NhbGUucGFnZUFsaWduSG9yaXpvbnRhbGx5ID0gdHJ1ZTtcclxuICAgICAgdGhpcy5nYW1lLnNjYWxlLnNldFNjcmVlblNpemUodHJ1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5nYW1lLnN0YXRlLnN0YXJ0KCdQcmVsb2FkZXInKTtcclxuICB9XHJcbn07XHJcbiIsIi8qXHJcbk1haW4gdGVzdGluZyBlbnZpcm9ubWVudC5cclxuKi9cclxuXHJcbnZhciBSZW5kZXJhYmxlcyA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9uQWNjZXNzL1JlbmRlcmFibGVzJyk7XHJcbnZhciBVSUJ1aWxkZXIgPSByZXF1aXJlKCcuLi91aS9VSUJ1aWxkZXInKTtcclxudmFyIEN1YmUgPSByZXF1aXJlKCcuLi9lbnRpdGllcy9jdWJlJyk7XHJcbnZhciBNb2R1bGVCdWlsZGVyID0gcmVxdWlyZSgnLi4vZW50aXRpZXMvTW9kdWxlQnVpbGRlcicpO1xyXG52YXIgVXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xyXG52YXIgQ3ViZUdyb3VwID0gcmVxdWlyZSgnLi4vZW50aXRpZXMvY3ViZV9ncm91cCcpO1xyXG52YXIgSGFja2FibGUgPSByZXF1aXJlKCcuLi9lbnRpdGllcy9IYWNrYWJsZScpO1xyXG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJy4uL2VmZmVjdHMvRW1pdHRlcicpO1xyXG52YXIgbW91c2VCb2R5OyAvLyBwaHlzaWNzIGJvZHkgZm9yIG1vdXNlXHJcbnZhciBNb3VzZSA9IHJlcXVpcmUoJy4uL2VudGl0aWVzL21vdXNlJyk7XHJcblxyXG52YXIgYmcsIGJnMjtcclxudmFyIG51bVJvaWRzID0gMDtcclxudmFyIG1heFJvaWRzID0gNTA7XHJcbnZhciBhc3Rlcm9pZHMsIGFzdGVyb2lkTGlzdDtcclxudmFyIGxlZnRLZXksIHJpZ2h0S2V5LCBjd0tleSwgY2N3S2V5O1xyXG52YXIgYXN0ZXJvaWRDRywgY3ViZUNHO1xyXG5cclxudmFyIEdhbWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdGhpcy50ZXN0ZW50aXR5ID0gbnVsbDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2FtZTtcclxuXHJcbkdhbWUucHJvdG90eXBlID0ge1xyXG5cdFxyXG4gIGNyZWF0ZTogZnVuY3Rpb24gKCkge1xyXG5cdHRoaXMuZ2FtZS53b3JsZC5zZXRCb3VuZHMoMCwgMCwgODAwMCwgNDAwMCk7XHJcblx0XHJcblx0Ly9DcmVhdGUgdGhlIHR3byBiYWNrZ3JvdW5kIGltYWdlc1xyXG4gICAgYmcgPSB0aGlzLmdhbWUuYWRkLnNwcml0ZSgwLCAwLCAnZWFydGhOaWdodCcpO1xyXG5cdGJnMiA9IHRoaXMuZ2FtZS5hZGQuc3ByaXRlKC04MDAwLCAwLCAnZWFydGhOaWdodCcpO1xyXG5cdFxyXG5cdHRoaXMuZ2FtZS5waHlzaWNzLnN0YXJ0U3lzdGVtKFBoYXNlci5QaHlzaWNzLlAySlMpO1xyXG4gICB0aGlzLmdhbWUucGh5c2ljcy5wMi5zZXRJbXBhY3RFdmVudHModHJ1ZSk7XHJcblxyXG5cdGN1YmVDRyA9IHRoaXMuZ2FtZS5waHlzaWNzLnAyLmNyZWF0ZUNvbGxpc2lvbkdyb3VwKCk7XHJcblx0YXN0ZXJvaWRDRyA9IHRoaXMuZ2FtZS5waHlzaWNzLnAyLmNyZWF0ZUNvbGxpc2lvbkdyb3VwKCk7XHJcblx0XHJcbiAgIHRoaXMubW91c2UgPSBuZXcgTW91c2UodGhpcy5nYW1lLCB0aGlzLmlucHV0KTtcclxuICAgXHJcbiAgIHRoaXMudXBkYXRlRGVwZW5kZW50cyA9IFtdO1xyXG5cclxuXHQvL2NyZWF0ZSBSZW5kZXJhYmxlcyBjbGFzc1xyXG5cdHRoaXMucmVuZGVyYWJsZXMgPSBuZXcgUmVuZGVyYWJsZXMoKTtcclxuXHQvL2NyZWF0ZSB0aGUgVUlCdWlsZGVyXHJcblx0dGhpcy51aUJ1aWxkZXIgPSBuZXcgVUlCdWlsZGVyKHRoaXMsIHRoaXMucmVuZGVyYWJsZXMpOyAgIFxyXG5cdC8vY3JlYXRlIE1vZHVsZUJ1aWxkZXIgYW5kIHN0b3JlIGl0IGluIHRoaXMgZ2FtZSBzdGF0ZSBvYmplY3RcclxuXHR0aGlzLm1vZHVsZUJ1aWxkZXIgPSBuZXcgTW9kdWxlQnVpbGRlcih0aGlzKTtcclxuXHQvL2NyZWF0ZSBhbmQgc3RvcmUgdGhlIGNvcmUgbW9kdWxlXHJcblx0dGhpcy5jb3JlTW9kdWxlID0gdGhpcy5tb2R1bGVCdWlsZGVyLmJ1aWxkKCdjb3JlJywgMTIwMCwgMTIwMCwgdHJ1ZSk7XHJcblx0dGhpcy5jdWJlV2lkdGggPSB0aGlzLmNvcmVNb2R1bGUuY3ViZS53aWR0aDtcclxuXHR0aGlzLmNvcmVNb2R1bGUuY3ViZS5ib2R5LnNldENvbGxpc2lvbkdyb3VwKGN1YmVDRyk7XHJcblx0dGhpcy5jb3JlTW9kdWxlLmN1YmUuYm9keS5jb2xsaWRlcyhbY3ViZUNHLCBhc3Rlcm9pZENHXSk7XHJcblx0dGhpcy5jdWJlQnVmZmVyID0gMjtcclxuXHR2YXIgcGxheWVyR3JvdXAgPSBuZXcgQ3ViZUdyb3VwKHRoaXMsIHRoaXMuY29yZU1vZHVsZS5jdWJlKTtcclxuXHR0aGlzLnVwZGF0ZURlcGVuZGVudHMucHVzaChwbGF5ZXJHcm91cCk7XHJcblx0dGhpcy5wbGF5ZXIgPSBwbGF5ZXJHcm91cDtcclxuICAgdGhpcy5wbGF5ZXIuaXNQbGF5ZXIgPSB0cnVlO1xyXG4gICBcclxuICAgdGhpcy5tb3VzZSA9IG5ldyBNb3VzZSh0aGlzLmdhbWUsIHRoaXMuaW5wdXQsIHBsYXllckdyb3VwKTtcclxuXHR0aGlzLnBsYXllci5pc1BsYXllciA9IHRydWU7XHJcblxyXG5cdC8vQ3JlYXRlIHRoZSBlbWl0dGVyIGZvciB0aGUgYmluYXJ5IHBhcnRpY2xlIGVmZmVjdHNcclxuXHR0aGlzLkJpbmFyeUVtaXR0ZXIgPSBuZXcgRW1pdHRlcih0aGlzKTtcclxuXHRcclxuXHQvL3Rlc3QgaGFja2FibGUgb2JqZWN0XHJcblx0dGhpcy50ZXN0SGFjayA9IG5ldyBIYWNrYWJsZSh0aGlzLCAxNjAwLDEyMDAsICdoYWNrYWJsZTEnLCA0MDApO1xyXG5cclxuXHR0aGlzLnNwYWNlS2V5ID0gdGhpcy5nYW1lLmlucHV0LmtleWJvYXJkLmFkZEtleShQaGFzZXIuS2V5Ym9hcmQuU1BBQ0VCQVIpO1xyXG5cdHRoaXMuZ2FtZS5pbnB1dC5rZXlib2FyZC5hZGRLZXlDYXB0dXJlKFt0aGlzLnNwYWNlS2V5XSk7XHJcblxyXG5cdFxyXG5cdGFzdGVyb2lkcyA9IHRoaXMuZ2FtZS5hZGQuZ3JvdXAoKTtcclxuXHRhc3Rlcm9pZHMuZW5hYmxlQm9keSA9IHRydWU7XHJcblx0YXN0ZXJvaWRzLnBoeXNpY3NCb2R5VHlwZSA9IFBoYXNlci5QaHlzaWNzLlAySlM7XHJcblx0YXN0ZXJvaWRMaXN0ID0gbmV3IFBoYXNlci5BcnJheVNldCgpO1xyXG5cdHRoaXMuZ2VuZXJhdGVBc3Rlcm9pZHMoKTtcclxuXHRcclxuXHRsZWZ0S2V5ID0gdGhpcy5nYW1lLmlucHV0LmtleWJvYXJkLmFkZEtleShQaGFzZXIuS2V5Ym9hcmQuQSk7XHJcblx0cmlnaHRLZXkgPSB0aGlzLmdhbWUuaW5wdXQua2V5Ym9hcmQuYWRkS2V5KFBoYXNlci5LZXlib2FyZC5EKTtcclxuXHRjY3dLZXkgPSB0aGlzLmdhbWUuaW5wdXQua2V5Ym9hcmQuYWRkS2V5KFBoYXNlci5LZXlib2FyZC5RKTtcclxuXHRjd0tleSA9IHRoaXMuZ2FtZS5pbnB1dC5rZXlib2FyZC5hZGRLZXkoUGhhc2VyLktleWJvYXJkLkUpO1xyXG5cdFxyXG5cdC8vREVCVUdHSU5HIExJU1RFTkVSUy0gYWxsb3cgeW91IHRvIGNyZWF0ZSBtb2R1bGVzIGJ5IHByZXNzaW5nIGtleXNcclxuXHQvL2NvcmVcclxuXHR0aGlzLnBsYWNlQ29yZUtleSA9IHRoaXMuZ2FtZS5pbnB1dC5rZXlib2FyZC5hZGRLZXkoUGhhc2VyLktleWJvYXJkLlApO1xyXG5cdHRoaXMucGxhY2VDb3JlS2V5Lm9uRG93bi5hZGQodGhpcy5hZGRDb3JlLCB0aGlzKTtcclxuXHQvL3NoaWVsZFxyXG5cdHRoaXMucGxhY2VTaGllbGRLZXkgPSB0aGlzLmdhbWUuaW5wdXQua2V5Ym9hcmQuYWRkS2V5KFBoYXNlci5LZXlib2FyZC5PKTtcclxuICAgIHRoaXMucGxhY2VTaGllbGRLZXkub25Eb3duLmFkZCh0aGlzLmFkZFNoaWVsZCwgdGhpcyk7XHJcblx0Ly90aHJ1c3RlclxyXG5cdHRoaXMucGxhY2VUaHJ1c3RlcktleSA9IHRoaXMuZ2FtZS5pbnB1dC5rZXlib2FyZC5hZGRLZXkoUGhhc2VyLktleWJvYXJkLkkpO1xyXG4gICAgdGhpcy5wbGFjZVRocnVzdGVyS2V5Lm9uRG93bi5hZGQodGhpcy5hZGRUaHJ1c3RlciwgdGhpcyk7XHJcblx0Ly9zb2xhclBhbmVsXHJcblx0dGhpcy5wbGFjZVNQS2V5ID0gdGhpcy5nYW1lLmlucHV0LmtleWJvYXJkLmFkZEtleShQaGFzZXIuS2V5Ym9hcmQuVSk7XHJcbiAgICB0aGlzLnBsYWNlU1BLZXkub25Eb3duLmFkZCh0aGlzLmFkZFNQLCB0aGlzKTtcclxuXHQvL2hhY2tlclxyXG5cdHRoaXMucGxhY2VIYWNrS2V5ID0gdGhpcy5nYW1lLmlucHV0LmtleWJvYXJkLmFkZEtleShQaGFzZXIuS2V5Ym9hcmQuWSk7XHJcblx0dGhpcy5wbGFjZUhhY2tLZXkub25Eb3duLmFkZCh0aGlzLmFkZEhhY2ssIHRoaXMpO1xyXG5cdC8vZ3VuXHJcblx0dGhpcy5wbGFjZUd1bktleSA9IHRoaXMuZ2FtZS5pbnB1dC5rZXlib2FyZC5hZGRLZXkoUGhhc2VyLktleWJvYXJkLlQpO1xyXG4gICAgdGhpcy5wbGFjZUd1bktleS5vbkRvd24uYWRkKHRoaXMuYWRkR3VuLCB0aGlzKTtcclxuXHQvL0VORFxyXG4gICAgXHJcbiAgICAvLyBEZWJ1ZyBjb250cm9sbGVyXHJcbiAgICB0aGlzLmRlYnVnS2V5ID0gdGhpcy5nYW1lLmlucHV0LmtleWJvYXJkLmFkZEtleShQaGFzZXIuS2V5Ym9hcmQuSCk7XHJcbiAgICB0aGlzLmRlYnVnS2V5Lm9uRG93bi5hZGQodGhpcy5kZWJ1ZywgdGhpcyk7XHJcbiAgICB0aGlzLnJvb3RTcGF3bmVkID0gZmFsc2U7XHJcbiAgICBcclxuICAgIHRoaXMuZGVidWdOdW0gPSAwO1xyXG4gICAgdGhpcy5teVJvb3QgPSB1bmRlZmluZWQ7XHJcblxyXG5cdCB0aGlzLmdhbWUuY2FtZXJhLnNldFBvc2l0aW9uKDEwMDAsIDEwMDApO1xyXG4gICAgXHJcbiAgICB0aGlzLmxldmVsRGF0YSA9IEpTT04ucGFyc2UodGhpcy5nYW1lLmNhY2hlLmdldFRleHQoJ2xldmVsX29uZScpKTtcclxuICAgIC8vdGhpcy5sb2FkRGF0YSgpO1xyXG4gICAgXHJcbiAgICB0aGlzLmp1aWN5ID0gdGhpcy5nYW1lLnBsdWdpbnMuYWRkKG5ldyBQaGFzZXIuUGx1Z2luLkp1aWN5KHRoaXMpKTtcclxuICAgIHRoaXMuZ2FtZS5jYW1lcmEuZm9sbG93KHRoaXMuY29yZU1vZHVsZS5jdWJlKTtcclxuICB9LFxyXG4gIFxyXG4gIGxvYWREYXRhOiBmdW5jdGlvbigpIHtcclxuICAgICAgdmFyIG15TGV2ZWwgPSB0aGlzLmxldmVsRGF0YVsnbGV2ZWxfb25lJ107XHJcbiAgICAgIGZvciAodmFyIGtleSBpbiBteUxldmVsKSB7XHJcbiAgICAgICAgIGlmIChteUxldmVsLmhhc093blByb3BlcnR5KGtleSkpIHtcclxuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBteUxldmVsW2tleV07XHJcbiAgICAgICAgICAgIGlmIChlbGVtZW50Lmhhc093blByb3BlcnR5KCdibHVlcHJpbnQnKSkgeyAvLyBlbmVteSB0eXBlXHJcbiAgICAgICAgICAgICAgIHZhciBlbmVteVggPSBlbGVtZW50Wyd4X3BvcyddO1xyXG4gICAgICAgICAgICAgICB2YXIgZW5lbXlZID0gZWxlbWVudFsneV9wb3MnXTtcclxuICAgICAgICAgICAgICAgdmFyIGVuZW15R3JvdXAgPSBuZXcgQ3ViZUdyb3VwKHRoaXMsIHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgICAgIHRoaXMudXBkYXRlRGVwZW5kZW50cy5wdXNoKGVuZW15R3JvdXApO1xyXG4gICAgICAgICAgICAgICB2YXIgYmx1ZXByaW50ID0gZWxlbWVudFsnYmx1ZXByaW50J107XHJcbiAgICAgICAgICAgICAgIC8vIHZhciBwcmFjdGljYWwgPSBbXTtcclxuICAgICAgICAgICAgICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgYmx1ZXByaW50Lmxlbmd0aDsgcm93KyspIHtcclxuICAgICAgICAgICAgICAgICAgLy8gdmFyIG5ld0NvbCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCBibHVlcHJpbnRbcm93XS5sZW5ndGg7IGNvbCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgIHZhciB0eXBlID0gYmx1ZXByaW50W3Jvd11bY29sXTtcclxuICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld01vZHVsZSA9IHRoaXMubW9kdWxlQnVpbGRlci5idWlsZCh0eXBlLCBlbmVteVggKyByb3cgKiAodGhpcy5jdWJlV2lkdGggKyB0aGlzLmN1YmVCdWZmZXIpLFxyXG4gICAgICAgICAgICAgICAgICAgICBlbmVteVkgLSBjb2wgKiAodGhpcy5jdWJlV2lkdGggKyB0aGlzLmN1YmVCdWZmZXIpLCBmYWxzZSk7XHJcblx0XHRcdFx0XHQgbmV3TW9kdWxlLmN1YmUuYm9keS5zZXRDb2xsaXNpb25Hcm91cChjdWJlQ0cpO1xyXG5cdFx0XHRcdFx0IG5ld01vZHVsZS5jdWJlLmJvZHkuY29sbGlkZXMoW2N1YmVDRywgYXN0ZXJvaWRDR10pO1xyXG4gICAgICAgICAgICAgICAgICAgICAvLyBuZXdDb2wucHVzaChuZXdNb2R1bGUuY3ViZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgIHZhciBwb2ludCA9IG5ldyBQaGFzZXIuUG9pbnQocm93LCBjb2wpO1xyXG4gICAgICAgICAgICAgICAgICAgICBlbmVteUdyb3VwLmFkZChuZXdNb2R1bGUuY3ViZSwgcG9pbnQpO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIC8vIHByYWN0aWNhbC5wdXNoKG5ld0NvbCk7XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgLy8gVE9ETzogZ2l2ZSBkaWZmZXJlbnQgdHlwZXMgaGVyZVxyXG4gICAgICAgICAgICAgICBlbmVteUdyb3VwLmdpdmVBSSgncmFtJywgdGhpcy5wbGF5ZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgIH1cclxuICAgICAgfVxyXG4gIH0sXHJcblxyXG4gIHVwZGF0ZTogZnVuY3Rpb24gKCkgeyAgICBcclxuXHRpZihsZWZ0S2V5LmlzRG93bikge1xyXG5cdFx0aWYodGhpcy5jb3JlTW9kdWxlLmN1YmUuYm9keS5hbmd1bGFyVmVsb2NpdHkgPiAtOSkgeyBcclxuXHRcdFx0dGhpcy5jb3JlTW9kdWxlLmN1YmUuYm9keS5hbmd1bGFyRm9yY2UgKz0gLTUgKiBNYXRoLnBvdyh0aGlzLnBsYXllci5udW1DdWJlcywgMS42NSk7XHJcblx0XHR9XHJcblx0fVxyXG5cdFxyXG5cdGlmKHJpZ2h0S2V5LmlzRG93bikge1xyXG5cdFx0aWYodGhpcy5jb3JlTW9kdWxlLmN1YmUuYm9keS5hbmd1bGFyVmVsb2NpdHkgPCA5KSB7XHJcblx0XHRcdHRoaXMuY29yZU1vZHVsZS5jdWJlLmJvZHkuYW5ndWxhckZvcmNlICs9IDUgKiBNYXRoLnBvdyh0aGlzLnBsYXllci5udW1DdWJlcywgMS42NSk7XHJcblx0XHR9XHJcblx0fVxyXG5cdFxyXG5cdGlmKGNjd0tleS5pc0Rvd24pIHtcclxuXHRcdGlmKHRoaXMubW91c2UuZ3JhYmJlZCAhPT0gdW5kZWZpbmVkICYmIHRoaXMubW91c2UuZ3JhYmJlZC5zcHJpdGUuZ3JvdXAgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHR0aGlzLm1vdXNlLmdyYWJiZWQuYW5ndWxhckZvcmNlICs9IC01O1xyXG5cdFx0fVxyXG5cdH1cclxuXHRcclxuXHRpZihjd0tleS5pc0Rvd24pIHtcclxuXHRcdGlmKHRoaXMubW91c2UuZ3JhYmJlZCAhPT0gdW5kZWZpbmVkICYmIHRoaXMubW91c2UuZ3JhYmJlZC5zcHJpdGUuZ3JvdXAgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHR0aGlzLm1vdXNlLmdyYWJiZWQuYW5ndWxhckZvcmNlICs9IDU7XHJcblx0XHR9XHJcblx0fVxyXG5cdFxyXG5cdHRoaXMubW91c2UudXBkYXRlKCk7XHJcblx0dGhpcy5zY3JvbGxCRygpO1xyXG4gICBcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudXBkYXRlRGVwZW5kZW50cy5sZW5ndGg7IGkrKykge1xyXG5cdFx0aWYgKHRoaXMudXBkYXRlRGVwZW5kZW50c1tpXS51cGRhdGUpIHtcclxuXHRcdFx0dGhpcy51cGRhdGVEZXBlbmRlbnRzW2ldLnVwZGF0ZSgpO1xyXG5cdFx0fVxyXG5cdH1cclxuICB9LFxyXG4gIFxyXG4gIHJlbmRlcjogZnVuY3Rpb24gKCkge1xyXG5cdHRoaXMubW91c2UucmVuZGVyKCk7XHJcblx0dGhpcy5yZW5kZXJhYmxlcy5yZW5kZXJBbGwoKTtcclxuICB9LFxyXG4gIFxyXG5cdHNjcm9sbEJHOiBmdW5jdGlvbigpIHtcclxuXHRcdGJnLnggKz0gMC4xMjU7XHJcblx0XHRpZihiZy54ID49IDgwMDApIHtcclxuXHRcdFx0YmcueCArPSAwO1xyXG5cdFx0fVxyXG5cdFx0YmcyLnggKz0gMC4xMjU7XHJcblx0XHRpZihiZzIueCA+PSA4MDAwKSB7XHJcblx0XHRcdGJnMi54ID0gMDtcclxuXHRcdH1cclxuXHR9LFxyXG5cdFxyXG5cdGdlbmVyYXRlQXN0ZXJvaWRzOiBmdW5jdGlvbigpIHtcclxuXHRcdGZvcig7bnVtUm9pZHMgPCBtYXhSb2lkczsgbnVtUm9pZHMrKykge1xyXG5cdFx0XHR2YXIgY29pbkEgPSB0aGlzLmdhbWUucm5kLmludGVnZXJJblJhbmdlKDAsMSk7XHJcblx0XHRcdHZhciBjb2luQiA9IHRoaXMuZ2FtZS5ybmQuaW50ZWdlckluUmFuZ2UoMCwxKTtcclxuXHRcdFx0dmFyIGFzdGVyb2lkO1xyXG5cdFx0XHRpZihjb2luQSA9PT0gMSkge1xyXG5cdFx0XHRcdGlmKGNvaW5CID09PSAxKSB7IC8vU3Bhd24gYXN0ZXJvaWQgYWJvdmUgc2NyZWVuXHJcblx0XHRcdFx0XHRhc3Rlcm9pZCA9IGFzdGVyb2lkcy5jcmVhdGUodGhpcy5jb3JlTW9kdWxlLmN1YmUueCArIHRoaXMuZ2FtZS5ybmQuaW50ZWdlckluUmFuZ2UoLXRoaXMuZ2FtZS5jYW1lcmEud2lkdGgvMiwgdGhpcy5nYW1lLmNhbWVyYS53aWR0aC8yKSwgdGhpcy5jb3JlTW9kdWxlLmN1YmUueSAtIHRoaXMuZ2FtZS5jYW1lcmEuaGVpZ2h0LzIgLSB0aGlzLmdhbWUucm5kLmludGVnZXJJblJhbmdlKDMyLCAzMDApLCAnYXN0ZXJvaWQnKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZSB7IC8vU3Bhd24gYXN0ZXJvaWQgYmVsb3cgc2NyZWVuXHJcblx0XHRcdFx0XHRhc3Rlcm9pZCA9IGFzdGVyb2lkcy5jcmVhdGUodGhpcy5jb3JlTW9kdWxlLmN1YmUueCArIHRoaXMuZ2FtZS5ybmQuaW50ZWdlckluUmFuZ2UoLXRoaXMuZ2FtZS5jYW1lcmEud2lkdGgvMiwgdGhpcy5nYW1lLmNhbWVyYS53aWR0aC8yKSwgdGhpcy5jb3JlTW9kdWxlLmN1YmUueSArIHRoaXMuZ2FtZS5jYW1lcmEuaGVpZ2h0LzIgKyB0aGlzLmdhbWUucm5kLmludGVnZXJJblJhbmdlKDMyLCAzMDApLCAnYXN0ZXJvaWQnKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0aWYoY29pbkIgPT09IDEpIHsgLy9TcGF3biBhc3Rlcm9pZCB0byBsZWZ0IG9mIHNjcmVlblxyXG5cdFx0XHRcdFx0YXN0ZXJvaWQgPSBhc3Rlcm9pZHMuY3JlYXRlKHRoaXMuY29yZU1vZHVsZS5jdWJlLnggLSB0aGlzLmdhbWUuY2FtZXJhLndpZHRoLzIgLSB0aGlzLmdhbWUucm5kLmludGVnZXJJblJhbmdlKDMyLCAzMDApLCB0aGlzLmNvcmVNb2R1bGUuY3ViZS55ICsgdGhpcy5nYW1lLnJuZC5pbnRlZ2VySW5SYW5nZSgtdGhpcy5nYW1lLmNhbWVyYS5oZWlnaHQvMiwgdGhpcy5nYW1lLmNhbWVyYS5oZWlnaHQvMiksICdhc3Rlcm9pZCcpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbHNlIHsgLy9TcGF3biBhc3Rlcm9pZCB0byByaWdodFxyXG5cdFx0XHRcdFx0YXN0ZXJvaWQgPSBhc3Rlcm9pZHMuY3JlYXRlKHRoaXMuY29yZU1vZHVsZS5jdWJlLnggKyB0aGlzLmdhbWUuY2FtZXJhLndpZHRoLzIgKyB0aGlzLmdhbWUucm5kLmludGVnZXJJblJhbmdlKDMyLCAzMDApLCB0aGlzLmNvcmVNb2R1bGUuY3ViZS55ICsgdGhpcy5nYW1lLnJuZC5pbnRlZ2VySW5SYW5nZSgtdGhpcy5nYW1lLmNhbWVyYS5oZWlnaHQvMiwgdGhpcy5nYW1lLmNhbWVyYS5oZWlnaHQvMiksICdhc3Rlcm9pZCcpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRcclxuXHRcdFx0YXN0ZXJvaWQuYm9keS5zZXRDaXJjbGUoMTYpOyAvL0NoYW5nZSB0aGUgY29sbGlzaW9uIGRldGVjdGlvbiBmcm9tIGFuIEFBQkIgdG8gYSBjaXJjbGVcclxuXHRcdFx0YXN0ZXJvaWQuYm9keS5hbmd1bGFyRGFtcGluZyA9IDA7XHJcblx0XHRcdGFzdGVyb2lkLmJvZHkuZGFtcGluZyA9IDA7XHJcblx0XHRcdGFzdGVyb2lkLmJvZHkucm90YXRpb24gPSB0aGlzLmdhbWUucm5kLnJlYWxJblJhbmdlKDAsIDIgKiAzLjE0KTtcclxuXHRcdFx0YXN0ZXJvaWQuYm9keS5mb3JjZS54ID0gdGhpcy5nYW1lLnJuZC5pbnRlZ2VySW5SYW5nZSgtMTAsIDEwKSAqIDc1MDtcclxuXHRcdFx0YXN0ZXJvaWQuYm9keS5mb3JjZS55ID0gdGhpcy5nYW1lLnJuZC5pbnRlZ2VySW5SYW5nZSgtMTAsIDEwKSAqIDc1MDtcclxuXHRcdFx0YXN0ZXJvaWQuYm9keS5zZXRDb2xsaXNpb25Hcm91cChhc3Rlcm9pZENHKTtcclxuXHRcdFx0YXN0ZXJvaWQuYm9keS5jb2xsaWRlcyhbYXN0ZXJvaWRDRywgY3ViZUNHXSk7XHJcblx0XHRcdGFzdGVyb2lkLmJvZHkuY29sbGlkZVdvcmxkQm91bmRzID0gZmFsc2U7XHJcblx0XHRcdGFzdGVyb2lkLmF1dG9DdWxsID0gdHJ1ZTtcclxuXHRcdFx0YXN0ZXJvaWQuY2hlY2tXb3JsZEJvdW5kcyA9IHRydWU7XHJcblx0XHRcdGFzdGVyb2lkLmV2ZW50cy5vbk91dE9mQm91bmRzLmFkZCh0aGlzLnJlc2V0QXN0ZXJvaWQsIGFzdGVyb2lkKTtcclxuXHRcdFx0YXN0ZXJvaWRMaXN0LmFkZChhc3Rlcm9pZCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHRcclxuXHRyZXNldEFzdGVyb2lkOiBmdW5jdGlvbigpIHsgLy9OZWVkcyB0byBiZSB1cGRhdGVkIG9uY2UgY29sbGlzaW9uIGdyb3VwcyBhcmUgd29ya2luZ1xyXG5cdFx0Ly90aGlzLm9iai54ID0gMTA7XHJcblx0XHQvL3RoaXMub2JqLnkgPSAxMDtcclxuXHR9LFxyXG5cdFxyXG4gIC8vREVCVUcgRlVOQ1RJT05TLSBldmVudCBmdW5jdGlvbnMgY2FsbGVkIGZyb20gbGlzdGVuZXJzIHRoYXQgYWxsb3cgeW91IHRvIGNyZWF0ZSBtb2R1bGVzIHdpdGgga2V5IHByZXNzZXNcclxuICBhZGRDb3JlOiBmdW5jdGlvbiAoKSB7IFxyXG5cdC8vQXR0ZW1wdHMgdG8gY3JlYXRlIG1vcmUgY29yZSBtb2R1bGVzIGhlcmUgd2lsbCBvbmx5IHJldHVybiB0aGUgZXhpc3RpbmcgY29yZVxyXG5cdHZhciBuZXdNb2R1bGUgPSB0aGlzLm1vZHVsZUJ1aWxkZXIuYnVpbGQoJ2NvcmUnLCB0aGlzLm1vdXNlLngsIHRoaXMubW91c2UueSwgdHJ1ZSk7XHJcblx0bmV3TW9kdWxlLmN1YmUuYm9keS5zZXRDb2xsaXNpb25Hcm91cChjdWJlQ0cpO1xyXG5cdG5ld01vZHVsZS5jdWJlLmJvZHkuY29sbGlkZXMoW2N1YmVDRywgYXN0ZXJvaWRDR10pO1xyXG4gIH0sXHJcbiAgYWRkU2hpZWxkOiBmdW5jdGlvbiAoKSB7XHJcblx0dmFyIG5ld01vZHVsZSA9IHRoaXMubW9kdWxlQnVpbGRlci5idWlsZCgnc2hpZWxkJywgdGhpcy5tb3VzZS54LCB0aGlzLm1vdXNlLnksIHRydWUpO1xyXG5cdG5ld01vZHVsZS5jdWJlLmJvZHkuc2V0Q29sbGlzaW9uR3JvdXAoY3ViZUNHKTtcclxuXHRuZXdNb2R1bGUuY3ViZS5ib2R5LmNvbGxpZGVzKFtjdWJlQ0csIGFzdGVyb2lkQ0ddKTtcclxuICB9LFxyXG4gIGFkZFRocnVzdGVyOiBmdW5jdGlvbiAoKSB7XHJcblx0dmFyIG5ld01vZHVsZSA9IHRoaXMubW9kdWxlQnVpbGRlci5idWlsZCgndGhydXN0ZXInLCB0aGlzLm1vdXNlLngsIHRoaXMubW91c2UueSwgdHJ1ZSk7XHJcblx0bmV3TW9kdWxlLmN1YmUuYm9keS5zZXRDb2xsaXNpb25Hcm91cChjdWJlQ0cpO1xyXG5cdG5ld01vZHVsZS5jdWJlLmJvZHkuY29sbGlkZXMoW2N1YmVDRywgYXN0ZXJvaWRDR10pO1xyXG4gIH0sXHJcbiAgYWRkU1A6IGZ1bmN0aW9uICgpIHtcclxuXHR2YXIgbmV3TW9kdWxlID0gdGhpcy5tb2R1bGVCdWlsZGVyLmJ1aWxkKCdzb2xhclBhbmVsJywgdGhpcy5tb3VzZS54LCB0aGlzLm1vdXNlLnksIHRydWUpO1xyXG5cdG5ld01vZHVsZS5jdWJlLmJvZHkuc2V0Q29sbGlzaW9uR3JvdXAoY3ViZUNHKTtcclxuXHRuZXdNb2R1bGUuY3ViZS5ib2R5LmNvbGxpZGVzKFtjdWJlQ0csIGFzdGVyb2lkQ0ddKTtcclxuICB9LFxyXG4gIGFkZEhhY2s6IGZ1bmN0aW9uICgpIHtcclxuXHR2YXIgbmV3TW9kdWxlID0gdGhpcy5tb2R1bGVCdWlsZGVyLmJ1aWxkKCdoYWNrZXInLCB0aGlzLm1vdXNlLngsIHRoaXMubW91c2UueSwgdHJ1ZSk7XHJcblx0bmV3TW9kdWxlLmN1YmUuYm9keS5zZXRDb2xsaXNpb25Hcm91cChjdWJlQ0cpO1xyXG5cdG5ld01vZHVsZS5jdWJlLmJvZHkuY29sbGlkZXMoW2N1YmVDRywgYXN0ZXJvaWRDR10pO1xyXG4gIH0sXHJcbiAgYWRkR3VuOiBmdW5jdGlvbiAoKSB7XHJcblx0dmFyIG5ld01vZHVsZSA9IHRoaXMubW9kdWxlQnVpbGRlci5idWlsZCgnZ3VuJywgdGhpcy5tb3VzZS54LCB0aGlzLm1vdXNlLnksIHRydWUpO1xyXG5cdG5ld01vZHVsZS5jdWJlLmJvZHkuc2V0Q29sbGlzaW9uR3JvdXAoY3ViZUNHKTtcclxuXHRuZXdNb2R1bGUuY3ViZS5ib2R5LmNvbGxpZGVzKFtjdWJlQ0csIGFzdGVyb2lkQ0ddKTtcclxuICB9LFxyXG5cclxuICBkZWJ1ZzogZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy5qdWljeS5zaGFrZSgpO1xyXG4gIH1cclxufTtcclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuIiwidmFyIE1lbnUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdGhpcy50ZXh0ID0gbnVsbDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTWVudTtcclxuXHJcbk1lbnUucHJvdG90eXBlID0ge1xyXG5cclxuICBjcmVhdGU6IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciB4ID0gdGhpcy5nYW1lLndpZHRoIC8gMjtcclxuICAgIHZhciB5ID0gdGhpcy5nYW1lLmhlaWdodCAvIDI7XHJcblxyXG4gICAgdmFyIHN0eWxlID0geyBmb250OiAnNjVweCBBcmlhbCcsIGZpbGw6ICcjZmZmZmZmJywgYWxpZ246ICdjZW50ZXInIH07XHJcbiAgICB0aGlzLnRpdGxlID0gdGhpcy5nYW1lLmFkZC50ZXh0KHRoaXMuZ2FtZS53b3JsZC5jZW50ZXJYLCB0aGlzLmdhbWUud29ybGQuY2VudGVyWSAtIDI1MCwgJ0Fib3ZlIFRoZSBJcm9uIEN1cnRhaW4nLCBzdHlsZSk7XHJcbiAgICB0aGlzLm5ld0dhbWUgPSB0aGlzLmdhbWUuYWRkLnRleHQodGhpcy5nYW1lLndvcmxkLmNlbnRlclgsIHRoaXMuZ2FtZS53b3JsZC5jZW50ZXJZIC0gMTUwLCAnTmV3IFNpbXVsYXRpb24nLCBzdHlsZSk7XHJcbiAgICB0aGlzLmxldmVsID0gdGhpcy5nYW1lLmFkZC50ZXh0KHRoaXMuZ2FtZS53b3JsZC5jZW50ZXJYLCB0aGlzLmdhbWUud29ybGQuY2VudGVyWSAtIDUwLCAnTWlzc2lvbiBTZWxlY3QnLCBzdHlsZSk7XHJcbiAgICB0aGlzLmNvbnRyb2xzID0gdGhpcy5nYW1lLmFkZC50ZXh0KHRoaXMuZ2FtZS53b3JsZC5jZW50ZXJYLCB0aGlzLmdhbWUud29ybGQuY2VudGVyWSArIDUwLCAnTWFudWFsJywgc3R5bGUpO1xyXG4gICAgdGhpcy5jcmVkaXRzID0gdGhpcy5nYW1lLmFkZC50ZXh0KHRoaXMuZ2FtZS53b3JsZC5jZW50ZXJYLCB0aGlzLmdhbWUud29ybGQuY2VudGVyWSArIDE1MCwgJ0NyZWRpdHMnLCBzdHlsZSk7XHJcblxyXG4gICAgdGhpcy5pbnB1dC5vbkRvd24uYWRkKHRoaXMub25Eb3duLCB0aGlzKTtcclxuICB9LFxyXG5cclxuICB1cGRhdGU6IGZ1bmN0aW9uICgpIHtcclxuICB9LFxyXG5cclxuICBvbkRvd246IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMuZ2FtZS5zdGF0ZS5zdGFydChwbGF5ZXJTdGF0ZS5jdXJyZW50TGV2ZWwpOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcclxuICB9XHJcbn07XHJcbiIsInZhciBQcmVsb2FkZXIgPSBmdW5jdGlvbiAoZ2FtZSkge1xyXG4gIGdhbWUgPSBudWxsO1xyXG4gIHRoaXMuYXNzZXQgPSBudWxsO1xyXG4gIHRoaXMucmVhZHkgPSBmYWxzZTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUHJlbG9hZGVyO1xyXG5cclxuUHJlbG9hZGVyLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgcHJlbG9hZDogZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy5hc3NldCA9IHRoaXMuYWRkLnNwcml0ZSg2NDAsIDM2MCwgJ3ByZWxvYWRlcicpO1xyXG4gICAgdGhpcy5hc3NldC5hbmNob3Iuc2V0VG8oMC41LCAwLjUpO1xyXG5cclxuICAgIHRoaXMubG9hZC5vbkxvYWRDb21wbGV0ZS5hZGRPbmNlKHRoaXMub25Mb2FkQ29tcGxldGUsIHRoaXMpO1xyXG4gICAgdGhpcy5sb2FkLnNldFByZWxvYWRTcHJpdGUodGhpcy5hc3NldCk7XHJcbiAgICB0aGlzLmxvYWQuaW1hZ2UoJ3Rlc3RzcHJpdGUnLCAnYXNzZXRzL3Rlc3QyLnBuZycpO1xyXG5cdHRoaXMubG9hZC5zcHJpdGVzaGVldCgnY29yZScsICdhc3NldHMvY29yZVNoZWV0LnBuZycsIDY0LCA2NCk7IFxyXG5cdHRoaXMubG9hZC5zcHJpdGVzaGVldCgndGhydXN0ZXInLCAnYXNzZXRzL3RocnVzdGVyU2hlZXQucG5nJywgNjQsIDY0KTtcclxuXHR0aGlzLmxvYWQuc3ByaXRlc2hlZXQoJ2d1bicsICdhc3NldHMvZ3VuU2hlZXQucG5nJywgNjQsIDY0KTtcclxuXHR0aGlzLmxvYWQuaW1hZ2UoJ3NoaWVsZCcsICdhc3NldHMvc2hpZWxkLnBuZycpO1xyXG5cdHRoaXMubG9hZC5pbWFnZSgnc29sYXJQYW5lbCcsICdhc3NldHMvc29sYXJQYW5lbC5wbmcnKTtcclxuXHR0aGlzLmxvYWQuaW1hZ2UoJ2hhY2tlcicsICdhc3NldHMvaGFja2VyLnBuZycpO1xyXG5cdHRoaXMubG9hZC5zcHJpdGVzaGVldCgnaGFja2FibGUxJywgJ2Fzc2V0cy9oYWNrYWJsZTEucG5nJywgMjU2LCAyNTYpO1xyXG4gICAgdGhpcy5sb2FkLmF0bGFzSlNPTkhhc2goJ2Nvbm5lY3Rpb25zJywgJ2Fzc2V0cy9jb25uZWN0aW9ucy5wbmcnLCAnYXNzZXRzL2Nvbm5lY3Rpb25zLmpzb24nKTtcclxuXHR0aGlzLmxvYWQuaW1hZ2UoJ2FzdGVyb2lkJywgJ2Fzc2V0cy9hc3Rlcm9pZC5wbmcnKTtcclxuICAgIHRoaXMubG9hZC5hdGxhc0pTT05IYXNoKCdjb25uZWN0aW9ucycsICdhc3NldHMvY29ubmVjdGlvbnMucG5nJywgJ2Fzc2V0cy9jb25uZWN0aW9ucy5qc29uJyk7XHJcblx0dGhpcy5sb2FkLmltYWdlKCdlYXJ0aE5pZ2h0JywgJ2Fzc2V0cy9iZ19lYXJ0aE5pZ2h0U21hbGwuanBnJyk7XHJcbiAgICB0aGlzLmxvYWQucGh5c2ljcygnbW9kdWxlX3BoeXNpY3MnLCAnYXNzZXRzL21vZHVsZV9waHlzaWNzLmpzb24nKTtcclxuICAgIHRoaXMubG9hZC50ZXh0KCdsZXZlbF9vbmUnLCAnYXNzZXRzL2xldmVsX29uZS5qc29uJyk7XHJcbiAgfSxcclxuXHJcbiAgY3JlYXRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLmFzc2V0LmNyb3BFbmFibGVkID0gZmFsc2U7XHJcbiAgfSxcclxuXHJcbiAgdXBkYXRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAoISF0aGlzLnJlYWR5KSB7XHJcbiAgICAgIC8vdGhpcy5nYW1lLnN0YXRlLnN0YXJ0KCdNZW51Jyk7XHJcbiAgICAgIHRoaXMuZ2FtZS5zdGF0ZS5zdGFydChwbGF5ZXJTdGF0ZS5jdXJyZW50TGV2ZWwpOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcclxuICAgIH1cclxuICB9LFxyXG5cclxuICBvbkxvYWRDb21wbGV0ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy5yZWFkeSA9IHRydWU7XHJcbiAgfVxyXG59O1xyXG4iLCJ2YXIgU3BsYXNoID0gZnVuY3Rpb24gKCkge1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTcGxhc2g7XHJcblxyXG5TcGxhc2gucHJvdG90eXBlID0ge1xyXG4gIGNyZWF0ZTogZnVuY3Rpb24gKCkge1xyXG4gIH1cclxufTsiLCIvL05PVEU6IERPTidUIFVTRSB0aGlzIGNvZGUgdG8gY3JlYXRlIGEgUHJvZ3Jlc3NCYXIuIEluc3RlYWQsIHVzZSB0aGUgVUlCdWlsZGVyIG9iamVjdCBhbmQgY2FsbCBidWlsZFByb2dyZXNzQmFyXHJcblxyXG52YXIgUHJvZ3Jlc3NCYXIgPSBmdW5jdGlvbihzZXRUeXBlLCBzZXRNYXhWYWx1ZSwgc2V0R3JhcGhpY3MsIHNldFJlbmRlcmFibGVzKSB7XHJcblx0dGhpcy50eXBlID0gc2V0VHlwZTsgLy9Ud28gdHlwZXMsIFwiZ3Jvd2luZ1wiIChzdGFydHMgYXQgMCwgdHJpZ2dlcnMgZXZlbnQgd2hlbiBmdWxsKSBcclxuXHRcdFx0XHRcdFx0IC8vYW5kIFwic2hyaW5raW5nXCIgKHN0YXJ0cyBmdWxsLCB0cmlnZ2VycyBhdCAwKVxyXG5cdHRoaXMuYmdCb3JkZXJTaXplID0gMjtcdFx0XHQvL2RlZmF1bHQgc2l6ZSBvZiBiYWNrZ3JvdW5kIGJvcmRlclxyXG5cdHRoaXMuYmdCb3JkZXJDb2xvciA9IDB4QUFBQUFBO1x0Ly9kZWZhdWx0IGNvbG9yIG9mIGJhY2tncm91bmQgYm9yZGVyXHJcblx0dGhpcy5iZ0NvbG9yID0gMHg4ODg4ODg7XHRcdC8vZGVmYXVsdCBjb2xvciBvZiBiYWNrZ3JvdW5kXHJcblx0dGhpcy5wYWRkaW5nSG9yaXogPSA1O1x0XHRcdC8vZGVmYXVsdCBzdW0gb2YgcGFkZGluZyBvbiBsZWZ0IGFuZCByaWdodCBzaWRlIGlubmVyIHZhbHVlIGJhclxyXG5cdHRoaXMucGFkZGluZ1ZlcnQgPSA1O1x0XHRcdC8vZGVmYXVsdCBzdW0gKGkuZS4gaGFsZiBvbiBlYWNoIHNpZGUpIG9mIHZlcnRpY2FsIHBhZGRpbmcgb2YgaW5uZXIgdmFsdWUgYmFyXHJcblx0dGhpcy52YWx1ZUJvcmRlclNpemUgPSAxO1x0XHQvL2RlZmF1bHQgc2l6ZSBvZiB2YWx1ZSBib3JkZXJcclxuXHR0aGlzLnZhbHVlQm9yZGVyQ29sb3IgPSAweDg4ODhGRjsgLy9kZWZhdWx0IGNvbG9yIG9mIHZhbHVlIGJvcmRlclxyXG5cdHRoaXMudmFsdWVDb2xvciA9IDB4MDAwMDk5O1x0XHQvL2RlZmF1bHQgY29sb3Igb2YgaW5uZXIgdmFsdWUgYmFyXHJcblx0dGhpcy54ID0gbnVsbDtcclxuXHR0aGlzLnkgPSBudWxsO1xyXG5cdHRoaXMud2lkdGggPSBudWxsO1xyXG5cdHRoaXMuaGVpZ2h0ID0gbnVsbDtcclxuXHR0aGlzLm1heFZhbHVlID0gc2V0TWF4VmFsdWU7XHJcblx0dGhpcy5ncmFwaGljcyA9IHNldEdyYXBoaWNzOyAvL3N0b3JlIGdyYXBoaWNzIGNsYXNzICh1c2VkIHRvIGRyYXcgYmFyKVxyXG5cdHRoaXMucmVuZGVyYWJsZXMgPSBzZXRSZW5kZXJhYmxlcztcclxuXHRcclxuXHR0aGlzLm9uRXZlbnQgPSBmdW5jdGlvbigpIHt9OyAvL292ZXJ3cml0ZSB0aGlzIGZ1bmN0aW9uIHRvIG1ha2Ugd2hhdGV2ZXIgeW91IHdhbnQgaGFwcGVuIHdoZW4gcHJvZ3Jlc3NCYXIgcmVhY2hlcyBsaW1pdFxyXG5cdFxyXG5cdC8vc3dpdGNoKHRoaXMudHlwZSkge1xyXG5cdC8vY2FzZSAnZ3Jvd2luZycgOiBcclxuXHRpZihzZXRUeXBlID09PSAnZ3Jvd2luZycpIHtcclxuXHRcdHRoaXMudmFsdWUgPSAwO1xyXG5cdFx0Ly90cnlUcmlnZ2VyIGlzIGNhbGxlZCBhdXRvbWF0aWNhbGx5IHdoZW4geW91IGFkZC9zdWJ0cmFjdCB2YWx1ZSwgYW5kIHdpbGwgdHJpZ2dlciB0aGUgb25FdmVudCgpIGZ1bmN0aW9uXHJcblx0XHR0aGlzLnRyeVRyaWdnZXIgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0aWYodGhpcy52YWx1ZSA+PSB0aGlzLm1heFZhbHVlKSB7XHJcblx0XHRcdFx0dGhpcy5vbkV2ZW50KCk7XHJcblx0XHRcdH1cclxuXHRcdH07XHJcblx0XHQvL2JyZWFrO1xyXG5cdH1cclxuXHRlbHNlIGlmKHNldFR5cGUgPT09ICdzaHJpbmtpbmcnKSB7XHJcblx0Ly9jYXNlICdzaHJpbmtpbmcnIDpcclxuXHRcdHRoaXMudmFsdWUgPSB0aGlzLm1heFZhbHVlO1xyXG5cdFx0dGhpcy50cnlUcmlnZ2VyID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdGlmKHRoaXMudmFsdWUgPD0gMCkge1xyXG5cdFx0XHRcdHRoaXMub25FdmVudCgpO1xyXG5cdFx0XHR9XHJcblx0XHR9O1xyXG5cdC8vfVxyXG5cdH1cclxufTtcclxuXHJcblByb2dyZXNzQmFyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFByb2dyZXNzQmFyO1xyXG5cclxuUHJvZ3Jlc3NCYXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcclxuXHR0aGlzLmdyYXBoaWNzLmNsZWFyKCk7XHJcblx0dGhpcy5yZW5kZXJhYmxlcy51bnN1YnNjcmliZSh0aGlzKTtcclxufTtcclxuXHJcbi8vVG8gc3VidHJhY3QgdmFsdWUsIGp1c3QgdXNlIG5lZ2F0aXZlIG51bWJlcnMgYXMgYXJndW1lbnQgaS5lLiBmb28uYWRkVmFsdWUoLTUpO1xyXG5Qcm9ncmVzc0Jhci5wcm90b3R5cGUuYWRkVmFsdWUgPSBmdW5jdGlvbiAoYWRkVGhpcykge1xyXG5cdHRoaXMudmFsdWUgKz0gYWRkVGhpcztcclxuXHRpZih0aGlzLnZhbHVlID4gdGhpcy5tYXhWYWx1ZSkge1xyXG5cdFx0dGhpcy52YWx1ZSA9IHRoaXMubWF4VmFsdWU7XHJcblx0fVxyXG5cdGlmKHRoaXMudmFsdWUgPCAwKSB7XHJcblx0XHR0aGlzLnZhbHVlID0gMDtcclxuXHR9XHJcblx0dGhpcy50cnlUcmlnZ2VyKCk7XHJcbn07XHJcblxyXG4vL1NldHMgdGhlIGxvY2F0aW9uIHdoZXJlIHByb2dyZXNzIGJhciBpcyByZW5kZXJlZFxyXG5Qcm9ncmVzc0Jhci5wcm90b3R5cGUuc2V0TG9jYXRpb24gPSBmdW5jdGlvbihzZXRYLCBzZXRZKSB7XHJcblx0dGhpcy54ID0gc2V0WDtcclxuXHR0aGlzLnkgPSBzZXRZO1xyXG59O1xyXG5cclxuLy9TZXRzIHRoZSBzaXplIG9mIHRoZSBwcm9ncmVzcyBiYXJcclxuUHJvZ3Jlc3NCYXIucHJvdG90eXBlLnNldFNpemUgPSBmdW5jdGlvbihzZXRXaWR0aCwgc2V0SGVpZ2h0KSB7XHJcblx0dGhpcy53aWR0aCA9IHNldFdpZHRoO1xyXG5cdHRoaXMuaGVpZ2h0ID0gc2V0SGVpZ2h0O1xyXG59O1xyXG5cclxuUHJvZ3Jlc3NCYXIucHJvdG90eXBlLnNldFN0eWxlID0gZnVuY3Rpb24oYmdCb3JkZXJTaXplLCBiZ0JvcmRlckNvbG9yLCBiZ0NvbG9yLCBwYWRkaW5nSG9yaXosIHBhZGRpbmdWZXJ0LCB2YWx1ZUJvcmRlclNpemUsIHZhbHVlQm9yZGVyQ29sb3IsIHZhbHVlQ29sb3IpIHtcclxuXHR0aGlzLmJnQm9yZGVyU2l6ZSA9IGJnQm9yZGVyU2l6ZTtcclxuXHR0aGlzLmJnQm9yZGVyQ29sb3IgPSBiZ0JvcmRlckNvbG9yO1xyXG5cdHRoaXMuYmdDb2xvciA9IGJnQ29sb3I7XHJcblx0dGhpcy5wYWRkaW5nSG9yaXogPSBwYWRkaW5nSG9yaXo7XHJcblx0dGhpcy5wYWRkaW5nVmVydCA9IHBhZGRpbmdWZXJ0O1xyXG5cdHRoaXMudmFsdWVCb3JkZXJTaXplID0gdmFsdWVCb3JkZXJTaXplO1xyXG5cdHRoaXMudmFsdWVCb3JkZXJDb2xvciA9IHZhbHVlQm9yZGVyQ29sb3I7XHJcblx0dGhpcy52YWx1ZUNvbG9yID0gdmFsdWVDb2xvcjtcclxufTtcclxuXHJcbi8vdXBkYXRlIGZvciBwcm9ncmVzcyBiYXIsIGNhbGxlZCBqdXN0IGJlZm9yZSBkcmF3aW5nIHByb2dyZXNzIGJhclxyXG4vL092ZXJ3cml0ZSB0aGlzIGZ1bmN0aW9uIGlmIGRlc2lyZWRcclxuUHJvZ3Jlc3NCYXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCkge307XHJcblxyXG4vL1JlbmRlcnMgcHJvZ3Jlc3NCYXJcclxuUHJvZ3Jlc3NCYXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKCkge1xyXG5cdHRoaXMudXBkYXRlKCk7XHJcblx0dGhpcy5ncmFwaGljcy5jbGVhcigpO1xyXG5cdC8vRHJhdyBiYWNrZ3JvdW5kIG9mIGJhclxyXG5cdHRoaXMuZ3JhcGhpY3MubGluZVN0eWxlKHRoaXMuYmdCb3JkZXJTaXplLCB0aGlzLmJnQm9yZGVyQ29sb3IsIDEpOyAvL3NldHMgYm9yZGVyIGNvbG9yIGFuZCBzaXplXHJcblx0dGhpcy5ncmFwaGljcy5iZWdpbkZpbGwodGhpcy5iZ0NvbG9yKTsgLy9zZXRzIGNvbG9yIG9mIGJhY2tncm91bmQgZmlsbFxyXG5cdHRoaXMuZ3JhcGhpY3MuZHJhd1JlY3QodGhpcy54LXRoaXMud2lkdGgvMiwgdGhpcy55LXRoaXMuaGVpZ2h0LzIsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcclxuXHR0aGlzLmdyYXBoaWNzLmVuZEZpbGwoKTtcclxuXHQvL0RyYXcgdmFsdWUgb2YgYmFyXHJcblx0dmFyIHBlcmNlbnRhZ2UgPSB0aGlzLnZhbHVlIC8gdGhpcy5tYXhWYWx1ZTtcclxuXHR2YXIgYmFyV2lkdGggPSB0aGlzLndpZHRoIC0gdGhpcy5wYWRkaW5nSG9yaXo7XHJcblx0dmFyIGJhckhlaWdodCA9IHRoaXMuaGVpZ2h0IC0gdGhpcy5wYWRkaW5nVmVydDtcclxuXHR0aGlzLmdyYXBoaWNzLmxpbmVTdHlsZSh0aGlzLnZhbHVlQm9yZGVyU2l6ZSwgdGhpcy52YWx1ZUJvcmRlckNvbG9yLCAxKTtcclxuXHR0aGlzLmdyYXBoaWNzLmJlZ2luRmlsbCh0aGlzLnZhbHVlQ29sb3IpO1xyXG5cdHRoaXMuZ3JhcGhpY3MuZHJhd1JlY3QodGhpcy54LShiYXJXaWR0aC8yKSwgdGhpcy55LShiYXJIZWlnaHQvMiksIGJhcldpZHRoKnBlcmNlbnRhZ2UsIGJhckhlaWdodCk7XHJcblx0dGhpcy5ncmFwaGljcy5lbmRGaWxsKCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFByb2dyZXNzQmFyOyIsInZhciBQcm9ncmVzc0JhciA9IHJlcXVpcmUoJy4vUHJvZ3Jlc3NCYXInKTtcclxuXHJcbnZhciBVSUJ1aWxkZXIgPSBmdW5jdGlvbihzZXRHYW1lU3RhdGUsIHNldFJlbmRlcmFibGVzKSB7XHJcblx0Ly9FbnN1cmUgdGhhdCBjYW5ub3QgY3JlYXRlIG11bHRpcGxlIGluc3RhbmNlcyBvZiB0aGlzIGNsYXNzXHJcblx0aWYoVUlCdWlsZGVyLnByb3RvdHlwZS5leGlzdHMpIHtcclxuXHRcdHJldHVybiBVSUJ1aWxkZXIucHJvdG90eXBlLmV4aXN0aW5nUmVmZXJlbmNlO1xyXG5cdH1cclxuXHRcclxuXHR0aGlzLmdhbWVTdGF0ZSA9IHNldEdhbWVTdGF0ZTtcclxuXHR0aGlzLnJlbmRlcmFibGVzID0gc2V0UmVuZGVyYWJsZXM7XHJcblx0Ly9DcmVhdGUgYW5kIHN0b3JlIGEgZ3JhcGhpY3Mgb2JqZWN0ICh1c2VkIGZvciBzdHVmZiBsaWtlIGRyYXdpbmcgcmVjdGFuZ2xlcylcclxuXHRVSUJ1aWxkZXIucHJvdG90eXBlLmV4aXN0cyA9IHRydWU7XHJcblx0VUlCdWlsZGVyLnByb3RvdHlwZS5leGlzdGluZ1JlZmVyZW5jZSA9IHRoaXM7XHJcbn07XHJcblxyXG5VSUJ1aWxkZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVUlCdWlsZGVyO1xyXG4vL1RoZXNlIHZhcidzIGhlbHAgY3JlYXRlIHRoZSBzaW5nbGV0b24gZnVuY3Rpb25hbGl0eVxyXG5VSUJ1aWxkZXIucHJvdG90eXBlLmV4aXN0cyA9IGZhbHNlO1xyXG5VSUJ1aWxkZXIucHJvdG90eXBlLmV4aXN0aW5nUmVmZXJlbmNlID0gbnVsbDtcclxuXHJcbi8vVXNlIHRoaXMgZnVuY3Rpb24gdG8gY3JlYXRlIGEgcHJvZ3Jlc3MgYmFyXHJcbi8vVXNhZ2U6IHR5cGU6IGNhbiBiZSBcImdyb3dpbmdcIiBvciBcInNocmlua2luZ1wiLCB0aGlzIHdpbGwgZWZmZWN0IGlmIGJhciBzdGFydHMgYXQgMCBhbmQgZ29lcyB1cCBvciB2aXMgdmVyc2FcclxuLy9cdFx0IG1heFZhbHVlOiBzZXRzIHRoZSBtYXggdmFsdWUgb2YgdGhlIHByb2dyZXNzIGJhciwgaS5lLiB1c2luZyAxMDAgY3JlYXRlcyBhIGJhciBmcm9tIDAgdG8gMTAwXHJcbi8vXHRcdCB4LHk6IHNldHMgbG9jYXRpb25cclxuLy9cdFx0IERPTidUIEZPUkdFVCB0byBvdmVyd3JpdGUgdGhlIG9uRXZlbnQoKSBmdW5jdGlvbiBmb3IgdGhlIHByb2dyZXNzIGJhciBhZnRlciBjcmVhdGluZyBpdFxyXG4vL1x0XHRcdC1vbkV2ZW50KCkgaXMgYXV0b21hdGljYWxseSBjYWxsZWQgd2hlbiBiYXIgZmlsbHMvc2hyaW5rcyBwYXN0IGxpbWl0IChkZXBlbmRpbmcgb24gYmFyIHR5cGUpXHJcblVJQnVpbGRlci5wcm90b3R5cGUuYnVpbGRQcm9ncmVzc0JhciA9IGZ1bmN0aW9uKHR5cGUsIHgsIHksIHdpZHRoLCBoZWlnaHQsIG1heFZhbHVlKSB7XHJcblx0Ly9jcmVhdGUgYW5kIGZvcm1hdCBuZXcgcHJvZyBiYXJcclxuXHR2YXIgZ3JhcGhpY3MgPSB0aGlzLmdhbWVTdGF0ZS5nYW1lLmFkZC5ncmFwaGljcygwLDApO1xyXG5cdHZhciBuZXdQcm9nQmFyID0gbmV3IFByb2dyZXNzQmFyKHR5cGUsIG1heFZhbHVlLCBncmFwaGljcywgdGhpcy5yZW5kZXJhYmxlcyk7XHJcblx0bmV3UHJvZ0Jhci5zZXRMb2NhdGlvbih4LHkpO1xyXG5cdG5ld1Byb2dCYXIuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcclxuXHQvL3N1YnNjcmliZSB0byAncmVuZGVyYWJsZXMnIHNvIHRoYXQgcmVuZGVyKCkgaXMgY2FsbGVkIGF1dG9tYXRpY2FsbHlcclxuXHR0aGlzLnJlbmRlcmFibGVzLnN1YnNjcmliZShuZXdQcm9nQmFyKTtcclxuXHRyZXR1cm4gbmV3UHJvZ0JhcjtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVUlCdWlsZGVyOyIsIi8qXHJcbkNvbGxlY3Rpb24gb2YgdXRpbGl0eSBmdW5jdGlvbnMuXHJcbiovXHJcblxyXG52YXIgVXRpbHMgPSB7XHJcbiAgICBjb250YWluc09iamVjdDogZnVuY3Rpb24ob2JqLCBsaXN0KSB7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGxpc3RbaV0gPT09IG9iaikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH0sXHJcbiAgICBkaXN0YW5jZTogZnVuY3Rpb24oeDEsIHkxLCB4MiwgeTIpIHtcclxuICAgICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coeDEgLSB4MiwgMikgKyBNYXRoLnBvdyh5MSAtIHkyLCAyKSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFV0aWxzOyJdfQ==
