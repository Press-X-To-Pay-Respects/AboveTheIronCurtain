(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"./src/js/main.js":[function(require,module,exports){
'use strict';

var game = new Phaser.Game(1280, 720, Phaser.AUTO, 'atic-game');

window.playerState = {
    currentLevel: 'Game'
};

game.state.add('Boot', require('./states/boot'));
game.state.add('Splash', require('./states/splash'));
game.state.add('Preloader', require('./states/preloader'));
game.state.add('Menu', require('./states/menu'));
game.state.add('Game', require('./states/game'));

game.state.start('Boot');
},{"./states/boot":"C:\\Users\\mattd_000\\Documents\\GitHub\\AboveTheIronCurtain\\src\\js\\states\\boot.js","./states/game":"C:\\Users\\mattd_000\\Documents\\GitHub\\AboveTheIronCurtain\\src\\js\\states\\game.js","./states/menu":"C:\\Users\\mattd_000\\Documents\\GitHub\\AboveTheIronCurtain\\src\\js\\states\\menu.js","./states/preloader":"C:\\Users\\mattd_000\\Documents\\GitHub\\AboveTheIronCurtain\\src\\js\\states\\preloader.js","./states/splash":"C:\\Users\\mattd_000\\Documents\\GitHub\\AboveTheIronCurtain\\src\\js\\states\\splash.js"}],"C:\\Users\\mattd_000\\Documents\\GitHub\\AboveTheIronCurtain\\src\\js\\entities\\Module.js":[function(require,module,exports){
//Don't use this function to create modules, instead use moduleBuilder()
var Module = function(setCube, type) {
   this.cube = setCube;
   this.cube.module = this;
   this.type = type;
};

Module.prototype.constructor = Module;

module.exports = Module;
},{}],"C:\\Users\\mattd_000\\Documents\\GitHub\\AboveTheIronCurtain\\src\\js\\entities\\ModuleBuilder.js":[function(require,module,exports){
var Cube = require('./cube');
var Module = require('./Module');

var thrustAmt = 5000;

//Use this to create a moduleBuilder- only need to create one instance of it
var ModuleBuilder = function(setGameState, setColGroup) {
	//Ensure that cannot create multiple instances of this class
	if(ModuleBuilder.prototype.exists) {
		return ModuleBuilder.prototype.existingReference;
	}
		
	this.gameState = setGameState;
   this.colGroup = setColGroup;
	// this.coreExists = false;	//records if core has been created
	this.core = null;			//stores core when it is created
	//var space = this.gameState.input.keyboard.addKey(Phaser.Keyboard.SPACEBAR);
	ModuleBuilder.prototype.exists = true;
	ModuleBuilder.prototype.existingReference = this;
};

ModuleBuilder.prototype.constructor = ModuleBuilder;

//These var's help create the singleton functionality
ModuleBuilder.prototype.exists = false;
ModuleBuilder.prototype.existingReference = null;

/** Module functions **/
function solarPanelGiveTarget(target) {
   if (this.cube.group && target.cube.group && this.cube.group !== target.cube.group || this === target) {
      return;
   }
   var ourGroup = this.cube.group;
   var newConnection = {start: this.cube, end: target.cube};
   this.cube.myConnection = newConnection;
   target.cube.myConnection = newConnection;
   ourGroup.displayConnection(this.cube.myConnection);
}

function solarPanelMouseOver() {
   if (!this.cube.myConnection || !this.cube.group) {
      return;
   }
   this.cube.group.displayConnection(this.cube.myConnection);
}

function solarPanelOnRemove() {
   if (!this.cube.myConnection || !this.cube.myConnection.end) {
      console.log('solarPanelOnRemove() had an error');
   }
   this.cube.myConnection.end.myConnection = undefined;
   this.cube.myConnection = undefined;
}

function beginThrust() {
   this.thrust = true;
   this.cube.frame = 1;
}

function endThrust() {
   this.thrust = false;
   this.cube.frame = 0;
}

function thrusterUpdate() {
   // console.log(this.thrust);
   if (this.thrust && this.cube.myConnection) {
      this.cube.body.force.x = thrustAmt * Math.cos(this.cube.rotation - Math.PI / 2);
      this.cube.body.force.y = thrustAmt * Math.sin(this.cube.rotation - Math.PI / 2);
	  if(this.cube.frame === 1) {
		this.cube.frame = 2;
	  }
	  else {
		this.cube.frame = 1;
	  }
   }
}

/** End module functions **/

//call this function from ModuleBuilder to construct modules
//TYPES: 'core' 'shield' 'thruster' 'solarPanel' 'gun'
ModuleBuilder.prototype.build = function(type, x, y, forPlayer) {
	//Create cube object to be stored within module
	//Sprite names for modules are directly mapped to module names, so just pass 'type' as sprite name
	var newCube = new Cube(this.gameState.game, x, y, type);
    var scale = 0.5;
    newCube.name = this.gameState.debugNum++;
    newCube.scale.setTo(scale, scale);
    newCube.anchor.setTo(0.5, 0.5);
    this.gameState.game.physics.p2.enable(newCube);
    newCube.body.onBeginContact.add(newCube.cubeCollide, newCube);
	newCube.body.collideWorldBounds = false;
    newCube.body.damping = 0.9;
    newCube.body.angularDamping = 0.9;
    if (!this.gameState.rootSpawned) {
       newCube.root = true;
       this.gameState.rootSpawned = true;
    }

   var cIndicator = this.gameState.add.sprite(0, 0, 'connections', 'connection_line.png');
   cIndicator.anchor.setTo(0.5, 0.5);
   cIndicator.animations.add('end', ['connection_end.png'], 60, true);
   cIndicator.animations.add('line', ['connection_line.png'], 60, true);
   cIndicator.animations.add('right', ['connection_right.png'], 60, true);
   newCube.addChild(cIndicator);
   newCube.cIndicator = cIndicator;
   cIndicator.alpha = 0;
	
	//Create module to wrap around cube class
	var newModule = new Module(newCube, type);
		
	//TODO: edit special module attributes based on 'type'z
	
	//Store module if it is core
	if(type === 'core')
	{
		newModule.cube.animations.add('core', [0,1,2], 20, true);
		newModule.cube.animations.play('core');
		this.core = newModule;
		this.coreExists = true;
	}
   // solar panel testing
   if (type === 'solarPanel') {
      newModule.giveTarget = solarPanelGiveTarget;
      newModule.mouseOver = solarPanelMouseOver;
      newModule.onRemove = solarPanelOnRemove;
   }
   
   //Thruster module events
	if(type === 'thruster') {
      if (forPlayer) {
         var space = this.gameState.input.keyboard.addKey(Phaser.Keyboard.SPACEBAR); 
         this.gameState.input.keyboard.addKeyCapture([space]);
         // space.onDown.add(applyThrust, newModule);
         space.onDown.add(beginThrust, newModule);
         space.onUp.add(endThrust, newModule);
      } else {
         // newModule.thrust = false;
         newModule.beginThrust = beginThrust;
         newModule.endThrust = endThrust;
      }
      newModule.update = thrusterUpdate;
	}
	//Return the module object
	return newModule;
};

module.exports = ModuleBuilder;
















},{"./Module":"C:\\Users\\mattd_000\\Documents\\GitHub\\AboveTheIronCurtain\\src\\js\\entities\\Module.js","./cube":"C:\\Users\\mattd_000\\Documents\\GitHub\\AboveTheIronCurtain\\src\\js\\entities\\cube.js"}],"C:\\Users\\mattd_000\\Documents\\GitHub\\AboveTheIronCurtain\\src\\js\\entities\\cube.js":[function(require,module,exports){
/*
Defines a cube.
*/

var Cube = function (game, x, y, sprite) {
    Phaser.Sprite.call(this, game, x, y, sprite);
    this.game = game;
    this.game.add.existing(this);
    this.group = undefined;
    this.module = undefined;
    this.indicatorFade = 0.02;
    this.health = 3;
    this.constraints = [];
   // this.ramCooldown = 500;
   // this.ramDelay = 0;
};

Cube.prototype = Object.create(Phaser.Sprite.prototype);
Cube.prototype.constructor = Cube;

/**
 * Automatically called by World.update
 */
Cube.prototype.update = function() {
   if (this.cIndicator && this.cIndicator.alpha > 0) {
      this.cIndicator.alpha -= this.indicatorFade;
   }
   if (this.module.update) {
      this.module.update();
   }
   // if (this.ramDelay > 0) {
      // this.ramDelay -= this.game.time.elapsed;
   // }
};

// Cube.prototype.resetRamDelay = function() {
  // this.ramDelay = this.ramCooldown; 
// };

Cube.prototype.cubeCollide = function(other) {
   if (!this.group || !other || !other.sprite || other.sprite.key === 'asteroid') {
      return;
   }
	this.group.handleCollision(this, other.sprite);
	this.group.countCubes();
};

Cube.prototype.toString = function() {
   var string = '';
   string += this.concat('name', this.name);
   return string;
};

Cube.prototype.concat = function(string, val) {
   return string + ': ' + val + '\n';
};
Cube.prototype.displayIndicator = function() {
  this.cIndicator.alpha = 1; 
};

Cube.prototype.takeDamage = function(amt) {
   this.health -= amt;
   if (this.health <= 0) {
      this.group.destroyCube(this);
	  // this.group.countCubes();
   }
};

Cube.prototype.remove = function() {
   if (!this.group) {
      return;
   }
   this.group.remove(this);
};

module.exports = Cube;















},{}],"C:\\Users\\mattd_000\\Documents\\GitHub\\AboveTheIronCurtain\\src\\js\\entities\\cube_group.js":[function(require,module,exports){
var Astar = require('../libs/javascript-astar/astar');
var EnemyAI = require('./enemy_ai');

/*
Defines a cube group.
*/

var CubeGroup = function (game, root) {
   this.game = game;
   this.root = root;
   this.cubes = [];
   var col = [];
   col.push(this.root);
   this.cubes.push(col);
   if (this.root) {
      this.root.group = this;
   }
   this.DIR = {NORTH: 0, EAST: 1, SOUTH: 2, WEST: 3};
   this.offset = 2;
   this.numCubes = 1;
   this.bounceBackForce = 30;
   this.minRamVel = 100;
};

CubeGroup.prototype.constructor = CubeGroup;

/**
 * Automatically called by World.update
 */
CubeGroup.prototype.update = function() {
   if (this.AI) {
      this.AI.update();
   }
};

CubeGroup.prototype.call = function(fun) {
   for (var row = 0; row < this.cubesWidth(); row++) {
      for (var col = 0; col < this.cubesHeight(); col++) {
         var cube = this.cubes[row][col];
         if (cube && cube.hasOwnProperty(fun)) {
            // if cubes need functions called
         } else if (cube && cube.module && cube.module.hasOwnProperty(fun)) {
            var fn = cube.module[fun];
            if (typeof fn === 'function') {
               fn.call(cube.module);
            }
         }
      }
   }
};

CubeGroup.prototype.giveAI = function(type, player) {
   this.AI = new EnemyAI(this.game, this, type, player);
};

CubeGroup.prototype.add = function(cube, point) {
  if (!this.root && cube.module.type === 'core') {
     this.root = cube;
  }
  cube.group = this;
  this.set(cube, point);
  this.createConstraints(cube, point);
  // this.displayCubes();
};

CubeGroup.prototype.handleCollision = function(origin, other) {
   // stop if other does not exist, either is not a cube, both are in same group
   if (other === null || origin.prototype !== other.prototype) {
      return;
   }
   // if (other.group && other.group !== this && origin.ramDelay <= 0) {
   var sumVel = Math.abs(origin.body.velocity.x) + Math.abs(origin.body.velocity.y);
   if (other.group && other.group !== this && sumVel >= this.minRamVel) {
      console.log(origin.body.velocity.x, origin.body.velocity.y, sumVel);
      // console.log(origin.name, 'ramming damage!');
      other.takeDamage(3);
      // origin.resetRamDelay();
   } else if (!other.group && this.isPlayer) {
      var relSide = this.relativeSide(origin.body, other.body);
      var originLoc = this.find(origin);
      var otherLoc = this.adjust(originLoc, relSide);
      this.set(other, otherLoc);
      otherLoc = this.find(other); // update position since set can shift grid
      if (!otherLoc) {
         // console.log('handle collision failed to find position for good applicant');
         return;
      }
      this.createConstraints(other, otherLoc);
      // console.log(other.body.collidesWith);
      // this.displayCubes();
   }
};

CubeGroup.prototype.createConstraints = function(me, point) {
   // this.displayCubes();
   var myNorth = this.get(this.adjust(point, this.DIR.NORTH));
   var myEast = this.get(this.adjust(point, this.DIR.EAST));
   var mySouth = this.get(this.adjust(point, this.DIR.SOUTH));
   var myWest = this.get(this.adjust(point, this.DIR.WEST));
   var constraint;
   if (myNorth) {
      constraint = this.game.physics.p2.createLockConstraint(me.body, myNorth.body, [0, me.width + this.offset]); // me - north
      me.constraints.push(constraint);
      myNorth.constraints.push(constraint);
   }
   if (myEast) {
      constraint = this.game.physics.p2.createLockConstraint(me.body, myEast.body, [-me.width - this.offset, 0]); // me - east
      me.constraints.push(constraint);
      myEast.constraints.push(constraint);
   }
   if (mySouth) {
      constraint = this.game.physics.p2.createLockConstraint(mySouth.body, me.body, [0, me.width + this.offset]); // south - me
      me.constraints.push(constraint);
      mySouth.constraints.push(constraint);
   }
   if (myWest) {
      constraint = this.game.physics.p2.createLockConstraint(myWest.body, me.body, [-me.width - this.offset, 0]); // west - me
      me.constraints.push(constraint);
      myWest.constraints.push(constraint);
   }
};

CubeGroup.prototype.relativeSide = function(thisBody, otherBody) {
  var thisPoint = new Phaser.Point(thisBody.x, thisBody.y);
  var otherPoint = new Phaser.Point(otherBody.x, otherBody.y);
  var angleToOther = Phaser.Point.angle(thisPoint, otherPoint);
  if (angleToOther < 0) { // fix dumb part of Phaser.Point.angle()
     angleToOther = 2 * Math.PI + angleToOther;
  }
  angleToOther = (angleToOther + 3/2 * Math.PI) % (2 * Math.PI); // rotate 90 d clockwise
  var diffAngle = Math.abs(Math.abs(angleToOther) - Math.abs(thisBody.rotation));
   if (diffAngle < 1 / 4 * Math.PI || diffAngle > 7 / 4 * Math.PI) { // north
     return this.DIR.NORTH;
  } else if (diffAngle >= 1 / 4 * Math.PI && diffAngle < 3 / 4 * Math.PI) { // east
     return this.DIR.EAST;
  } else if (diffAngle >= 3 / 4 * Math.PI && diffAngle < 5 / 4 * Math.PI) { // south
     return this.DIR.SOUTH;
  } else if (diffAngle >= 5 / 4 * Math.PI && diffAngle < 7 / 4 * Math.PI) { // west
     return this.DIR.WEST;
  }
};

CubeGroup.prototype.find = function(cube) {
   for (var row = 0; row < this.cubesWidth(); row++) {
      for (var col = 0; col < this.cubesHeight(); col++) {
         if (this.cubes[row][col] === cube) {
            return new Phaser.Point(row, col);
         }
      }
   }
   return undefined;
};

CubeGroup.prototype.get = function(point) {
  if (!point || this.outOfBounds(point)) {
      return;
  }
  return this.cubes[point.x][point.y];
};

CubeGroup.prototype.cubesWidth = function() {
   return this.cubes.length;
};

CubeGroup.prototype.cubesHeight = function() {
   return this.cubes[0].length;
};

CubeGroup.prototype.addTopRow = function() {
   for (var row = 0; row < this.cubesWidth(); row++) {
      this.cubes[row].push(undefined);
   }
};

CubeGroup.prototype.addRightCol = function() {
   var newCol = [];
   for (var i = 0; i < this.cubesHeight(); i++) {
      newCol.push(undefined);
   }
   this.cubes.push(newCol);
};

CubeGroup.prototype.addBotRow = function() {
   for (var row = 0; row < this.cubesWidth(); row++) {
      this.cubes[row].unshift(undefined);
   }
};

CubeGroup.prototype.addLeftCol = function() {
   var newCol = new Array(this.cubesHeight());
   this.cubes.unshift(newCol);
};

CubeGroup.prototype.getCube = function(point) {
   if (!point || this.outOfBounds(point)) {
      return undefined;
   }
   return this.cubes[point.x][point.y];
};

CubeGroup.prototype.adjust = function(point, dir) {
  if (!point) {
     return;
  }
  var newPoint = new Phaser.Point(point.x, point.y);
  switch (dir) {
      case this.DIR.NORTH:
      newPoint.y++;
      break;
      case this.DIR.EAST:
      newPoint.x++;
      break;
      case this.DIR.SOUTH:
      newPoint.y--;
      break;
      case this.DIR.WEST:
      newPoint.x--;
      break;
   }
   return newPoint;
};

CubeGroup.prototype.set = function(cube, point) {
   if (!point) {
      console.log('set given undefined point');
      return;
   }
   if (point.x < 0) {
      this.addLeftCol();
      point.x = 0;
   } else if (point.x >= this.cubesWidth()) {
      this.addRightCol();
      point.x = this.cubesWidth() - 1;
   } else if (point.y < 0) {
      this.addBotRow();
      point.y = 0;
   } else if (point.y >= this.cubesHeight()) {
      this.addTopRow();
      point.y = this.cubesHeight() - 1;
   }
   if (this.get(point)) {
      // console.log('tried to set to filled position');
      return;
   }
   this.cubes[point.x][point.y] = cube;
   cube.group = this;
};

CubeGroup.prototype.outOfBounds = function(point) {
   if (!point) {
      console.log('out of bounds given undefined point');
      return;
   }
   if (point.x < 0 || point.x >= this.cubesWidth() || point.y < 0 || point.y >= this.cubesHeight()) {
      return true;
   }
   return false;
};

CubeGroup.prototype.displayCubes = function() {
   console.log('================');
   var output = 'Display Cubes\n';
   var row = 0;
   var col = this.cubesHeight() - 1;
   while (col >= 0) {
      while (row < this.cubesWidth()) {
         var cube = this.cubes[row][col];
         if (cube) {
            output += '# ';
         } else {
            output += '_ ';
         }
         row++;
      }
      row = 0;
      col--;
      output += '\n';
   }
   console.log(output);
   console.log('---------------');
};

CubeGroup.prototype.displayConnection = function(connection) {
   var graph = new Astar.Graph(this.cubesToGraph());
   var startPoint = this.find(connection.start);
   var endPoint = this.find(connection.end);
   if (!startPoint || !endPoint) {
      console.log('displayConnection failed to get points');
      return;
   }
   var start = graph.grid[startPoint.x][startPoint.y];
   var end = graph.grid[endPoint.x][endPoint.y];
   var result = Astar.astar.search(graph, start, end);
   result.unshift(start);
   var previous;
   for(var i = 0; i < result.length; i++) {
      var curPoint = new Phaser.Point(result[i].x, result[i].y);
      var cur = this.get(curPoint);
      var indicator = cur.cIndicator;
      var dir;
      var prevPoint;
      var nextPoint;
      if (!previous) {
         indicator.animations.play('end');
         nextPoint = new Phaser.Point(result[i+1].x, result[i+1].y);
         dir = this.dirBetween(curPoint, nextPoint);
         indicator.rotation = this.dirToAngle(dir);
      } else if (i === result.length - 1) {
         indicator.animations.play('end');
         prevPoint = new Phaser.Point(previous.x, previous.y);
         dir = this.dirBetween(curPoint, prevPoint);
         indicator.rotation = this.dirToAngle(dir);
      } else {
         indicator.animations.play('line');
         prevPoint = new Phaser.Point(previous.x, previous.y);
         var prevDir = this.dirBetween(curPoint, prevPoint);
         nextPoint = new Phaser.Point(result[i+1].x, result[i+1].y);
         var nextDir = this.dirBetween(curPoint, nextPoint);
         this.manageIndicator(indicator, prevDir, nextDir);
      }
      previous = result[i];
      cur.displayIndicator();
    }
};

CubeGroup.prototype.manageIndicator = function(indicator, prevDir, nextDir) {
  indicator.scale.setTo(Math.abs(indicator.scale.x), indicator.scale.y);
  if (prevDir === this.DIR.NORTH && nextDir === this.DIR.SOUTH) { // 2
      indicator.rotation = Math.PI;
   } else if (prevDir === this.DIR.SOUTH && nextDir === this.DIR.NORTH) { // 1
      indicator.rotation = 0;
   } else if (prevDir === this.DIR.EAST && nextDir === this.DIR.WEST) { // 4
      indicator.rotation = 1 / 2 * Math.PI;
   } else if (prevDir === this.DIR.WEST && nextDir === this.DIR.EAST) { // 3
      indicator.rotation = 3 / 2  * Math.PI;
   } else {
      indicator.animations.play('right');
      if (prevDir === this.DIR.SOUTH && nextDir === this.DIR.EAST) { // 5
         indicator.rotation = 0;
      } else if (prevDir === this.DIR.WEST && nextDir === this.DIR.SOUTH) { // 6
         indicator.rotation = 1 / 2 * Math.PI;
      } else if (prevDir === this.DIR.NORTH && nextDir === this.DIR.WEST) { // 7
         indicator.rotation = Math.PI;
      } else if (prevDir === this.DIR.EAST && nextDir === this.DIR.NORTH) { // 8
         indicator.rotation = 3 / 2 * Math.PI;
      } else {
         indicator.scale.setTo(-Math.abs(indicator.scale.x), indicator.scale.y);
         if (prevDir === this.DIR.SOUTH && nextDir === this.DIR.WEST) { // 9
            indicator.rotation = 0;
         } else if (prevDir === this.DIR.WEST && nextDir === this.DIR.NORTH) { // 10
            indicator.rotation = 1 / 2 * Math.PI;
         } else if (prevDir === this.DIR.NORTH && nextDir === this.DIR.EAST) { // 11
            indicator.rotation = Math.PI;
         } else if (prevDir === this.DIR.EAST && nextDir === this.DIR.SOUTH) { // 12
            indicator.rotation = 3 / 2 * Math.PI;
         }
      }
   } 
};

CubeGroup.prototype.cubesToGraph = function() {
  var graph = [];
  for (var row = 0; row < this.cubesWidth(); row++) {
     var newCol = [];
      for (var col = 0; col < this.cubesHeight(); col++) {
         if (this.cubes[row][col]) {
            newCol.push(1);
         } else {
            newCol.push(0);
         }
      }
      graph.push(newCol);
   }
   return graph;
};

CubeGroup.prototype.dirBetween = function(a, b) {
   var deltaX = a.x - b.x;
   var deltaY = a.y - b.y;
   if (deltaX > 0) {
      return this.DIR.WEST;
   }
   if (deltaX < 0) {
      return this.DIR.EAST;
   }
   if (deltaY > 0) {
      return this.DIR.SOUTH;
   }
   if (deltaY < 0) {
      return this.DIR.NORTH;
   }
   return this.DIR.NORTH;
};

CubeGroup.prototype.dirToAngle = function(dir) {
  switch (dir) {
   case this.DIR.NORTH:
   return Math.PI;
   case this.DIR.EAST:
   return 3 / 2 * Math.PI;
   case this.DIR.SOUTH:
   return 0;
   case this.DIR.WEST:
   return 1 / 2 * Math.PI;
  }  
};

CubeGroup.prototype.destroyCube = function(cube) {
  // console.log('destroyCube');
  var loc = this.find(cube);
  if (!loc) {
     console.log('attempt to destroy cube not in group');
     return;
  }
  // remove cube from group
  this.remove(cube);
  // destroy cube
  cube.kill(true);
};

CubeGroup.prototype.remove = function(cube) {
   // console.log('remove');
   if (this.root === cube) {
      return;
   }
   // remove cube from array
   var row, col;
   for (row = 0; row < this.cubesWidth(); row++) {
      for (col = 0; col < this.cubesHeight(); col++) {
         if (this.cubes[row][col] === cube) {
            // this.cubes[row][col].group = undefined;
            this.cubes[row][col] = undefined;
            break;
         }
      }
   }
   // remove constraints from cube
   this.removeConstraints(cube);
   cube.group = undefined;
   if (cube.module && cube.module.hasOwnProperty('onRemove')) {
      cube.module.onRemove();
   }
   // test for exiles
   for (row = 0; row < this.cubesWidth(); row++) {
      for (col = 0; col < this.cubesHeight(); col++) {
         var exile = this.cubes[row][col];
         if (exile && this.isExile(exile)) {
            this.remove(exile);
         }
      }
   }
   // this.displayCubes();
};

CubeGroup.prototype.removeNeighborsConstraint = function(constraint, cube) {
   // console.log('removeNeighborsConstraint');
   var neighbors = this.getNeighbors(cube);
   for (var i = 0; i < neighbors.length; i++) {
      var neighbor = neighbors[i];
      for (var j = 0; j < neighbor.constraints.length; j++) {
         if (neighbor.constraints[j] === constraint) {
            neighbor.constraints.splice(j, 1);
         }
      }
   }
};

CubeGroup.prototype.getNeighbors = function(cube) {
   var loc = this.find(cube);
   var north = this.get(this.adjust(loc, this.DIR.NORTH));
   var east = this.get(this.adjust(loc, this.DIR.EAST));
   var south = this.get(this.adjust(loc, this.DIR.SOUTH));
   var west = this.get(this.adjust(loc, this.DIR.WEST));
   var neighbors = [];
   if (north) {
      neighbors.push(north);
   }
   if (east) {
      neighbors.push(east);
   }
   if (south) {
      neighbors.push(south);
   }
   if (west) {
      neighbors.push(west);
   }
   return neighbors;
};

CubeGroup.prototype.removeConstraints = function(cube) {
   // console.log('removeConstraints');
   while (cube.constraints.length > 0) {
      this.removeNeighborsConstraint(cube.constraints[0], cube);
      this.game.physics.p2.removeConstraint(cube.constraints[0]);
      cube.constraints.splice(0, 1);
   }
};

// only used to test Astar
CubeGroup.prototype.testPath = function() {
  var graph = new Astar.Graph([
        [1,1,1,1],
        [0,1,1,0],
        [0,0,0,1]
    ]);
   var start = graph.grid[0][0];
   var end = graph.grid[2][3];
   var result = Astar.astar.search(graph, start, end);
   result.unshift(start);
   for(var i = 0; i < result.length; i++) {
      console.log(result[i].x, result[i].y);
    } 
};

CubeGroup.prototype.isExile = function(cube) {
   if (cube === this.root) {
      return;
   }
   var graph = new Astar.Graph(this.cubesToGraph());
   var startPoint = this.find(this.root);
   var endPoint = this.find(cube);
   var start = graph.grid[startPoint.x][startPoint.y];
   var end = graph.grid[endPoint.x][endPoint.y];
   var result = Astar.astar.search(graph, start, end);
   // if no path is found, the cube is an exile
   if (result.length === 0) {
      return true;
   }
   return false;
};

CubeGroup.prototype.countCubes = function() {
	var row, col;
	var num  = 0;
	for (row = 0; row < this.cubesWidth(); row++) {
		for (col = 0; col < this.cubesHeight(); col++) {
			if (this.cubes[row][col] !== undefined) {
				num++;
			}
		}
	}
	//console.log(num);
	this.numCubes = num;
};

module.exports = CubeGroup;

















},{"../libs/javascript-astar/astar":"C:\\Users\\mattd_000\\Documents\\GitHub\\AboveTheIronCurtain\\src\\js\\libs\\javascript-astar\\astar.js","./enemy_ai":"C:\\Users\\mattd_000\\Documents\\GitHub\\AboveTheIronCurtain\\src\\js\\entities\\enemy_ai.js"}],"C:\\Users\\mattd_000\\Documents\\GitHub\\AboveTheIronCurtain\\src\\js\\entities\\enemy_ai.js":[function(require,module,exports){
var Utils = require('../utils.js');

var EnemyAI = function(game, group, type, playerGroup) {
   this.game = game;
   this.group = group;
   this.type = type;
   this.playerGroup = playerGroup;
   this.player = this.playerGroup.root;
   this.ramDist = 500;
   this.rotationForce = 50;
   this.facingAllowance = Math.PI / 20;
   this.thrustersFiring = false;
   switch (this.type) {
      case 'ram':
      this.allocateToThrusters();
      break;
   }
};

EnemyAI.prototype.constructor = EnemyAI;

EnemyAI.prototype.update = function() {
   switch (this.type) {
      case 'ram':
      this.ramUpdate();
      break;
   }
};

EnemyAI.prototype.ramUpdate = function() {
   return;
   if (!this.group.root) {
      return;
   }
   var root = this.group.root;
   var myPos = new Phaser.Point(root.x, root.y);
   var playerPos = new Phaser.Point(this.player.x, this.player.y);
   var dist = Utils.distance(myPos.x, myPos.y, playerPos.x, playerPos.y);
   if (dist <= this.ramDist) {
      var angleTo = this.angleTo(myPos, playerPos);
      var diffAngle = angleTo - root.body.rotation;
      if (diffAngle > 0) {
         root.body.angularForce = this.rotationForce;
      } else {
         root.body.angularForce = -this.rotationForce;
      }
      if (Math.abs(diffAngle) <= this.facingAllowance && !this.thrustersFiring) {
         this.group.call('beginThrust');
         this.thrustersFiring = true;
         this.allocateToThrusters();
      } else if (Math.abs(diffAngle) > this.facingAllowance && this.thrustersFiring){
         this.group.call('endThrust');
         this.thrustersFiring = false;
      }
   }
};

EnemyAI.prototype.allocateToThrusters = function() {
   var panels = [];
   var thrusters = [];
   for (var row = 0; row < this.group.cubesWidth(); row++) {
      for (var col = 0; col < this.group.cubesHeight(); col++) {
         var cube = this.group.cubes[row][col];
         if (cube && cube.module) {
            if (cube.module.type === 'solarPanel' && !cube.myConnection) {
               panels.push(cube.module);
            } else if (cube.module.type === 'thruster' && !cube.myConnection) {
               thrusters.push(cube.module);
            }
         }
      }
   }
   var i = 0;
   while (i < thrusters.length && i < panels.length) {
      var tarPanel = panels[i];
      var tarThruster = thrusters[i];
      var newConnection = {start: tarPanel.cube, end: tarThruster.cube};
      tarPanel.cube.myConnection = newConnection;
      tarThruster.cube.myConnection = newConnection;
      this.group.displayConnection(tarPanel.cube.myConnection);
      i++;
   }
};

EnemyAI.prototype.angleTo = function(from, to) {
  var angleToOther = Phaser.Point.angle(from, to);
  if (angleToOther < 0) { // fix dumb part of Phaser.Point.angle()
     angleToOther = 2 * Math.PI + angleToOther;
  }
  angleToOther = (angleToOther + 3/2 * Math.PI) % (2 * Math.PI); // rotate 90 d clockwise
  return angleToOther;
};

module.exports = EnemyAI;











},{"../utils.js":"C:\\Users\\mattd_000\\Documents\\GitHub\\AboveTheIronCurtain\\src\\js\\utils.js"}],"C:\\Users\\mattd_000\\Documents\\GitHub\\AboveTheIronCurtain\\src\\js\\entities\\mouse.js":[function(require,module,exports){
var Utils = require('../utils.js');

var Mouse = function(game, input, playerGroup) {
   this.game = game;
   this.input = input;
	this.body = new p2.Body(); // jshint ignore:line
   this.game.physics.p2.world.addBody(this.body);
   // this.game.physics.p2.enable(this);
   
   this.input.onDown.add(this.click, this);
   this.input.onUp.add(this.release, this);
   this.input.addMoveCallback(this.move, this);
   this.x = 0;
   this.y = 0;
   
   this.grabbed = undefined;
   this.lastClicked = undefined;
   this.line = new Phaser.Line(0, 0, 0, 0);
   
   this.removeThreshold = 400; // time in milliseconds
   this.removeTime = 0; // time till threshold
   
   this.playerGroup = playerGroup;
};

Mouse.prototype.constructor = Mouse;

Mouse.prototype.update = function() {
   if (this.grabbed) {
      var angle = Math.atan2(this.grabbed.sprite.y - (this.input.position.y + this.game.camera.y), this.grabbed.sprite.x - (this.input.position.x+ this.game.camera.x)) + Math.PI;
      var dist = Utils.distance(this.grabbed.sprite.x, this.grabbed.sprite.y, (this.input.position.x+ this.game.camera.x), (this.input.position.y + this.game.camera.y));
      var weight = 10;
      if (!this.grabbed.sprite.group) {
         this.grabbed.force.x = Math.cos(angle) * dist * weight;
         this.grabbed.force.y = Math.sin(angle) * dist * weight;
      }
      this.line.setTo(this.grabbed.sprite.x, this.grabbed.sprite.y, (this.input.position.x+ this.game.camera.x), (this.input.position.y + this.game.camera.y));
      this.removeTime += this.game.time.elapsed;
      if (this.removeTime >= this.removeThreshold && this.grabbed.sprite.key !== 'asteroid') {
         this.grabbed.sprite.remove();
         this.removeTime = 0;
      }
    } else {
       this.line.setTo(0, 0, 0, 0);
    }
    var point = new Phaser.Point(this.x, this.y);
    var bodies = this.game.physics.p2.hitTest(point);
    if (bodies.length)
    {
        var hover = bodies[0].parent;
        if (hover.sprite.module && hover.sprite.module.mouseOver) {
           hover.sprite.module.mouseOver();
        }
    }
};

Mouse.prototype.click = function(pointer) {
   var point = new Phaser.Point(pointer.x + this.game.camera.x, pointer.y + this.game.camera.y);
   var bodies = this.game.physics.p2.hitTest(point);
   if (bodies.length)
   {
     var temp = bodies[0].parent;
     if (temp.sprite && temp.sprite.module && temp.sprite.module.type === 'core') {
        return;
     }
     if (temp.sprite && temp.sprite.group && temp.sprite.group !== this.playerGroup) {
        return;
     }
     this.removeTime = 0;
     this.grabbed = temp;
     // console.log(this.grabbed.sprite.name);
     if (this.grabbed.sprite.module && this.grabbed.sprite.module.hasOwnProperty('mouseDown')) {
        this.grabbed.sprite.module.mouseDown();
     }
     if (this.lastClicked && this.lastClicked.sprite && this.lastClicked.sprite.module &&
     this.lastClicked.sprite.module.giveTarget) {
        this.lastClicked.sprite.module.giveTarget(this.grabbed.sprite.module);
     }
     this.lastClicked = temp;
   }
};
  
 Mouse.prototype.release = function() {
   if (this.grabbed) {
     this.grabbed = undefined;
   }
};
  
Mouse.prototype.move = function(pointer) {
   // p2 uses different coordinate system, so convert the pointer position to p2's coordinate system
   this.body.position[0] = this.game.physics.p2.pxmi(pointer.position.x);
   this.body.position[1] = this.game.physics.p2.pxmi(pointer.position.y);
   this.x = pointer.position.x + this.game.camera.x;
   this.y = pointer.position.y + this.game.camera.y;
};

Mouse.prototype.render = function() {
   this.game.debug.geom(this.line);
};

module.exports = Mouse;















},{"../utils.js":"C:\\Users\\mattd_000\\Documents\\GitHub\\AboveTheIronCurtain\\src\\js\\utils.js"}],"C:\\Users\\mattd_000\\Documents\\GitHub\\AboveTheIronCurtain\\src\\js\\libs\\javascript-astar\\astar.js":[function(require,module,exports){
// javascript-astar 0.4.0
// http://github.com/bgrins/javascript-astar
// Freely distributable under the MIT License.
// Implements the astar search algorithm in javascript using a Binary Heap.
// Includes Binary Heap (with modifications) from Marijn Haverbeke.
// http://eloquentjavascript.net/appendix2.html

(function(definition) {
    /* global module, define */
    if(typeof module === 'object' && typeof module.exports === 'object') {
        module.exports = definition();
    } else if(typeof define === 'function' && define.amd) {
        define([], definition);
    } else {
        var exports = definition();
        window.astar = exports.astar;
        window.Graph = exports.Graph;
    }
})(function() {

function pathTo(node){
    var curr = node,
        path = [];
    while(curr.parent) {
        path.push(curr);
        curr = curr.parent;
    }
    return path.reverse();
}

function getHeap() {
    return new BinaryHeap(function(node) {
        return node.f;
    });
}

var astar = {
    /**
    * Perform an A* Search on a graph given a start and end node.
    * @param {Graph} graph
    * @param {GridNode} start
    * @param {GridNode} end
    * @param {Object} [options]
    * @param {bool} [options.closest] Specifies whether to return the
               path to the closest node if the target is unreachable.
    * @param {Function} [options.heuristic] Heuristic function (see
    *          astar.heuristics).
    */
    search: function(graph, start, end, options) {
        graph.cleanDirty();
        options = options || {};
        var heuristic = options.heuristic || astar.heuristics.manhattan,
            closest = options.closest || false;

        var openHeap = getHeap(),
            closestNode = start; // set the start node to be the closest if required

        start.h = heuristic(start, end);

        openHeap.push(start);

        while(openHeap.size() > 0) {

            // Grab the lowest f(x) to process next.  Heap keeps this sorted for us.
            var currentNode = openHeap.pop();

            // End case -- result has been found, return the traced path.
            if(currentNode === end) {
                return pathTo(currentNode);
            }

            // Normal case -- move currentNode from open to closed, process each of its neighbors.
            currentNode.closed = true;

            // Find all neighbors for the current node.
            var neighbors = graph.neighbors(currentNode);

            for (var i = 0, il = neighbors.length; i < il; ++i) {
                var neighbor = neighbors[i];

                if (neighbor.closed || neighbor.isWall()) {
                    // Not a valid node to process, skip to next neighbor.
                    continue;
                }

                // The g score is the shortest distance from start to current node.
                // We need to check if the path we have arrived at this neighbor is the shortest one we have seen yet.
                var gScore = currentNode.g + neighbor.getCost(currentNode),
                    beenVisited = neighbor.visited;

                if (!beenVisited || gScore < neighbor.g) {

                    // Found an optimal (so far) path to this node.  Take score for node to see how good it is.
                    neighbor.visited = true;
                    neighbor.parent = currentNode;
                    neighbor.h = neighbor.h || heuristic(neighbor, end);
                    neighbor.g = gScore;
                    neighbor.f = neighbor.g + neighbor.h;
                    graph.markDirty(neighbor);
                    if (closest) {
                        // If the neighbour is closer than the current closestNode or if it's equally close but has
                        // a cheaper path than the current closest node then it becomes the closest node
                        if (neighbor.h < closestNode.h || (neighbor.h === closestNode.h && neighbor.g < closestNode.g)) {
                            closestNode = neighbor;
                        }
                    }

                    if (!beenVisited) {
                        // Pushing to heap will put it in proper place based on the 'f' value.
                        openHeap.push(neighbor);
                    }
                    else {
                        // Already seen the node, but since it has been rescored we need to reorder it in the heap
                        openHeap.rescoreElement(neighbor);
                    }
                }
            }
        }

        if (closest) {
            return pathTo(closestNode);
        }

        // No result was found - empty array signifies failure to find path.
        return [];
    },
    // See list of heuristics: http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html
    heuristics: {
        manhattan: function(pos0, pos1) {
            var d1 = Math.abs(pos1.x - pos0.x);
            var d2 = Math.abs(pos1.y - pos0.y);
            return d1 + d2;
        },
        diagonal: function(pos0, pos1) {
            var D = 1;
            var D2 = Math.sqrt(2);
            var d1 = Math.abs(pos1.x - pos0.x);
            var d2 = Math.abs(pos1.y - pos0.y);
            return (D * (d1 + d2)) + ((D2 - (2 * D)) * Math.min(d1, d2));
        }
    },
    cleanNode:function(node){
        node.f = 0;
        node.g = 0;
        node.h = 0;
        node.visited = false;
        node.closed = false;
        node.parent = null;
    }
};

/**
* A graph memory structure
* @param {Array} gridIn 2D array of input weights
* @param {Object} [options]
* @param {bool} [options.diagonal] Specifies whether diagonal moves are allowed
*/
function Graph(gridIn, options) {
    options = options || {};
    this.nodes = [];
    this.diagonal = !!options.diagonal;
    this.grid = [];
    for (var x = 0; x < gridIn.length; x++) {
        this.grid[x] = [];

        for (var y = 0, row = gridIn[x]; y < row.length; y++) {
            var node = new GridNode(x, y, row[y]);
            this.grid[x][y] = node;
            this.nodes.push(node);
        }
    }
    this.init();
}

Graph.prototype.init = function() {
    this.dirtyNodes = [];
    for (var i = 0; i < this.nodes.length; i++) {
        astar.cleanNode(this.nodes[i]);
    }
};

Graph.prototype.cleanDirty = function() {
    for (var i = 0; i < this.dirtyNodes.length; i++) {
        astar.cleanNode(this.dirtyNodes[i]);
    }
    this.dirtyNodes = [];
};

Graph.prototype.markDirty = function(node) {
    this.dirtyNodes.push(node);
};

Graph.prototype.neighbors = function(node) {
    var ret = [],
        x = node.x,
        y = node.y,
        grid = this.grid;

    // West
    if(grid[x-1] && grid[x-1][y]) {
        ret.push(grid[x-1][y]);
    }

    // East
    if(grid[x+1] && grid[x+1][y]) {
        ret.push(grid[x+1][y]);
    }

    // South
    if(grid[x] && grid[x][y-1]) {
        ret.push(grid[x][y-1]);
    }

    // North
    if(grid[x] && grid[x][y+1]) {
        ret.push(grid[x][y+1]);
    }

    if (this.diagonal) {
        // Southwest
        if(grid[x-1] && grid[x-1][y-1]) {
            ret.push(grid[x-1][y-1]);
        }

        // Southeast
        if(grid[x+1] && grid[x+1][y-1]) {
            ret.push(grid[x+1][y-1]);
        }

        // Northwest
        if(grid[x-1] && grid[x-1][y+1]) {
            ret.push(grid[x-1][y+1]);
        }

        // Northeast
        if(grid[x+1] && grid[x+1][y+1]) {
            ret.push(grid[x+1][y+1]);
        }
    }

    return ret;
};

Graph.prototype.toString = function() {
    var graphString = [],
        nodes = this.grid, // when using grid
        rowDebug, row, y, l;
    for (var x = 0, len = nodes.length; x < len; x++) {
        rowDebug = [];
        row = nodes[x];
        for (y = 0, l = row.length; y < l; y++) {
            rowDebug.push(row[y].weight);
        }
        graphString.push(rowDebug.join(' '));
    }
    return graphString.join('\n');
};

function GridNode(x, y, weight) {
    this.x = x;
    this.y = y;
    this.weight = weight;
}

GridNode.prototype.toString = function() {
    return '[' + this.x + ' ' + this.y + ']';
};

GridNode.prototype.getCost = function(fromNeighbor) {
    // Take diagonal weight into consideration.
    if (fromNeighbor && fromNeighbor.x !== this.x && fromNeighbor.y !== this.y) {
        return this.weight * 1.41421;
    }
    return this.weight;
};

GridNode.prototype.isWall = function() {
    return this.weight === 0;
};

function BinaryHeap(scoreFunction){
    this.content = [];
    this.scoreFunction = scoreFunction;
}

BinaryHeap.prototype = {
    push: function(element) {
        // Add the new element to the end of the array.
        this.content.push(element);

        // Allow it to sink down.
        this.sinkDown(this.content.length - 1);
    },
    pop: function() {
        // Store the first element so we can return it later.
        var result = this.content[0];
        // Get the element at the end of the array.
        var end = this.content.pop();
        // If there are any elements left, put the end element at the
        // start, and let it bubble up.
        if (this.content.length > 0) {
            this.content[0] = end;
            this.bubbleUp(0);
        }
        return result;
    },
    remove: function(node) {
        var i = this.content.indexOf(node);

        // When it is found, the process seen in 'pop' is repeated
        // to fill up the hole.
        var end = this.content.pop();

        if (i !== this.content.length - 1) {
            this.content[i] = end;

            if (this.scoreFunction(end) < this.scoreFunction(node)) {
                this.sinkDown(i);
            }
            else {
                this.bubbleUp(i);
            }
        }
    },
    size: function() {
        return this.content.length;
    },
    rescoreElement: function(node) {
        this.sinkDown(this.content.indexOf(node));
    },
    sinkDown: function(n) {
        // Fetch the element that has to be sunk.
        var element = this.content[n];

        // When at 0, an element can not sink any further.
        while (n > 0) {

            // Compute the parent element's index, and fetch it.
            var parentN = ((n + 1) >> 1) - 1, parent = this.content[parentN]; // jshint ignore:line
            // Swap the elements if the parent is greater.
            if (this.scoreFunction(element) < this.scoreFunction(parent)) {
                this.content[parentN] = element;
                this.content[n] = parent;
                // Update 'n' to continue at the new position.
                n = parentN;
            }
            // Found a parent that is less, no need to sink any further.
            else {
                break;
            }
        }
    },
    bubbleUp: function(n) {
        // Look up the target element and its score.
        var length = this.content.length,
            element = this.content[n],
            elemScore = this.scoreFunction(element);

        while(true) {
            // Compute the indices of the child elements.
            var child2N = (n + 1) << 1, child1N = child2N - 1; // jshint ignore:line
            // This is used to store the new position of the element, if any.
            var swap = null,
                child1Score;
            // If the first child exists (is inside the array)...
            if (child1N < length) {
                // Look it up and compute its score.
                var child1 = this.content[child1N];
                child1Score = this.scoreFunction(child1);

                // If the score is less than our element's, we need to swap.
                if (child1Score < elemScore){
                    swap = child1N;
                }
            }

            // Do the same checks for the other child.
            if (child2N < length) {
                var child2 = this.content[child2N],
                    child2Score = this.scoreFunction(child2);
                if (child2Score < (swap === null ? elemScore : child1Score)) {
                    swap = child2N;
                }
            }

            // If the element needs to be moved, swap it, and continue.
            if (swap !== null) {
                this.content[n] = this.content[swap];
                this.content[swap] = element;
                n = swap;
            }
            // Otherwise, we are done.
            else {
                break;
            }
        }
    }
};

return {
    astar: astar,
    Graph: Graph
};

});

},{}],"C:\\Users\\mattd_000\\Documents\\GitHub\\AboveTheIronCurtain\\src\\js\\plugins\\Juicy.js":[function(require,module,exports){
'use strict';

/**
* @author       Jeremy Dowell <jeremy@codevinsky.com>
* @license      {@link http://www.wtfpl.net/txt/copying/|WTFPL}
*/

/**
* Creates a new `Juicy` object.
*
* @class Phaser.Plugin.Juicy
* @constructor
*
* @param {Phaser.Game} game Current game instance.
*/
Phaser.Plugin.Juicy = function (game) {

  Phaser.Plugin.call(this, game);

  /**
  * @property {Phaser.Rectangle} _boundsCache - A reference to the current world bounds.
  * @private
  */
  this._boundsCache = Phaser.Utils.extend(false, {}, this.game.world.bounds);

  /**
  * @property {number} _shakeWorldMax - The maximum world shake radius
  * @private
  */
  this._shakeWorldMax = 20;

  /**
  * @property {number} _shakeWorldTime - The maximum world shake time
  * @private
  */
  this._shakeWorldTime = 0;

  /**
  * @property {number} _trailCounter - A count of how many trails we're tracking
  * @private
  */  
  this._trailCounter = 0;

  /**
  * @property {object} _overScales - An object containing overscaling configurations
  * @private
  */  
  this._overScales = {};

  /**
  * @property {number} _overScalesCounter - A count of how many overScales we're tracking
  * @private
  */  
  this._overScalesCounter = 0;
};

if(typeof module === 'object' && module.exports) {
  module.exports = Phaser.Plugin.Juicy;
}

Phaser.Plugin.Juicy.prototype = Object.create(Phaser.Plugin.prototype);
Phaser.Plugin.Juicy.prototype.constructor = Phaser.Plugin.Juicy;

/**
* Creates a new `Juicy.ScreenFlash` object.
*
* @class Phaser.Plugin.Juicy.ScreenFlash
* @constructor
*
* @param {Phaser.Game} game -  Current game instance.
* @param {string} color='white' - The color to flash the screen.
* @memberof Phaser.Plugin.Juicy
*/
Phaser.Plugin.Juicy.ScreenFlash = function(game, color) {
  color = color || 'white';
  var bmd = game.add.bitmapData(game.width, game.height);
  bmd.ctx.fillStyle = color;
  bmd.ctx.fillRect(0,0, game.width, game.height);

  Phaser.Sprite.call(this, game, 0,0, bmd);
  this.alpha = 0;
};

Phaser.Plugin.Juicy.ScreenFlash.prototype = Object.create(Phaser.Sprite.prototype);
Phaser.Plugin.Juicy.ScreenFlash.prototype.constructor = Phaser.Plugin.Juicy.ScreenFlash;


/*
* Flashes the screen
*
* @param {number} [maxAlpha=1] - The maximum alpha to flash the screen to
* @param {number} [duration=100] - The duration of the flash in milliseconds
* @method Phaser.Plugin.Juicy.ScreenFlash.prototype.flash
* @memberof Phaser.Plugin.Juicy.ScreenFlash
*/
Phaser.Plugin.Juicy.ScreenFlash.prototype.flash = function(maxAlpha, duration) {
  maxAlpha = maxAlpha || 1;
  duration = duration || 100;
  var flashTween = this.game.add.tween(this).to({alpha: maxAlpha}, 100, Phaser.Easing.Bounce.InOut, true,0, 0, true);
  flashTween.onComplete.add(function() {
    this.alpha = 0;
  }, this);
};

/**
* Creates a new `Juicy.Trail` object.
*
* @class Phaser.Plugin.Juicy.Trail
* @constructor
*
* @param {Phaser.Game} game -  Current game instance.
* @param {number} [trailLength=100] - The length of the trail
* @param {number} [color=0xFFFFFF] - The color of the trail
* @memberof Phaser.Plugin.Juicy
*/
Phaser.Plugin.Juicy.Trail = function(game, trailLength, color) {
  Phaser.Graphics.call(this, game, 0,0);
  
  /**
  * @property {Phaser.Sprite} target - The target sprite whose movement we want to create the trail from
  */
  this.target = null;
  /**
  * @property {number} trailLength - The number of segments to use to create the trail
  */
  this.trailLength = trailLength || 100;
  /**
  * @property {number} trailWidth - The width of the trail
  */
  this.trailWidth = 15.0;

  /**
  * @property {boolean} trailScale - Whether or not to taper the trail towards the end
  */
  this.trailScaling = false;

  /**
  * @property {Phaser.Sprite} trailColor - The color of the trail
  */
  this.trailColor = color || 0xFFFFFF;
  
  /**
  * @property {Array<Phaser.Point>} _segments - A historical collection of the previous position of the target
  * @private
  */
  this._segments = [];
  /**
  * @property {Array<number>} _verts - A collection of vertices created from _segments
  * @private
  */
  this._verts = [];
  /**
  * @property {Array<Phaser.Point>} _segments - A collection of indices created from _verts
  * @private
  */
  this._indices = [];

};

Phaser.Plugin.Juicy.Trail.prototype = Object.create(Phaser.Graphics.prototype);
Phaser.Plugin.Juicy.Trail.prototype.constructor = Phaser.Plugin.Juicy.Trail;

/**
* Updates the Trail if a target is set
*
* @method Phaser.Plugin.Juicy.Trail#update
* @memberof Phaser.Plugin.Juicy.Trail
*/

Phaser.Plugin.Juicy.Trail.prototype.update = function() {
  if(this.target) {
    this.x = this.target.x;
    this.y = this.target.y;
    this.addSegment(this.target.x, this.target.y);
    this.redrawSegments(this.target.x, this.target.y);
  }
};

/**
* Adds a segment to the segments list and culls the list if it is too long
* 
* @param {number} [x] - The x position of the point
* @param {number} [y] - The y position of the point
* 
* @method Phaser.Plugin.Juicy.Trail#addSegment
* @memberof Phaser.Plugin.Juicy.Trail
*/
Phaser.Plugin.Juicy.Trail.prototype.addSegment = function(x, y) {
  var segment;

  while(this._segments.length > this.trailLength) {
    segment = this._segments.shift();
  }
  if(!segment) {
    segment = new Phaser.Point();
  }

  segment.x = x;
  segment.y = y;

  this._segments.push(segment);
};


/**
* Creates and draws the triangle trail from segments
* 
* @param {number} [offsetX] - The x position of the object
* @param {number} [offsetY] - The y position of the object
* 
* @method Phaser.Plugin.Juicy.Trail#redrawSegment
* @memberof Phaser.Plugin.Juicy.Trail
*/
Phaser.Plugin.Juicy.Trail.prototype.redrawSegments = function(offsetX, offsetY) {
  this.clear();
  var s1, // current segment
      s2, // previous segment
      vertIndex = 0, // keeps track of which vertex index we're at
      offset, // temporary storage for amount to extend line outwards, bigger = wider
      ang, //temporary storage of the inter-segment angles
      sin = 0, // as above
      cos = 0; // again as above

  // first we make sure that the vertice list is the same length as we we want
  // each segment (except the first) will create to vertices with two values each
  if (this._verts.length !== (this._segments.length -1) * 4) {
    // if it's not correct, we clear the entire list
    this._verts = [];
  }

  // now we loop over all the segments, the list has the "youngest" segment at the end
  var prevAng = 0; // jshint ignore:line
  
  for(var j = 0; j < this._segments.length; ++j) {
    // store the active segment for convenience
    s1 = this._segments[j];

    // if there's a previous segment, time to do some math
    if(s2) {
      // we calculate the angle between the two segments
      // the result will be in radians, so adding half of pi will "turn" the angle 90 degrees
      // that means we can use the sin and cos values to "expand" the line outwards
      ang = Math.atan2(s1.y - s2.y, s1.x - s2.x) + Math.PI / 2;
      sin = Math.sin(ang);
      cos = Math.cos(ang);

      // now it's time to creat ethe two vertices that will represent this pair of segments
      // using a loop here is probably a bit overkill since it's only two iterations
      for(var i = 0; i < 2; ++i) {
        // this makes the first segment stand out to the "left" of the line
        // annd the second to the right, changing that magic number at the end will alther the line width
        offset = ( -0.5 + i / 1) * this.trailWidth;

        // if trail scale effect is enabled, we scale down the offset as we move down the list
        if(this.trailScaling) {
          offset *= j / this._segments.length;
        }

        // finally we put to values in the vert list
        // using the segment coordinates as a base we add the "extended" point
        // offsetX and offsetY are used her to move the entire trail
        this._verts[vertIndex++] = s1.x + cos * offset - offsetX;
        this._verts[vertIndex++] = s1.y + sin * offset - offsetY;
      }
    }
    // finally store the current segment as the previous segment and go for another round
    s2 = s1.copyTo({});
  }
  // we need at least four vertices to draw something
  if(this._verts.length >= 8) {
    // now, we have a triangle "strip", but flash can't draw that without 
    // instructions for which vertices to connect, so it's time to make those
    
    // here, we loop over all the vertices and pair them together in triangles
    // each group of four vertices forms two triangles
    for(var k = 0; k < this._verts.length; k++) {
      this._indices[k * 6 + 0] = k * 2 + 0;
      this._indices[k * 6 + 1] = k * 2 + 1;
      this._indices[k * 6 + 2] = k * 2 + 2;
      this._indices[k * 6 + 3] = k * 2 + 1;
      this._indices[k * 6 + 4] = k * 2 + 2;
      this._indices[k * 6 + 5] = k * 2 + 3;
    }
    this.beginFill(this.trailColor);
    this.drawTriangles(this._verts, this._indices);
    this.endFill();
    
  }
};

Phaser.Plugin.Juicy.prototype.shake = function (duration, strength) {
  if (this.game.camera.target !== null) {
     this.cameraTarget = this.game.camera.target;
     this.game.camera.unfollow();
  }
  this._shakeWorldTime = duration || 20;
  this._shakeWorldMax = strength || 20;
};

Phaser.Plugin.Juicy.prototype.createScreenFlash = function(color) {
    return new Phaser.Plugin.Juicy.ScreenFlash(this.game, color);
};


Phaser.Plugin.Juicy.prototype.createTrail = function(length, color) {
  return new Phaser.Plugin.Juicy.Trail(this.game, length, color);
};

Phaser.Plugin.Juicy.prototype.overScale = function(object, scale, initialScale) {
  scale = scale || 1.5;
  var id = this._overScalesCounter++;
  initialScale = initialScale || new Phaser.Point(1,1);
  var scaleObj = this._overScales[id];
  if(!scaleObj) {
    scaleObj = {
      object: object,
      cache: initialScale.copyTo({})
    };
  } 
  scaleObj.scale = scale;
  
  this._overScales[id] = scaleObj;
};

Phaser.Plugin.Juicy.prototype.jelly = function(object, strength, delay, initialScale) {
  strength = strength || 0.2;
  delay = delay || 0;
  initialScale = initialScale ||  new Phaser.Point(1, 1);
  
  this.game.add.tween(object.scale).to({x: initialScale.x + (initialScale.x * strength)}, 50, Phaser.Easing.Quadratic.InOut, true, delay)
  .to({x: initialScale.x}, 600, Phaser.Easing.Elastic.Out, true);

  this.game.add.tween(object.scale).to({y: initialScale.y + (initialScale.y * strength)}, 50, Phaser.Easing.Quadratic.InOut, true, delay + 50)
  .to({y: initialScale.y}, 600, Phaser.Easing.Elastic.Out, true);
};

Phaser.Plugin.Juicy.prototype.mouseStretch = function(object, strength, initialScale) {
    strength = strength || 0.5;
    initialScale = initialScale || new Phaser.Point(1,1);
    object.scale.x = initialScale.x + (Math.abs(object.x - this.game.input.activePointer.x) / 100) * strength;
    object.scale.y = initialScale.y + (initialScale.y * strength) - (object.scale.x * strength);
};

Phaser.Plugin.Juicy.prototype.update = function () {
  var scaleObj;
  // Screen Shake
  if(this._shakeWorldTime > 0) { 
    var magnitude = (this._shakeWorldTime / this._shakeWorldMax) * this._shakeWorldMax;
    var x = this.game.rnd.integerInRange(-magnitude, magnitude) + this.cameraTarget.x - this.game.camera.width / 2;
    var y = this.game.rnd.integerInRange(-magnitude, magnitude) + this.cameraTarget.y - this.game.camera.height / 2;

    this.game.camera.x = x;
    this.game.camera.y = y;
    this._shakeWorldTime--;
    if(this._shakeWorldTime <= 0) {
       this.game.camera.follow(this.cameraTarget);
    }
  }

  // over scales
  for(var s in this._overScales) {
    if(this._overScales.hasOwnProperty(s)) {
      scaleObj = this._overScales[s];
      if(scaleObj.scale > 0.01) {
        scaleObj.object.scale.x = scaleObj.scale * scaleObj.cache.x;
        scaleObj.object.scale.y = scaleObj.scale * scaleObj.cache.y;
        scaleObj.scale -= this.game.time.elapsed * scaleObj.scale * 0.35;
      } else {
        scaleObj.object.scale.x = scaleObj.cache.x;
        scaleObj.object.scale.y = scaleObj.cache.y;
        delete this._overScales[s];
      }
    }
  }
};

// Draw Triangles Polyfill for back compatibility
if(!Phaser.Graphics.prototype.drawTriangle) {
  Phaser.Graphics.prototype.drawTriangle = function(points, cull) {
      var triangle = new Phaser.Polygon(points);
      if (cull) {
          var cameraToFace = new Phaser.Point(this.game.camera.x - points[0].x, this.game.camera.y - points[0].y);
          var ab = new Phaser.Point(points[1].x - points[0].x, points[1].y - points[0].y);
          var cb = new Phaser.Point(points[1].x - points[2].x, points[1].y - points[2].y);
          var faceNormal = cb.cross(ab);
          if (cameraToFace.dot(faceNormal) > 0) {
              this.drawPolygon(triangle);
          }
      } else {
          this.drawPolygon(triangle);
      }
      return;
  };
}
},{}],"C:\\Users\\mattd_000\\Documents\\GitHub\\AboveTheIronCurtain\\src\\js\\states\\boot.js":[function(require,module,exports){
var Boot = function () {};

module.exports = Boot;

Boot.prototype = {

  preload: function () {
    this.load.image('preloader', 'assets/preloader.gif');
  },

  create: function () {
    this.game.input.maxPointers = 1;

    /*
    if (this.game.device.desktop) {
      //this.game.stage.scale.pageAlignHorizontally = true;
      this.game.scale.scaleMode = Phaser.ScaleManager.RESIZE;
    } else {
      this.game.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL;
      this.game.scale.minWidth =  480;
      this.game.scale.minHeight = 260;
      this.game.scale.maxWidth = 640;
      this.game.scale.maxHeight = 480;
      this.game.scale.forceLandscape = true;
      this.game.scale.pageAlignHorizontally = true;
      this.game.scale.setScreenSize(true);
    }
    */
    var width = 800;
    var height = 800;
    this.game.width = width;
    this.game.height = height;
    // this.game.stage.bounds.width = width;
    // this.game.stage.bounds.height = height;
    // this.game.renderer.resize(width, height);

    this.game.state.start('Preloader');
  }
};

},{}],"C:\\Users\\mattd_000\\Documents\\GitHub\\AboveTheIronCurtain\\src\\js\\states\\game.js":[function(require,module,exports){
/*
Main testing environment.
*/

var ModuleBuilder = require('../entities/ModuleBuilder');
var CubeGroup = require('../entities/cube_group');
var Mouse = require('../entities/mouse');
var Juicy = require('../plugins/Juicy'); // jshint ignore:line

var bg, bg2;
var numRoids = 0;
var maxRoids = 50;
var asteroids, asteroidList;
var leftKey, rightKey, cwKey, ccwKey;
var asteroidCG, cubeCG;

var Game = function () {
  this.testentity = null;
};

module.exports = Game;

Game.prototype = {
	
  create: function () {
	this.game.world.setBounds(0, 0, 8000, 4000);
	
	//Create the two background images
    bg = this.game.add.sprite(0, 0, 'earthNight');
	bg2 = this.game.add.sprite(-8000, 0, 'earthNight');
	
	this.game.physics.startSystem(Phaser.Physics.P2JS);
   this.game.physics.p2.setImpactEvents(true);

	cubeCG = this.game.physics.p2.createCollisionGroup();
	asteroidCG = this.game.physics.p2.createCollisionGroup();
	
   this.mouse = new Mouse(this.game, this.input);
   
   this.updateDependents = [];
   
	//create ModuleBuilder and store it in this game state object
	this.moduleBuilder = new ModuleBuilder(this);
	//create and store the core module
	this.coreModule = this.moduleBuilder.build('core', 1500, 1500, true);
	this.cubeWidth = this.coreModule.cube.width;
	this.coreModule.cube.body.setCollisionGroup(cubeCG);
	this.coreModule.cube.body.collides([cubeCG, asteroidCG]);
	this.cubeBuffer = 2;
	var playerGroup = new CubeGroup(this, this.coreModule.cube);
	this.updateDependents.push(playerGroup);
	this.player = playerGroup;
   this.player.isPlayer = true;
   
   this.mouse = new Mouse(this.game, this.input, playerGroup);
	this.player.isPlayer = true;
   
	this.spaceKey = this.game.input.keyboard.addKey(Phaser.Keyboard.SPACEBAR);
	this.game.input.keyboard.addKeyCapture([this.spaceKey]);
	
	asteroids = this.game.add.group();
	asteroids.enableBody = true;
	asteroids.physicsBodyType = Phaser.Physics.P2JS;
	asteroidList = new Phaser.ArraySet();
	this.generateAsteroids();
	
	leftKey = this.game.input.keyboard.addKey(Phaser.Keyboard.A);
	rightKey = this.game.input.keyboard.addKey(Phaser.Keyboard.D);
	ccwKey = this.game.input.keyboard.addKey(Phaser.Keyboard.Q);
	cwKey = this.game.input.keyboard.addKey(Phaser.Keyboard.E);
	
	//DEBUGGING LISTENERS- allow you to create modules by pressing keys
	//core
	this.placeCoreKey = this.game.input.keyboard.addKey(Phaser.Keyboard.P);
	this.placeCoreKey.onDown.add(this.addCore, this);
	//shield
	this.placeShieldKey = this.game.input.keyboard.addKey(Phaser.Keyboard.O);
    this.placeShieldKey.onDown.add(this.addShield, this);
	//thruster
	this.placeThrusterKey = this.game.input.keyboard.addKey(Phaser.Keyboard.I);
    this.placeThrusterKey.onDown.add(this.addThruster, this);
	//solarPanel
	this.placeSPKey = this.game.input.keyboard.addKey(Phaser.Keyboard.U);
    this.placeSPKey.onDown.add(this.addSP, this);
	//gun
	this.placeGunKey = this.game.input.keyboard.addKey(Phaser.Keyboard.Y);
    this.placeGunKey.onDown.add(this.addGun, this);
	//END
    
    // Debug controller
    this.debugKey = this.game.input.keyboard.addKey(Phaser.Keyboard.H);
    this.debugKey.onDown.add(this.debug, this);
    this.rootSpawned = false;
    
    this.debugNum = 0;
    this.myRoot = undefined;

	 this.game.camera.setPosition(1000, 1000);
    
    this.levelData = JSON.parse(this.game.cache.getText('level_one'));
    this.loadData();
    
    this.juicy = this.game.plugins.add(new Phaser.Plugin.Juicy(this));
    this.game.camera.follow(this.coreModule.cube);
  },
  
  loadData: function() {
      var myLevel = this.levelData['level_one'];
      for (var key in myLevel) {
         if (myLevel.hasOwnProperty(key)) {
            var element = myLevel[key];
            if (element.hasOwnProperty('blueprint')) { // enemy type
               var enemyX = element['x_pos'];
               var enemyY = element['y_pos'];
               var enemyGroup = new CubeGroup(this, undefined);
               this.updateDependents.push(enemyGroup);
               var blueprint = element['blueprint'];
               // var practical = [];
               for (var row = 0; row < blueprint.length; row++) {
                  // var newCol = [];
                  for (var col = 0; col < blueprint[row].length; col++) {
                     var type = blueprint[row][col];
                     var newModule = this.moduleBuilder.build(type, enemyX + row * (this.cubeWidth + this.cubeBuffer),
                     enemyY - col * (this.cubeWidth + this.cubeBuffer), false);
					 newModule.cube.body.setCollisionGroup(cubeCG);
					 newModule.cube.body.collides([cubeCG, asteroidCG]);
                     // newCol.push(newModule.cube);
                     var point = new Phaser.Point(row, col);
                     enemyGroup.add(newModule.cube, point);
                  }
                  // practical.push(newCol);
               }
               // TODO: give different types here
               enemyGroup.giveAI('ram', this.player);
            }
         }
      }
  },

  update: function () {    
	if(leftKey.isDown) {
		if(this.coreModule.cube.body.angularVelocity > -9) { 
			this.coreModule.cube.body.angularForce += -5 * Math.pow(this.player.numCubes, 1.65);
		}
	}
	
	if(rightKey.isDown) {
		if(this.coreModule.cube.body.angularVelocity < 9) {
			this.coreModule.cube.body.angularForce += 5 * Math.pow(this.player.numCubes, 1.65);
		}
	}
	
	if(ccwKey.isDown) {
		if(this.mouse.grabbed !== undefined && this.mouse.grabbed.sprite.group === undefined) {
			this.mouse.grabbed.angularForce += -5;
		}
	}
	
	if(cwKey.isDown) {
		if(this.mouse.grabbed !== undefined && this.mouse.grabbed.sprite.group === undefined) {
			this.mouse.grabbed.angularForce += 5;
		}
	}
	
	this.mouse.update();
	this.scrollBG();
   
	for (var i = 0; i < this.updateDependents.length; i++) {
		if (this.updateDependents[i].update) {
			this.updateDependents[i].update();
		}
	}
  },
  
  render: function () {
	this.mouse.render();
  },
  
	scrollBG: function() {
		bg.x += 0.125;
		if(bg.x >= 8000) {
			bg.x += 0;
		}
		bg2.x += 0.125;
		if(bg2.x >= 8000) {
			bg2.x = 0;
		}
	},
	
	generateAsteroids: function() {
		for(;numRoids < maxRoids; numRoids++) {
			var coinA = this.game.rnd.integerInRange(0,1);
			var coinB = this.game.rnd.integerInRange(0,1);
			var asteroid;
			if(coinA === 1) {
				if(coinB === 1) { //Spawn asteroid above screen
					asteroid = asteroids.create(this.coreModule.cube.x + this.game.rnd.integerInRange(-this.game.camera.width/2, this.game.camera.width/2), this.coreModule.cube.y - this.game.camera.height/2 - this.game.rnd.integerInRange(32, 300), 'asteroid');
				}
				else { //Spawn asteroid below screen
					asteroid = asteroids.create(this.coreModule.cube.x + this.game.rnd.integerInRange(-this.game.camera.width/2, this.game.camera.width/2), this.coreModule.cube.y + this.game.camera.height/2 + this.game.rnd.integerInRange(32, 300), 'asteroid');
				}
			}
			else {
				if(coinB === 1) { //Spawn asteroid to left of screen
					asteroid = asteroids.create(this.coreModule.cube.x - this.game.camera.width/2 - this.game.rnd.integerInRange(32, 300), this.coreModule.cube.y + this.game.rnd.integerInRange(-this.game.camera.height/2, this.game.camera.height/2), 'asteroid');
				}
				else { //Spawn asteroid to right
					asteroid = asteroids.create(this.coreModule.cube.x + this.game.camera.width/2 + this.game.rnd.integerInRange(32, 300), this.coreModule.cube.y + this.game.rnd.integerInRange(-this.game.camera.height/2, this.game.camera.height/2), 'asteroid');
				}
			}
			
			asteroid.body.setCircle(16); //Change the collision detection from an AABB to a circle
			asteroid.body.angularDamping = 0;
			asteroid.body.damping = 0;
			asteroid.body.rotation = this.game.rnd.realInRange(0, 2 * 3.14);
			asteroid.body.force.x = this.game.rnd.integerInRange(-10, 10) * 750;
			asteroid.body.force.y = this.game.rnd.integerInRange(-10, 10) * 750;
			asteroid.body.setCollisionGroup(asteroidCG);
			asteroid.body.collides([asteroidCG, cubeCG]);
			asteroid.body.collideWorldBounds = false;
			asteroid.autoCull = true;
			asteroid.checkWorldBounds = true;
			asteroid.events.onOutOfBounds.add(this.resetAsteroid, asteroid);
			asteroidList.add(asteroid);
		}
	},
	
	resetAsteroid: function() { //Needs to be updated once collision groups are working
		//this.obj.x = 10;
		//this.obj.y = 10;
	},
	
  //DEBUG FUNCTIONS- event functions called from listeners that allow you to create modules with key presses
  addCore: function () { 
	//Attempts to create more core modules here will only return the existing core
	var newModule = this.moduleBuilder.build('core', this.mouse.x, this.mouse.y, true);
	newModule.cube.body.setCollisionGroup(cubeCG);
	newModule.cube.body.collides([cubeCG, asteroidCG]);
  },
  addShield: function () {
	var newModule = this.moduleBuilder.build('shield', this.mouse.x, this.mouse.y, true);
	newModule.cube.body.setCollisionGroup(cubeCG);
	newModule.cube.body.collides([cubeCG, asteroidCG]);
  },
  addThruster: function () {
	var newModule = this.moduleBuilder.build('thruster', this.mouse.x, this.mouse.y, true);
	newModule.cube.body.setCollisionGroup(cubeCG);
	newModule.cube.body.collides([cubeCG, asteroidCG]);
  },
  addSP: function () {
	var newModule = this.moduleBuilder.build('solarPanel', this.mouse.x, this.mouse.y, true);
	newModule.cube.body.setCollisionGroup(cubeCG);
	newModule.cube.body.collides([cubeCG, asteroidCG]);
  },
  addGun: function () {
	var newModule = this.moduleBuilder.build('gun', this.mouse.x, this.mouse.y, true);
	newModule.cube.body.setCollisionGroup(cubeCG);
	newModule.cube.body.collides([cubeCG, asteroidCG]);
  },

  debug: function () {
    this.juicy.shake();
  }
};




























},{"../entities/ModuleBuilder":"C:\\Users\\mattd_000\\Documents\\GitHub\\AboveTheIronCurtain\\src\\js\\entities\\ModuleBuilder.js","../entities/cube_group":"C:\\Users\\mattd_000\\Documents\\GitHub\\AboveTheIronCurtain\\src\\js\\entities\\cube_group.js","../entities/mouse":"C:\\Users\\mattd_000\\Documents\\GitHub\\AboveTheIronCurtain\\src\\js\\entities\\mouse.js","../plugins/Juicy":"C:\\Users\\mattd_000\\Documents\\GitHub\\AboveTheIronCurtain\\src\\js\\plugins\\Juicy.js"}],"C:\\Users\\mattd_000\\Documents\\GitHub\\AboveTheIronCurtain\\src\\js\\states\\menu.js":[function(require,module,exports){
var Menu = function () {
  this.text = null;
};

module.exports = Menu;

Menu.prototype = {

  create: function () {
    var x = this.game.width / 2;
    var y = this.game.height / 2;

    var style = { font: '65px Arial', fill: '#ffffff', align: 'center' };
    this.title = this.game.add.text(this.game.world.centerX, this.game.world.centerY - 250, 'Above The Iron Curtain', style);
    this.newGame = this.game.add.text(this.game.world.centerX, this.game.world.centerY - 150, 'New Simulation', style);
    this.level = this.game.add.text(this.game.world.centerX, this.game.world.centerY - 50, 'Mission Select', style);
    this.controls = this.game.add.text(this.game.world.centerX, this.game.world.centerY + 50, 'Manual', style);
    this.credits = this.game.add.text(this.game.world.centerX, this.game.world.centerY + 150, 'Credits', style);

    this.input.onDown.add(this.onDown, this);
  },

  update: function () {
  },

  onDown: function () {
    this.game.state.start(playerState.currentLevel); // jshint ignore:line
  }
};

},{}],"C:\\Users\\mattd_000\\Documents\\GitHub\\AboveTheIronCurtain\\src\\js\\states\\preloader.js":[function(require,module,exports){
var Preloader = function (game) {
  game = null;
  this.asset = null;
  this.ready = false;
};

module.exports = Preloader;

Preloader.prototype = {

  preload: function () {
    this.asset = this.add.sprite(640, 360, 'preloader');
    this.asset.anchor.setTo(0.5, 0.5);

    this.load.onLoadComplete.addOnce(this.onLoadComplete, this);
    this.load.setPreloadSprite(this.asset);
    this.load.image('testsprite', 'assets/test2.png');
	this.load.spritesheet('core', 'assets/coreSheet.png', 64, 64); 
	this.load.spritesheet('thruster', 'assets/thrusterSheet.png', 64, 64);
	this.load.spritesheet('gun', 'assets/gunSheet.png', 64, 64);
	this.load.image('shield', 'assets/shield.png');
	this.load.image('solarPanel', 'assets/solarPanel.png');
	this.load.image('asteroid', 'assets/asteroid.png');
   this.load.atlasJSONHash('connections', 'assets/connections.png', 'assets/connections.json');
	this.load.image('earthNight', 'assets/bg_earthNightSmall.jpg');
    this.load.physics('module_physics', 'assets/module_physics.json');
   this.load.text('level_one', 'assets/level_one.json');
  },

  create: function () {
    this.asset.cropEnabled = false;
  },

  update: function () {
    if (!!this.ready) {
      //this.game.state.start('Menu');
      this.game.state.start(playerState.currentLevel); // jshint ignore:line
    }
  },

  onLoadComplete: function () {
    this.ready = true;
  }
};

},{}],"C:\\Users\\mattd_000\\Documents\\GitHub\\AboveTheIronCurtain\\src\\js\\states\\splash.js":[function(require,module,exports){
var Splash = function () {
};

module.exports = Splash;

Splash.prototype = {
  create: function () {
  }
};
},{}],"C:\\Users\\mattd_000\\Documents\\GitHub\\AboveTheIronCurtain\\src\\js\\utils.js":[function(require,module,exports){
/*
Collection of utility functions.
*/

var Utils = {
    containsObject: function(obj, list) {
        var i;
        for (i = 0; i < list.length; i++) {
            if (list[i] === obj) {
                return true;
            }
        }

        return false;
    },
    distance: function(x1, y1, x2, y2) {
       return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
    }
};

module.exports = Utils;
},{}]},{},["./src/js/main.js"])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlc1xcYnJvd3NlcmlmeVxcbm9kZV9tb2R1bGVzXFxicm93c2VyLXBhY2tcXF9wcmVsdWRlLmpzIiwic3JjL2pzL21haW4uanMiLCJzcmMvanMvZW50aXRpZXMvTW9kdWxlLmpzIiwic3JjL2pzL2VudGl0aWVzL01vZHVsZUJ1aWxkZXIuanMiLCJzcmMvanMvZW50aXRpZXMvY3ViZS5qcyIsInNyYy9qcy9lbnRpdGllcy9jdWJlX2dyb3VwLmpzIiwic3JjL2pzL2VudGl0aWVzL2VuZW15X2FpLmpzIiwic3JjL2pzL2VudGl0aWVzL21vdXNlLmpzIiwic3JjL2pzL2xpYnMvamF2YXNjcmlwdC1hc3Rhci9hc3Rhci5qcyIsInNyYy9qcy9wbHVnaW5zL0p1aWN5LmpzIiwic3JjL2pzL3N0YXRlcy9ib290LmpzIiwic3JjL2pzL3N0YXRlcy9nYW1lLmpzIiwic3JjL2pzL3N0YXRlcy9tZW51LmpzIiwic3JjL2pzL3N0YXRlcy9wcmVsb2FkZXIuanMiLCJzcmMvanMvc3RhdGVzL3NwbGFzaC5qcyIsInNyYy9qcy91dGlscy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDellBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGdhbWUgPSBuZXcgUGhhc2VyLkdhbWUoMTI4MCwgNzIwLCBQaGFzZXIuQVVUTywgJ2F0aWMtZ2FtZScpO1xyXG5cclxud2luZG93LnBsYXllclN0YXRlID0ge1xyXG4gICAgY3VycmVudExldmVsOiAnR2FtZSdcclxufTtcclxuXHJcbmdhbWUuc3RhdGUuYWRkKCdCb290JywgcmVxdWlyZSgnLi9zdGF0ZXMvYm9vdCcpKTtcclxuZ2FtZS5zdGF0ZS5hZGQoJ1NwbGFzaCcsIHJlcXVpcmUoJy4vc3RhdGVzL3NwbGFzaCcpKTtcclxuZ2FtZS5zdGF0ZS5hZGQoJ1ByZWxvYWRlcicsIHJlcXVpcmUoJy4vc3RhdGVzL3ByZWxvYWRlcicpKTtcclxuZ2FtZS5zdGF0ZS5hZGQoJ01lbnUnLCByZXF1aXJlKCcuL3N0YXRlcy9tZW51JykpO1xyXG5nYW1lLnN0YXRlLmFkZCgnR2FtZScsIHJlcXVpcmUoJy4vc3RhdGVzL2dhbWUnKSk7XHJcblxyXG5nYW1lLnN0YXRlLnN0YXJ0KCdCb290Jyk7IiwiLy9Eb24ndCB1c2UgdGhpcyBmdW5jdGlvbiB0byBjcmVhdGUgbW9kdWxlcywgaW5zdGVhZCB1c2UgbW9kdWxlQnVpbGRlcigpXHJcbnZhciBNb2R1bGUgPSBmdW5jdGlvbihzZXRDdWJlLCB0eXBlKSB7XHJcbiAgIHRoaXMuY3ViZSA9IHNldEN1YmU7XHJcbiAgIHRoaXMuY3ViZS5tb2R1bGUgPSB0aGlzO1xyXG4gICB0aGlzLnR5cGUgPSB0eXBlO1xyXG59O1xyXG5cclxuTW9kdWxlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1vZHVsZTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTW9kdWxlOyIsInZhciBDdWJlID0gcmVxdWlyZSgnLi9jdWJlJyk7XHJcbnZhciBNb2R1bGUgPSByZXF1aXJlKCcuL01vZHVsZScpO1xyXG5cclxudmFyIHRocnVzdEFtdCA9IDUwMDA7XHJcblxyXG4vL1VzZSB0aGlzIHRvIGNyZWF0ZSBhIG1vZHVsZUJ1aWxkZXItIG9ubHkgbmVlZCB0byBjcmVhdGUgb25lIGluc3RhbmNlIG9mIGl0XHJcbnZhciBNb2R1bGVCdWlsZGVyID0gZnVuY3Rpb24oc2V0R2FtZVN0YXRlLCBzZXRDb2xHcm91cCkge1xyXG5cdC8vRW5zdXJlIHRoYXQgY2Fubm90IGNyZWF0ZSBtdWx0aXBsZSBpbnN0YW5jZXMgb2YgdGhpcyBjbGFzc1xyXG5cdGlmKE1vZHVsZUJ1aWxkZXIucHJvdG90eXBlLmV4aXN0cykge1xyXG5cdFx0cmV0dXJuIE1vZHVsZUJ1aWxkZXIucHJvdG90eXBlLmV4aXN0aW5nUmVmZXJlbmNlO1xyXG5cdH1cclxuXHRcdFxyXG5cdHRoaXMuZ2FtZVN0YXRlID0gc2V0R2FtZVN0YXRlO1xyXG4gICB0aGlzLmNvbEdyb3VwID0gc2V0Q29sR3JvdXA7XHJcblx0Ly8gdGhpcy5jb3JlRXhpc3RzID0gZmFsc2U7XHQvL3JlY29yZHMgaWYgY29yZSBoYXMgYmVlbiBjcmVhdGVkXHJcblx0dGhpcy5jb3JlID0gbnVsbDtcdFx0XHQvL3N0b3JlcyBjb3JlIHdoZW4gaXQgaXMgY3JlYXRlZFxyXG5cdC8vdmFyIHNwYWNlID0gdGhpcy5nYW1lU3RhdGUuaW5wdXQua2V5Ym9hcmQuYWRkS2V5KFBoYXNlci5LZXlib2FyZC5TUEFDRUJBUik7XHJcblx0TW9kdWxlQnVpbGRlci5wcm90b3R5cGUuZXhpc3RzID0gdHJ1ZTtcclxuXHRNb2R1bGVCdWlsZGVyLnByb3RvdHlwZS5leGlzdGluZ1JlZmVyZW5jZSA9IHRoaXM7XHJcbn07XHJcblxyXG5Nb2R1bGVCdWlsZGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1vZHVsZUJ1aWxkZXI7XHJcblxyXG4vL1RoZXNlIHZhcidzIGhlbHAgY3JlYXRlIHRoZSBzaW5nbGV0b24gZnVuY3Rpb25hbGl0eVxyXG5Nb2R1bGVCdWlsZGVyLnByb3RvdHlwZS5leGlzdHMgPSBmYWxzZTtcclxuTW9kdWxlQnVpbGRlci5wcm90b3R5cGUuZXhpc3RpbmdSZWZlcmVuY2UgPSBudWxsO1xyXG5cclxuLyoqIE1vZHVsZSBmdW5jdGlvbnMgKiovXHJcbmZ1bmN0aW9uIHNvbGFyUGFuZWxHaXZlVGFyZ2V0KHRhcmdldCkge1xyXG4gICBpZiAodGhpcy5jdWJlLmdyb3VwICYmIHRhcmdldC5jdWJlLmdyb3VwICYmIHRoaXMuY3ViZS5ncm91cCAhPT0gdGFyZ2V0LmN1YmUuZ3JvdXAgfHwgdGhpcyA9PT0gdGFyZ2V0KSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgfVxyXG4gICB2YXIgb3VyR3JvdXAgPSB0aGlzLmN1YmUuZ3JvdXA7XHJcbiAgIHZhciBuZXdDb25uZWN0aW9uID0ge3N0YXJ0OiB0aGlzLmN1YmUsIGVuZDogdGFyZ2V0LmN1YmV9O1xyXG4gICB0aGlzLmN1YmUubXlDb25uZWN0aW9uID0gbmV3Q29ubmVjdGlvbjtcclxuICAgdGFyZ2V0LmN1YmUubXlDb25uZWN0aW9uID0gbmV3Q29ubmVjdGlvbjtcclxuICAgb3VyR3JvdXAuZGlzcGxheUNvbm5lY3Rpb24odGhpcy5jdWJlLm15Q29ubmVjdGlvbik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNvbGFyUGFuZWxNb3VzZU92ZXIoKSB7XHJcbiAgIGlmICghdGhpcy5jdWJlLm15Q29ubmVjdGlvbiB8fCAhdGhpcy5jdWJlLmdyb3VwKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgfVxyXG4gICB0aGlzLmN1YmUuZ3JvdXAuZGlzcGxheUNvbm5lY3Rpb24odGhpcy5jdWJlLm15Q29ubmVjdGlvbik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNvbGFyUGFuZWxPblJlbW92ZSgpIHtcclxuICAgaWYgKCF0aGlzLmN1YmUubXlDb25uZWN0aW9uIHx8ICF0aGlzLmN1YmUubXlDb25uZWN0aW9uLmVuZCkge1xyXG4gICAgICBjb25zb2xlLmxvZygnc29sYXJQYW5lbE9uUmVtb3ZlKCkgaGFkIGFuIGVycm9yJyk7XHJcbiAgIH1cclxuICAgdGhpcy5jdWJlLm15Q29ubmVjdGlvbi5lbmQubXlDb25uZWN0aW9uID0gdW5kZWZpbmVkO1xyXG4gICB0aGlzLmN1YmUubXlDb25uZWN0aW9uID0gdW5kZWZpbmVkO1xyXG59XHJcblxyXG5mdW5jdGlvbiBiZWdpblRocnVzdCgpIHtcclxuICAgdGhpcy50aHJ1c3QgPSB0cnVlO1xyXG4gICB0aGlzLmN1YmUuZnJhbWUgPSAxO1xyXG59XHJcblxyXG5mdW5jdGlvbiBlbmRUaHJ1c3QoKSB7XHJcbiAgIHRoaXMudGhydXN0ID0gZmFsc2U7XHJcbiAgIHRoaXMuY3ViZS5mcmFtZSA9IDA7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHRocnVzdGVyVXBkYXRlKCkge1xyXG4gICAvLyBjb25zb2xlLmxvZyh0aGlzLnRocnVzdCk7XHJcbiAgIGlmICh0aGlzLnRocnVzdCAmJiB0aGlzLmN1YmUubXlDb25uZWN0aW9uKSB7XHJcbiAgICAgIHRoaXMuY3ViZS5ib2R5LmZvcmNlLnggPSB0aHJ1c3RBbXQgKiBNYXRoLmNvcyh0aGlzLmN1YmUucm90YXRpb24gLSBNYXRoLlBJIC8gMik7XHJcbiAgICAgIHRoaXMuY3ViZS5ib2R5LmZvcmNlLnkgPSB0aHJ1c3RBbXQgKiBNYXRoLnNpbih0aGlzLmN1YmUucm90YXRpb24gLSBNYXRoLlBJIC8gMik7XHJcblx0ICBpZih0aGlzLmN1YmUuZnJhbWUgPT09IDEpIHtcclxuXHRcdHRoaXMuY3ViZS5mcmFtZSA9IDI7XHJcblx0ICB9XHJcblx0ICBlbHNlIHtcclxuXHRcdHRoaXMuY3ViZS5mcmFtZSA9IDE7XHJcblx0ICB9XHJcbiAgIH1cclxufVxyXG5cclxuLyoqIEVuZCBtb2R1bGUgZnVuY3Rpb25zICoqL1xyXG5cclxuLy9jYWxsIHRoaXMgZnVuY3Rpb24gZnJvbSBNb2R1bGVCdWlsZGVyIHRvIGNvbnN0cnVjdCBtb2R1bGVzXHJcbi8vVFlQRVM6ICdjb3JlJyAnc2hpZWxkJyAndGhydXN0ZXInICdzb2xhclBhbmVsJyAnZ3VuJ1xyXG5Nb2R1bGVCdWlsZGVyLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uKHR5cGUsIHgsIHksIGZvclBsYXllcikge1xyXG5cdC8vQ3JlYXRlIGN1YmUgb2JqZWN0IHRvIGJlIHN0b3JlZCB3aXRoaW4gbW9kdWxlXHJcblx0Ly9TcHJpdGUgbmFtZXMgZm9yIG1vZHVsZXMgYXJlIGRpcmVjdGx5IG1hcHBlZCB0byBtb2R1bGUgbmFtZXMsIHNvIGp1c3QgcGFzcyAndHlwZScgYXMgc3ByaXRlIG5hbWVcclxuXHR2YXIgbmV3Q3ViZSA9IG5ldyBDdWJlKHRoaXMuZ2FtZVN0YXRlLmdhbWUsIHgsIHksIHR5cGUpO1xyXG4gICAgdmFyIHNjYWxlID0gMC41O1xyXG4gICAgbmV3Q3ViZS5uYW1lID0gdGhpcy5nYW1lU3RhdGUuZGVidWdOdW0rKztcclxuICAgIG5ld0N1YmUuc2NhbGUuc2V0VG8oc2NhbGUsIHNjYWxlKTtcclxuICAgIG5ld0N1YmUuYW5jaG9yLnNldFRvKDAuNSwgMC41KTtcclxuICAgIHRoaXMuZ2FtZVN0YXRlLmdhbWUucGh5c2ljcy5wMi5lbmFibGUobmV3Q3ViZSk7XHJcbiAgICBuZXdDdWJlLmJvZHkub25CZWdpbkNvbnRhY3QuYWRkKG5ld0N1YmUuY3ViZUNvbGxpZGUsIG5ld0N1YmUpO1xyXG5cdG5ld0N1YmUuYm9keS5jb2xsaWRlV29ybGRCb3VuZHMgPSBmYWxzZTtcclxuICAgIG5ld0N1YmUuYm9keS5kYW1waW5nID0gMC45O1xyXG4gICAgbmV3Q3ViZS5ib2R5LmFuZ3VsYXJEYW1waW5nID0gMC45O1xyXG4gICAgaWYgKCF0aGlzLmdhbWVTdGF0ZS5yb290U3Bhd25lZCkge1xyXG4gICAgICAgbmV3Q3ViZS5yb290ID0gdHJ1ZTtcclxuICAgICAgIHRoaXMuZ2FtZVN0YXRlLnJvb3RTcGF3bmVkID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgIHZhciBjSW5kaWNhdG9yID0gdGhpcy5nYW1lU3RhdGUuYWRkLnNwcml0ZSgwLCAwLCAnY29ubmVjdGlvbnMnLCAnY29ubmVjdGlvbl9saW5lLnBuZycpO1xyXG4gICBjSW5kaWNhdG9yLmFuY2hvci5zZXRUbygwLjUsIDAuNSk7XHJcbiAgIGNJbmRpY2F0b3IuYW5pbWF0aW9ucy5hZGQoJ2VuZCcsIFsnY29ubmVjdGlvbl9lbmQucG5nJ10sIDYwLCB0cnVlKTtcclxuICAgY0luZGljYXRvci5hbmltYXRpb25zLmFkZCgnbGluZScsIFsnY29ubmVjdGlvbl9saW5lLnBuZyddLCA2MCwgdHJ1ZSk7XHJcbiAgIGNJbmRpY2F0b3IuYW5pbWF0aW9ucy5hZGQoJ3JpZ2h0JywgWydjb25uZWN0aW9uX3JpZ2h0LnBuZyddLCA2MCwgdHJ1ZSk7XHJcbiAgIG5ld0N1YmUuYWRkQ2hpbGQoY0luZGljYXRvcik7XHJcbiAgIG5ld0N1YmUuY0luZGljYXRvciA9IGNJbmRpY2F0b3I7XHJcbiAgIGNJbmRpY2F0b3IuYWxwaGEgPSAwO1xyXG5cdFxyXG5cdC8vQ3JlYXRlIG1vZHVsZSB0byB3cmFwIGFyb3VuZCBjdWJlIGNsYXNzXHJcblx0dmFyIG5ld01vZHVsZSA9IG5ldyBNb2R1bGUobmV3Q3ViZSwgdHlwZSk7XHJcblx0XHRcclxuXHQvL1RPRE86IGVkaXQgc3BlY2lhbCBtb2R1bGUgYXR0cmlidXRlcyBiYXNlZCBvbiAndHlwZSd6XHJcblx0XHJcblx0Ly9TdG9yZSBtb2R1bGUgaWYgaXQgaXMgY29yZVxyXG5cdGlmKHR5cGUgPT09ICdjb3JlJylcclxuXHR7XHJcblx0XHRuZXdNb2R1bGUuY3ViZS5hbmltYXRpb25zLmFkZCgnY29yZScsIFswLDEsMl0sIDIwLCB0cnVlKTtcclxuXHRcdG5ld01vZHVsZS5jdWJlLmFuaW1hdGlvbnMucGxheSgnY29yZScpO1xyXG5cdFx0dGhpcy5jb3JlID0gbmV3TW9kdWxlO1xyXG5cdFx0dGhpcy5jb3JlRXhpc3RzID0gdHJ1ZTtcclxuXHR9XHJcbiAgIC8vIHNvbGFyIHBhbmVsIHRlc3RpbmdcclxuICAgaWYgKHR5cGUgPT09ICdzb2xhclBhbmVsJykge1xyXG4gICAgICBuZXdNb2R1bGUuZ2l2ZVRhcmdldCA9IHNvbGFyUGFuZWxHaXZlVGFyZ2V0O1xyXG4gICAgICBuZXdNb2R1bGUubW91c2VPdmVyID0gc29sYXJQYW5lbE1vdXNlT3ZlcjtcclxuICAgICAgbmV3TW9kdWxlLm9uUmVtb3ZlID0gc29sYXJQYW5lbE9uUmVtb3ZlO1xyXG4gICB9XHJcbiAgIFxyXG4gICAvL1RocnVzdGVyIG1vZHVsZSBldmVudHNcclxuXHRpZih0eXBlID09PSAndGhydXN0ZXInKSB7XHJcbiAgICAgIGlmIChmb3JQbGF5ZXIpIHtcclxuICAgICAgICAgdmFyIHNwYWNlID0gdGhpcy5nYW1lU3RhdGUuaW5wdXQua2V5Ym9hcmQuYWRkS2V5KFBoYXNlci5LZXlib2FyZC5TUEFDRUJBUik7IFxyXG4gICAgICAgICB0aGlzLmdhbWVTdGF0ZS5pbnB1dC5rZXlib2FyZC5hZGRLZXlDYXB0dXJlKFtzcGFjZV0pO1xyXG4gICAgICAgICAvLyBzcGFjZS5vbkRvd24uYWRkKGFwcGx5VGhydXN0LCBuZXdNb2R1bGUpO1xyXG4gICAgICAgICBzcGFjZS5vbkRvd24uYWRkKGJlZ2luVGhydXN0LCBuZXdNb2R1bGUpO1xyXG4gICAgICAgICBzcGFjZS5vblVwLmFkZChlbmRUaHJ1c3QsIG5ld01vZHVsZSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgIC8vIG5ld01vZHVsZS50aHJ1c3QgPSBmYWxzZTtcclxuICAgICAgICAgbmV3TW9kdWxlLmJlZ2luVGhydXN0ID0gYmVnaW5UaHJ1c3Q7XHJcbiAgICAgICAgIG5ld01vZHVsZS5lbmRUaHJ1c3QgPSBlbmRUaHJ1c3Q7XHJcbiAgICAgIH1cclxuICAgICAgbmV3TW9kdWxlLnVwZGF0ZSA9IHRocnVzdGVyVXBkYXRlO1xyXG5cdH1cclxuXHQvL1JldHVybiB0aGUgbW9kdWxlIG9iamVjdFxyXG5cdHJldHVybiBuZXdNb2R1bGU7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE1vZHVsZUJ1aWxkZXI7XHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbiIsIi8qXHJcbkRlZmluZXMgYSBjdWJlLlxyXG4qL1xyXG5cclxudmFyIEN1YmUgPSBmdW5jdGlvbiAoZ2FtZSwgeCwgeSwgc3ByaXRlKSB7XHJcbiAgICBQaGFzZXIuU3ByaXRlLmNhbGwodGhpcywgZ2FtZSwgeCwgeSwgc3ByaXRlKTtcclxuICAgIHRoaXMuZ2FtZSA9IGdhbWU7XHJcbiAgICB0aGlzLmdhbWUuYWRkLmV4aXN0aW5nKHRoaXMpO1xyXG4gICAgdGhpcy5ncm91cCA9IHVuZGVmaW5lZDtcclxuICAgIHRoaXMubW9kdWxlID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5pbmRpY2F0b3JGYWRlID0gMC4wMjtcclxuICAgIHRoaXMuaGVhbHRoID0gMztcclxuICAgIHRoaXMuY29uc3RyYWludHMgPSBbXTtcclxuICAgLy8gdGhpcy5yYW1Db29sZG93biA9IDUwMDtcclxuICAgLy8gdGhpcy5yYW1EZWxheSA9IDA7XHJcbn07XHJcblxyXG5DdWJlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUGhhc2VyLlNwcml0ZS5wcm90b3R5cGUpO1xyXG5DdWJlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEN1YmU7XHJcblxyXG4vKipcclxuICogQXV0b21hdGljYWxseSBjYWxsZWQgYnkgV29ybGQudXBkYXRlXHJcbiAqL1xyXG5DdWJlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpIHtcclxuICAgaWYgKHRoaXMuY0luZGljYXRvciAmJiB0aGlzLmNJbmRpY2F0b3IuYWxwaGEgPiAwKSB7XHJcbiAgICAgIHRoaXMuY0luZGljYXRvci5hbHBoYSAtPSB0aGlzLmluZGljYXRvckZhZGU7XHJcbiAgIH1cclxuICAgaWYgKHRoaXMubW9kdWxlLnVwZGF0ZSkge1xyXG4gICAgICB0aGlzLm1vZHVsZS51cGRhdGUoKTtcclxuICAgfVxyXG4gICAvLyBpZiAodGhpcy5yYW1EZWxheSA+IDApIHtcclxuICAgICAgLy8gdGhpcy5yYW1EZWxheSAtPSB0aGlzLmdhbWUudGltZS5lbGFwc2VkO1xyXG4gICAvLyB9XHJcbn07XHJcblxyXG4vLyBDdWJlLnByb3RvdHlwZS5yZXNldFJhbURlbGF5ID0gZnVuY3Rpb24oKSB7XHJcbiAgLy8gdGhpcy5yYW1EZWxheSA9IHRoaXMucmFtQ29vbGRvd247IFxyXG4vLyB9O1xyXG5cclxuQ3ViZS5wcm90b3R5cGUuY3ViZUNvbGxpZGUgPSBmdW5jdGlvbihvdGhlcikge1xyXG4gICBpZiAoIXRoaXMuZ3JvdXAgfHwgIW90aGVyIHx8ICFvdGhlci5zcHJpdGUgfHwgb3RoZXIuc3ByaXRlLmtleSA9PT0gJ2FzdGVyb2lkJykge1xyXG4gICAgICByZXR1cm47XHJcbiAgIH1cclxuXHR0aGlzLmdyb3VwLmhhbmRsZUNvbGxpc2lvbih0aGlzLCBvdGhlci5zcHJpdGUpO1xyXG5cdHRoaXMuZ3JvdXAuY291bnRDdWJlcygpO1xyXG59O1xyXG5cclxuQ3ViZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuICAgdmFyIHN0cmluZyA9ICcnO1xyXG4gICBzdHJpbmcgKz0gdGhpcy5jb25jYXQoJ25hbWUnLCB0aGlzLm5hbWUpO1xyXG4gICByZXR1cm4gc3RyaW5nO1xyXG59O1xyXG5cclxuQ3ViZS5wcm90b3R5cGUuY29uY2F0ID0gZnVuY3Rpb24oc3RyaW5nLCB2YWwpIHtcclxuICAgcmV0dXJuIHN0cmluZyArICc6ICcgKyB2YWwgKyAnXFxuJztcclxufTtcclxuQ3ViZS5wcm90b3R5cGUuZGlzcGxheUluZGljYXRvciA9IGZ1bmN0aW9uKCkge1xyXG4gIHRoaXMuY0luZGljYXRvci5hbHBoYSA9IDE7IFxyXG59O1xyXG5cclxuQ3ViZS5wcm90b3R5cGUudGFrZURhbWFnZSA9IGZ1bmN0aW9uKGFtdCkge1xyXG4gICB0aGlzLmhlYWx0aCAtPSBhbXQ7XHJcbiAgIGlmICh0aGlzLmhlYWx0aCA8PSAwKSB7XHJcbiAgICAgIHRoaXMuZ3JvdXAuZGVzdHJveUN1YmUodGhpcyk7XHJcblx0ICAvLyB0aGlzLmdyb3VwLmNvdW50Q3ViZXMoKTtcclxuICAgfVxyXG59O1xyXG5cclxuQ3ViZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oKSB7XHJcbiAgIGlmICghdGhpcy5ncm91cCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgIH1cclxuICAgdGhpcy5ncm91cC5yZW1vdmUodGhpcyk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEN1YmU7XHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuIiwidmFyIEFzdGFyID0gcmVxdWlyZSgnLi4vbGlicy9qYXZhc2NyaXB0LWFzdGFyL2FzdGFyJyk7XHJcbnZhciBFbmVteUFJID0gcmVxdWlyZSgnLi9lbmVteV9haScpO1xyXG5cclxuLypcclxuRGVmaW5lcyBhIGN1YmUgZ3JvdXAuXHJcbiovXHJcblxyXG52YXIgQ3ViZUdyb3VwID0gZnVuY3Rpb24gKGdhbWUsIHJvb3QpIHtcclxuICAgdGhpcy5nYW1lID0gZ2FtZTtcclxuICAgdGhpcy5yb290ID0gcm9vdDtcclxuICAgdGhpcy5jdWJlcyA9IFtdO1xyXG4gICB2YXIgY29sID0gW107XHJcbiAgIGNvbC5wdXNoKHRoaXMucm9vdCk7XHJcbiAgIHRoaXMuY3ViZXMucHVzaChjb2wpO1xyXG4gICBpZiAodGhpcy5yb290KSB7XHJcbiAgICAgIHRoaXMucm9vdC5ncm91cCA9IHRoaXM7XHJcbiAgIH1cclxuICAgdGhpcy5ESVIgPSB7Tk9SVEg6IDAsIEVBU1Q6IDEsIFNPVVRIOiAyLCBXRVNUOiAzfTtcclxuICAgdGhpcy5vZmZzZXQgPSAyO1xyXG4gICB0aGlzLm51bUN1YmVzID0gMTtcclxuICAgdGhpcy5ib3VuY2VCYWNrRm9yY2UgPSAzMDtcclxuICAgdGhpcy5taW5SYW1WZWwgPSAxMDA7XHJcbn07XHJcblxyXG5DdWJlR3JvdXAucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ3ViZUdyb3VwO1xyXG5cclxuLyoqXHJcbiAqIEF1dG9tYXRpY2FsbHkgY2FsbGVkIGJ5IFdvcmxkLnVwZGF0ZVxyXG4gKi9cclxuQ3ViZUdyb3VwLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpIHtcclxuICAgaWYgKHRoaXMuQUkpIHtcclxuICAgICAgdGhpcy5BSS51cGRhdGUoKTtcclxuICAgfVxyXG59O1xyXG5cclxuQ3ViZUdyb3VwLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24oZnVuKSB7XHJcbiAgIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IHRoaXMuY3ViZXNXaWR0aCgpOyByb3crKykge1xyXG4gICAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCB0aGlzLmN1YmVzSGVpZ2h0KCk7IGNvbCsrKSB7XHJcbiAgICAgICAgIHZhciBjdWJlID0gdGhpcy5jdWJlc1tyb3ddW2NvbF07XHJcbiAgICAgICAgIGlmIChjdWJlICYmIGN1YmUuaGFzT3duUHJvcGVydHkoZnVuKSkge1xyXG4gICAgICAgICAgICAvLyBpZiBjdWJlcyBuZWVkIGZ1bmN0aW9ucyBjYWxsZWRcclxuICAgICAgICAgfSBlbHNlIGlmIChjdWJlICYmIGN1YmUubW9kdWxlICYmIGN1YmUubW9kdWxlLmhhc093blByb3BlcnR5KGZ1bikpIHtcclxuICAgICAgICAgICAgdmFyIGZuID0gY3ViZS5tb2R1bGVbZnVuXTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICBmbi5jYWxsKGN1YmUubW9kdWxlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgfVxyXG59O1xyXG5cclxuQ3ViZUdyb3VwLnByb3RvdHlwZS5naXZlQUkgPSBmdW5jdGlvbih0eXBlLCBwbGF5ZXIpIHtcclxuICAgdGhpcy5BSSA9IG5ldyBFbmVteUFJKHRoaXMuZ2FtZSwgdGhpcywgdHlwZSwgcGxheWVyKTtcclxufTtcclxuXHJcbkN1YmVHcm91cC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oY3ViZSwgcG9pbnQpIHtcclxuICBpZiAoIXRoaXMucm9vdCAmJiBjdWJlLm1vZHVsZS50eXBlID09PSAnY29yZScpIHtcclxuICAgICB0aGlzLnJvb3QgPSBjdWJlO1xyXG4gIH1cclxuICBjdWJlLmdyb3VwID0gdGhpcztcclxuICB0aGlzLnNldChjdWJlLCBwb2ludCk7XHJcbiAgdGhpcy5jcmVhdGVDb25zdHJhaW50cyhjdWJlLCBwb2ludCk7XHJcbiAgLy8gdGhpcy5kaXNwbGF5Q3ViZXMoKTtcclxufTtcclxuXHJcbkN1YmVHcm91cC5wcm90b3R5cGUuaGFuZGxlQ29sbGlzaW9uID0gZnVuY3Rpb24ob3JpZ2luLCBvdGhlcikge1xyXG4gICAvLyBzdG9wIGlmIG90aGVyIGRvZXMgbm90IGV4aXN0LCBlaXRoZXIgaXMgbm90IGEgY3ViZSwgYm90aCBhcmUgaW4gc2FtZSBncm91cFxyXG4gICBpZiAob3RoZXIgPT09IG51bGwgfHwgb3JpZ2luLnByb3RvdHlwZSAhPT0gb3RoZXIucHJvdG90eXBlKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgfVxyXG4gICAvLyBpZiAob3RoZXIuZ3JvdXAgJiYgb3RoZXIuZ3JvdXAgIT09IHRoaXMgJiYgb3JpZ2luLnJhbURlbGF5IDw9IDApIHtcclxuICAgdmFyIHN1bVZlbCA9IE1hdGguYWJzKG9yaWdpbi5ib2R5LnZlbG9jaXR5LngpICsgTWF0aC5hYnMob3JpZ2luLmJvZHkudmVsb2NpdHkueSk7XHJcbiAgIGlmIChvdGhlci5ncm91cCAmJiBvdGhlci5ncm91cCAhPT0gdGhpcyAmJiBzdW1WZWwgPj0gdGhpcy5taW5SYW1WZWwpIHtcclxuICAgICAgY29uc29sZS5sb2cob3JpZ2luLmJvZHkudmVsb2NpdHkueCwgb3JpZ2luLmJvZHkudmVsb2NpdHkueSwgc3VtVmVsKTtcclxuICAgICAgLy8gY29uc29sZS5sb2cob3JpZ2luLm5hbWUsICdyYW1taW5nIGRhbWFnZSEnKTtcclxuICAgICAgb3RoZXIudGFrZURhbWFnZSgzKTtcclxuICAgICAgLy8gb3JpZ2luLnJlc2V0UmFtRGVsYXkoKTtcclxuICAgfSBlbHNlIGlmICghb3RoZXIuZ3JvdXAgJiYgdGhpcy5pc1BsYXllcikge1xyXG4gICAgICB2YXIgcmVsU2lkZSA9IHRoaXMucmVsYXRpdmVTaWRlKG9yaWdpbi5ib2R5LCBvdGhlci5ib2R5KTtcclxuICAgICAgdmFyIG9yaWdpbkxvYyA9IHRoaXMuZmluZChvcmlnaW4pO1xyXG4gICAgICB2YXIgb3RoZXJMb2MgPSB0aGlzLmFkanVzdChvcmlnaW5Mb2MsIHJlbFNpZGUpO1xyXG4gICAgICB0aGlzLnNldChvdGhlciwgb3RoZXJMb2MpO1xyXG4gICAgICBvdGhlckxvYyA9IHRoaXMuZmluZChvdGhlcik7IC8vIHVwZGF0ZSBwb3NpdGlvbiBzaW5jZSBzZXQgY2FuIHNoaWZ0IGdyaWRcclxuICAgICAgaWYgKCFvdGhlckxvYykge1xyXG4gICAgICAgICAvLyBjb25zb2xlLmxvZygnaGFuZGxlIGNvbGxpc2lvbiBmYWlsZWQgdG8gZmluZCBwb3NpdGlvbiBmb3IgZ29vZCBhcHBsaWNhbnQnKTtcclxuICAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuY3JlYXRlQ29uc3RyYWludHMob3RoZXIsIG90aGVyTG9jKTtcclxuICAgICAgLy8gY29uc29sZS5sb2cob3RoZXIuYm9keS5jb2xsaWRlc1dpdGgpO1xyXG4gICAgICAvLyB0aGlzLmRpc3BsYXlDdWJlcygpO1xyXG4gICB9XHJcbn07XHJcblxyXG5DdWJlR3JvdXAucHJvdG90eXBlLmNyZWF0ZUNvbnN0cmFpbnRzID0gZnVuY3Rpb24obWUsIHBvaW50KSB7XHJcbiAgIC8vIHRoaXMuZGlzcGxheUN1YmVzKCk7XHJcbiAgIHZhciBteU5vcnRoID0gdGhpcy5nZXQodGhpcy5hZGp1c3QocG9pbnQsIHRoaXMuRElSLk5PUlRIKSk7XHJcbiAgIHZhciBteUVhc3QgPSB0aGlzLmdldCh0aGlzLmFkanVzdChwb2ludCwgdGhpcy5ESVIuRUFTVCkpO1xyXG4gICB2YXIgbXlTb3V0aCA9IHRoaXMuZ2V0KHRoaXMuYWRqdXN0KHBvaW50LCB0aGlzLkRJUi5TT1VUSCkpO1xyXG4gICB2YXIgbXlXZXN0ID0gdGhpcy5nZXQodGhpcy5hZGp1c3QocG9pbnQsIHRoaXMuRElSLldFU1QpKTtcclxuICAgdmFyIGNvbnN0cmFpbnQ7XHJcbiAgIGlmIChteU5vcnRoKSB7XHJcbiAgICAgIGNvbnN0cmFpbnQgPSB0aGlzLmdhbWUucGh5c2ljcy5wMi5jcmVhdGVMb2NrQ29uc3RyYWludChtZS5ib2R5LCBteU5vcnRoLmJvZHksIFswLCBtZS53aWR0aCArIHRoaXMub2Zmc2V0XSk7IC8vIG1lIC0gbm9ydGhcclxuICAgICAgbWUuY29uc3RyYWludHMucHVzaChjb25zdHJhaW50KTtcclxuICAgICAgbXlOb3J0aC5jb25zdHJhaW50cy5wdXNoKGNvbnN0cmFpbnQpO1xyXG4gICB9XHJcbiAgIGlmIChteUVhc3QpIHtcclxuICAgICAgY29uc3RyYWludCA9IHRoaXMuZ2FtZS5waHlzaWNzLnAyLmNyZWF0ZUxvY2tDb25zdHJhaW50KG1lLmJvZHksIG15RWFzdC5ib2R5LCBbLW1lLndpZHRoIC0gdGhpcy5vZmZzZXQsIDBdKTsgLy8gbWUgLSBlYXN0XHJcbiAgICAgIG1lLmNvbnN0cmFpbnRzLnB1c2goY29uc3RyYWludCk7XHJcbiAgICAgIG15RWFzdC5jb25zdHJhaW50cy5wdXNoKGNvbnN0cmFpbnQpO1xyXG4gICB9XHJcbiAgIGlmIChteVNvdXRoKSB7XHJcbiAgICAgIGNvbnN0cmFpbnQgPSB0aGlzLmdhbWUucGh5c2ljcy5wMi5jcmVhdGVMb2NrQ29uc3RyYWludChteVNvdXRoLmJvZHksIG1lLmJvZHksIFswLCBtZS53aWR0aCArIHRoaXMub2Zmc2V0XSk7IC8vIHNvdXRoIC0gbWVcclxuICAgICAgbWUuY29uc3RyYWludHMucHVzaChjb25zdHJhaW50KTtcclxuICAgICAgbXlTb3V0aC5jb25zdHJhaW50cy5wdXNoKGNvbnN0cmFpbnQpO1xyXG4gICB9XHJcbiAgIGlmIChteVdlc3QpIHtcclxuICAgICAgY29uc3RyYWludCA9IHRoaXMuZ2FtZS5waHlzaWNzLnAyLmNyZWF0ZUxvY2tDb25zdHJhaW50KG15V2VzdC5ib2R5LCBtZS5ib2R5LCBbLW1lLndpZHRoIC0gdGhpcy5vZmZzZXQsIDBdKTsgLy8gd2VzdCAtIG1lXHJcbiAgICAgIG1lLmNvbnN0cmFpbnRzLnB1c2goY29uc3RyYWludCk7XHJcbiAgICAgIG15V2VzdC5jb25zdHJhaW50cy5wdXNoKGNvbnN0cmFpbnQpO1xyXG4gICB9XHJcbn07XHJcblxyXG5DdWJlR3JvdXAucHJvdG90eXBlLnJlbGF0aXZlU2lkZSA9IGZ1bmN0aW9uKHRoaXNCb2R5LCBvdGhlckJvZHkpIHtcclxuICB2YXIgdGhpc1BvaW50ID0gbmV3IFBoYXNlci5Qb2ludCh0aGlzQm9keS54LCB0aGlzQm9keS55KTtcclxuICB2YXIgb3RoZXJQb2ludCA9IG5ldyBQaGFzZXIuUG9pbnQob3RoZXJCb2R5LngsIG90aGVyQm9keS55KTtcclxuICB2YXIgYW5nbGVUb090aGVyID0gUGhhc2VyLlBvaW50LmFuZ2xlKHRoaXNQb2ludCwgb3RoZXJQb2ludCk7XHJcbiAgaWYgKGFuZ2xlVG9PdGhlciA8IDApIHsgLy8gZml4IGR1bWIgcGFydCBvZiBQaGFzZXIuUG9pbnQuYW5nbGUoKVxyXG4gICAgIGFuZ2xlVG9PdGhlciA9IDIgKiBNYXRoLlBJICsgYW5nbGVUb090aGVyO1xyXG4gIH1cclxuICBhbmdsZVRvT3RoZXIgPSAoYW5nbGVUb090aGVyICsgMy8yICogTWF0aC5QSSkgJSAoMiAqIE1hdGguUEkpOyAvLyByb3RhdGUgOTAgZCBjbG9ja3dpc2VcclxuICB2YXIgZGlmZkFuZ2xlID0gTWF0aC5hYnMoTWF0aC5hYnMoYW5nbGVUb090aGVyKSAtIE1hdGguYWJzKHRoaXNCb2R5LnJvdGF0aW9uKSk7XHJcbiAgIGlmIChkaWZmQW5nbGUgPCAxIC8gNCAqIE1hdGguUEkgfHwgZGlmZkFuZ2xlID4gNyAvIDQgKiBNYXRoLlBJKSB7IC8vIG5vcnRoXHJcbiAgICAgcmV0dXJuIHRoaXMuRElSLk5PUlRIO1xyXG4gIH0gZWxzZSBpZiAoZGlmZkFuZ2xlID49IDEgLyA0ICogTWF0aC5QSSAmJiBkaWZmQW5nbGUgPCAzIC8gNCAqIE1hdGguUEkpIHsgLy8gZWFzdFxyXG4gICAgIHJldHVybiB0aGlzLkRJUi5FQVNUO1xyXG4gIH0gZWxzZSBpZiAoZGlmZkFuZ2xlID49IDMgLyA0ICogTWF0aC5QSSAmJiBkaWZmQW5nbGUgPCA1IC8gNCAqIE1hdGguUEkpIHsgLy8gc291dGhcclxuICAgICByZXR1cm4gdGhpcy5ESVIuU09VVEg7XHJcbiAgfSBlbHNlIGlmIChkaWZmQW5nbGUgPj0gNSAvIDQgKiBNYXRoLlBJICYmIGRpZmZBbmdsZSA8IDcgLyA0ICogTWF0aC5QSSkgeyAvLyB3ZXN0XHJcbiAgICAgcmV0dXJuIHRoaXMuRElSLldFU1Q7XHJcbiAgfVxyXG59O1xyXG5cclxuQ3ViZUdyb3VwLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24oY3ViZSkge1xyXG4gICBmb3IgKHZhciByb3cgPSAwOyByb3cgPCB0aGlzLmN1YmVzV2lkdGgoKTsgcm93KyspIHtcclxuICAgICAgZm9yICh2YXIgY29sID0gMDsgY29sIDwgdGhpcy5jdWJlc0hlaWdodCgpOyBjb2wrKykge1xyXG4gICAgICAgICBpZiAodGhpcy5jdWJlc1tyb3ddW2NvbF0gPT09IGN1YmUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQaGFzZXIuUG9pbnQocm93LCBjb2wpO1xyXG4gICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgfVxyXG4gICByZXR1cm4gdW5kZWZpbmVkO1xyXG59O1xyXG5cclxuQ3ViZUdyb3VwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihwb2ludCkge1xyXG4gIGlmICghcG9pbnQgfHwgdGhpcy5vdXRPZkJvdW5kcyhwb2ludCkpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gIH1cclxuICByZXR1cm4gdGhpcy5jdWJlc1twb2ludC54XVtwb2ludC55XTtcclxufTtcclxuXHJcbkN1YmVHcm91cC5wcm90b3R5cGUuY3ViZXNXaWR0aCA9IGZ1bmN0aW9uKCkge1xyXG4gICByZXR1cm4gdGhpcy5jdWJlcy5sZW5ndGg7XHJcbn07XHJcblxyXG5DdWJlR3JvdXAucHJvdG90eXBlLmN1YmVzSGVpZ2h0ID0gZnVuY3Rpb24oKSB7XHJcbiAgIHJldHVybiB0aGlzLmN1YmVzWzBdLmxlbmd0aDtcclxufTtcclxuXHJcbkN1YmVHcm91cC5wcm90b3R5cGUuYWRkVG9wUm93ID0gZnVuY3Rpb24oKSB7XHJcbiAgIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IHRoaXMuY3ViZXNXaWR0aCgpOyByb3crKykge1xyXG4gICAgICB0aGlzLmN1YmVzW3Jvd10ucHVzaCh1bmRlZmluZWQpO1xyXG4gICB9XHJcbn07XHJcblxyXG5DdWJlR3JvdXAucHJvdG90eXBlLmFkZFJpZ2h0Q29sID0gZnVuY3Rpb24oKSB7XHJcbiAgIHZhciBuZXdDb2wgPSBbXTtcclxuICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmN1YmVzSGVpZ2h0KCk7IGkrKykge1xyXG4gICAgICBuZXdDb2wucHVzaCh1bmRlZmluZWQpO1xyXG4gICB9XHJcbiAgIHRoaXMuY3ViZXMucHVzaChuZXdDb2wpO1xyXG59O1xyXG5cclxuQ3ViZUdyb3VwLnByb3RvdHlwZS5hZGRCb3RSb3cgPSBmdW5jdGlvbigpIHtcclxuICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgdGhpcy5jdWJlc1dpZHRoKCk7IHJvdysrKSB7XHJcbiAgICAgIHRoaXMuY3ViZXNbcm93XS51bnNoaWZ0KHVuZGVmaW5lZCk7XHJcbiAgIH1cclxufTtcclxuXHJcbkN1YmVHcm91cC5wcm90b3R5cGUuYWRkTGVmdENvbCA9IGZ1bmN0aW9uKCkge1xyXG4gICB2YXIgbmV3Q29sID0gbmV3IEFycmF5KHRoaXMuY3ViZXNIZWlnaHQoKSk7XHJcbiAgIHRoaXMuY3ViZXMudW5zaGlmdChuZXdDb2wpO1xyXG59O1xyXG5cclxuQ3ViZUdyb3VwLnByb3RvdHlwZS5nZXRDdWJlID0gZnVuY3Rpb24ocG9pbnQpIHtcclxuICAgaWYgKCFwb2ludCB8fCB0aGlzLm91dE9mQm91bmRzKHBvaW50KSkge1xyXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICB9XHJcbiAgIHJldHVybiB0aGlzLmN1YmVzW3BvaW50LnhdW3BvaW50LnldO1xyXG59O1xyXG5cclxuQ3ViZUdyb3VwLnByb3RvdHlwZS5hZGp1c3QgPSBmdW5jdGlvbihwb2ludCwgZGlyKSB7XHJcbiAgaWYgKCFwb2ludCkge1xyXG4gICAgIHJldHVybjtcclxuICB9XHJcbiAgdmFyIG5ld1BvaW50ID0gbmV3IFBoYXNlci5Qb2ludChwb2ludC54LCBwb2ludC55KTtcclxuICBzd2l0Y2ggKGRpcikge1xyXG4gICAgICBjYXNlIHRoaXMuRElSLk5PUlRIOlxyXG4gICAgICBuZXdQb2ludC55Kys7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIHRoaXMuRElSLkVBU1Q6XHJcbiAgICAgIG5ld1BvaW50LngrKztcclxuICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgdGhpcy5ESVIuU09VVEg6XHJcbiAgICAgIG5ld1BvaW50LnktLTtcclxuICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgdGhpcy5ESVIuV0VTVDpcclxuICAgICAgbmV3UG9pbnQueC0tO1xyXG4gICAgICBicmVhaztcclxuICAgfVxyXG4gICByZXR1cm4gbmV3UG9pbnQ7XHJcbn07XHJcblxyXG5DdWJlR3JvdXAucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKGN1YmUsIHBvaW50KSB7XHJcbiAgIGlmICghcG9pbnQpIHtcclxuICAgICAgY29uc29sZS5sb2coJ3NldCBnaXZlbiB1bmRlZmluZWQgcG9pbnQnKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICB9XHJcbiAgIGlmIChwb2ludC54IDwgMCkge1xyXG4gICAgICB0aGlzLmFkZExlZnRDb2woKTtcclxuICAgICAgcG9pbnQueCA9IDA7XHJcbiAgIH0gZWxzZSBpZiAocG9pbnQueCA+PSB0aGlzLmN1YmVzV2lkdGgoKSkge1xyXG4gICAgICB0aGlzLmFkZFJpZ2h0Q29sKCk7XHJcbiAgICAgIHBvaW50LnggPSB0aGlzLmN1YmVzV2lkdGgoKSAtIDE7XHJcbiAgIH0gZWxzZSBpZiAocG9pbnQueSA8IDApIHtcclxuICAgICAgdGhpcy5hZGRCb3RSb3coKTtcclxuICAgICAgcG9pbnQueSA9IDA7XHJcbiAgIH0gZWxzZSBpZiAocG9pbnQueSA+PSB0aGlzLmN1YmVzSGVpZ2h0KCkpIHtcclxuICAgICAgdGhpcy5hZGRUb3BSb3coKTtcclxuICAgICAgcG9pbnQueSA9IHRoaXMuY3ViZXNIZWlnaHQoKSAtIDE7XHJcbiAgIH1cclxuICAgaWYgKHRoaXMuZ2V0KHBvaW50KSkge1xyXG4gICAgICAvLyBjb25zb2xlLmxvZygndHJpZWQgdG8gc2V0IHRvIGZpbGxlZCBwb3NpdGlvbicpO1xyXG4gICAgICByZXR1cm47XHJcbiAgIH1cclxuICAgdGhpcy5jdWJlc1twb2ludC54XVtwb2ludC55XSA9IGN1YmU7XHJcbiAgIGN1YmUuZ3JvdXAgPSB0aGlzO1xyXG59O1xyXG5cclxuQ3ViZUdyb3VwLnByb3RvdHlwZS5vdXRPZkJvdW5kcyA9IGZ1bmN0aW9uKHBvaW50KSB7XHJcbiAgIGlmICghcG9pbnQpIHtcclxuICAgICAgY29uc29sZS5sb2coJ291dCBvZiBib3VuZHMgZ2l2ZW4gdW5kZWZpbmVkIHBvaW50Jyk7XHJcbiAgICAgIHJldHVybjtcclxuICAgfVxyXG4gICBpZiAocG9pbnQueCA8IDAgfHwgcG9pbnQueCA+PSB0aGlzLmN1YmVzV2lkdGgoKSB8fCBwb2ludC55IDwgMCB8fCBwb2ludC55ID49IHRoaXMuY3ViZXNIZWlnaHQoKSkge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgfVxyXG4gICByZXR1cm4gZmFsc2U7XHJcbn07XHJcblxyXG5DdWJlR3JvdXAucHJvdG90eXBlLmRpc3BsYXlDdWJlcyA9IGZ1bmN0aW9uKCkge1xyXG4gICBjb25zb2xlLmxvZygnPT09PT09PT09PT09PT09PScpO1xyXG4gICB2YXIgb3V0cHV0ID0gJ0Rpc3BsYXkgQ3ViZXNcXG4nO1xyXG4gICB2YXIgcm93ID0gMDtcclxuICAgdmFyIGNvbCA9IHRoaXMuY3ViZXNIZWlnaHQoKSAtIDE7XHJcbiAgIHdoaWxlIChjb2wgPj0gMCkge1xyXG4gICAgICB3aGlsZSAocm93IDwgdGhpcy5jdWJlc1dpZHRoKCkpIHtcclxuICAgICAgICAgdmFyIGN1YmUgPSB0aGlzLmN1YmVzW3Jvd11bY29sXTtcclxuICAgICAgICAgaWYgKGN1YmUpIHtcclxuICAgICAgICAgICAgb3V0cHV0ICs9ICcjICc7XHJcbiAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG91dHB1dCArPSAnXyAnO1xyXG4gICAgICAgICB9XHJcbiAgICAgICAgIHJvdysrO1xyXG4gICAgICB9XHJcbiAgICAgIHJvdyA9IDA7XHJcbiAgICAgIGNvbC0tO1xyXG4gICAgICBvdXRwdXQgKz0gJ1xcbic7XHJcbiAgIH1cclxuICAgY29uc29sZS5sb2cob3V0cHV0KTtcclxuICAgY29uc29sZS5sb2coJy0tLS0tLS0tLS0tLS0tLScpO1xyXG59O1xyXG5cclxuQ3ViZUdyb3VwLnByb3RvdHlwZS5kaXNwbGF5Q29ubmVjdGlvbiA9IGZ1bmN0aW9uKGNvbm5lY3Rpb24pIHtcclxuICAgdmFyIGdyYXBoID0gbmV3IEFzdGFyLkdyYXBoKHRoaXMuY3ViZXNUb0dyYXBoKCkpO1xyXG4gICB2YXIgc3RhcnRQb2ludCA9IHRoaXMuZmluZChjb25uZWN0aW9uLnN0YXJ0KTtcclxuICAgdmFyIGVuZFBvaW50ID0gdGhpcy5maW5kKGNvbm5lY3Rpb24uZW5kKTtcclxuICAgaWYgKCFzdGFydFBvaW50IHx8ICFlbmRQb2ludCkge1xyXG4gICAgICBjb25zb2xlLmxvZygnZGlzcGxheUNvbm5lY3Rpb24gZmFpbGVkIHRvIGdldCBwb2ludHMnKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICB9XHJcbiAgIHZhciBzdGFydCA9IGdyYXBoLmdyaWRbc3RhcnRQb2ludC54XVtzdGFydFBvaW50LnldO1xyXG4gICB2YXIgZW5kID0gZ3JhcGguZ3JpZFtlbmRQb2ludC54XVtlbmRQb2ludC55XTtcclxuICAgdmFyIHJlc3VsdCA9IEFzdGFyLmFzdGFyLnNlYXJjaChncmFwaCwgc3RhcnQsIGVuZCk7XHJcbiAgIHJlc3VsdC51bnNoaWZ0KHN0YXJ0KTtcclxuICAgdmFyIHByZXZpb3VzO1xyXG4gICBmb3IodmFyIGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHZhciBjdXJQb2ludCA9IG5ldyBQaGFzZXIuUG9pbnQocmVzdWx0W2ldLngsIHJlc3VsdFtpXS55KTtcclxuICAgICAgdmFyIGN1ciA9IHRoaXMuZ2V0KGN1clBvaW50KTtcclxuICAgICAgdmFyIGluZGljYXRvciA9IGN1ci5jSW5kaWNhdG9yO1xyXG4gICAgICB2YXIgZGlyO1xyXG4gICAgICB2YXIgcHJldlBvaW50O1xyXG4gICAgICB2YXIgbmV4dFBvaW50O1xyXG4gICAgICBpZiAoIXByZXZpb3VzKSB7XHJcbiAgICAgICAgIGluZGljYXRvci5hbmltYXRpb25zLnBsYXkoJ2VuZCcpO1xyXG4gICAgICAgICBuZXh0UG9pbnQgPSBuZXcgUGhhc2VyLlBvaW50KHJlc3VsdFtpKzFdLngsIHJlc3VsdFtpKzFdLnkpO1xyXG4gICAgICAgICBkaXIgPSB0aGlzLmRpckJldHdlZW4oY3VyUG9pbnQsIG5leHRQb2ludCk7XHJcbiAgICAgICAgIGluZGljYXRvci5yb3RhdGlvbiA9IHRoaXMuZGlyVG9BbmdsZShkaXIpO1xyXG4gICAgICB9IGVsc2UgaWYgKGkgPT09IHJlc3VsdC5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgIGluZGljYXRvci5hbmltYXRpb25zLnBsYXkoJ2VuZCcpO1xyXG4gICAgICAgICBwcmV2UG9pbnQgPSBuZXcgUGhhc2VyLlBvaW50KHByZXZpb3VzLngsIHByZXZpb3VzLnkpO1xyXG4gICAgICAgICBkaXIgPSB0aGlzLmRpckJldHdlZW4oY3VyUG9pbnQsIHByZXZQb2ludCk7XHJcbiAgICAgICAgIGluZGljYXRvci5yb3RhdGlvbiA9IHRoaXMuZGlyVG9BbmdsZShkaXIpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgICBpbmRpY2F0b3IuYW5pbWF0aW9ucy5wbGF5KCdsaW5lJyk7XHJcbiAgICAgICAgIHByZXZQb2ludCA9IG5ldyBQaGFzZXIuUG9pbnQocHJldmlvdXMueCwgcHJldmlvdXMueSk7XHJcbiAgICAgICAgIHZhciBwcmV2RGlyID0gdGhpcy5kaXJCZXR3ZWVuKGN1clBvaW50LCBwcmV2UG9pbnQpO1xyXG4gICAgICAgICBuZXh0UG9pbnQgPSBuZXcgUGhhc2VyLlBvaW50KHJlc3VsdFtpKzFdLngsIHJlc3VsdFtpKzFdLnkpO1xyXG4gICAgICAgICB2YXIgbmV4dERpciA9IHRoaXMuZGlyQmV0d2VlbihjdXJQb2ludCwgbmV4dFBvaW50KTtcclxuICAgICAgICAgdGhpcy5tYW5hZ2VJbmRpY2F0b3IoaW5kaWNhdG9yLCBwcmV2RGlyLCBuZXh0RGlyKTtcclxuICAgICAgfVxyXG4gICAgICBwcmV2aW91cyA9IHJlc3VsdFtpXTtcclxuICAgICAgY3VyLmRpc3BsYXlJbmRpY2F0b3IoKTtcclxuICAgIH1cclxufTtcclxuXHJcbkN1YmVHcm91cC5wcm90b3R5cGUubWFuYWdlSW5kaWNhdG9yID0gZnVuY3Rpb24oaW5kaWNhdG9yLCBwcmV2RGlyLCBuZXh0RGlyKSB7XHJcbiAgaW5kaWNhdG9yLnNjYWxlLnNldFRvKE1hdGguYWJzKGluZGljYXRvci5zY2FsZS54KSwgaW5kaWNhdG9yLnNjYWxlLnkpO1xyXG4gIGlmIChwcmV2RGlyID09PSB0aGlzLkRJUi5OT1JUSCAmJiBuZXh0RGlyID09PSB0aGlzLkRJUi5TT1VUSCkgeyAvLyAyXHJcbiAgICAgIGluZGljYXRvci5yb3RhdGlvbiA9IE1hdGguUEk7XHJcbiAgIH0gZWxzZSBpZiAocHJldkRpciA9PT0gdGhpcy5ESVIuU09VVEggJiYgbmV4dERpciA9PT0gdGhpcy5ESVIuTk9SVEgpIHsgLy8gMVxyXG4gICAgICBpbmRpY2F0b3Iucm90YXRpb24gPSAwO1xyXG4gICB9IGVsc2UgaWYgKHByZXZEaXIgPT09IHRoaXMuRElSLkVBU1QgJiYgbmV4dERpciA9PT0gdGhpcy5ESVIuV0VTVCkgeyAvLyA0XHJcbiAgICAgIGluZGljYXRvci5yb3RhdGlvbiA9IDEgLyAyICogTWF0aC5QSTtcclxuICAgfSBlbHNlIGlmIChwcmV2RGlyID09PSB0aGlzLkRJUi5XRVNUICYmIG5leHREaXIgPT09IHRoaXMuRElSLkVBU1QpIHsgLy8gM1xyXG4gICAgICBpbmRpY2F0b3Iucm90YXRpb24gPSAzIC8gMiAgKiBNYXRoLlBJO1xyXG4gICB9IGVsc2Uge1xyXG4gICAgICBpbmRpY2F0b3IuYW5pbWF0aW9ucy5wbGF5KCdyaWdodCcpO1xyXG4gICAgICBpZiAocHJldkRpciA9PT0gdGhpcy5ESVIuU09VVEggJiYgbmV4dERpciA9PT0gdGhpcy5ESVIuRUFTVCkgeyAvLyA1XHJcbiAgICAgICAgIGluZGljYXRvci5yb3RhdGlvbiA9IDA7XHJcbiAgICAgIH0gZWxzZSBpZiAocHJldkRpciA9PT0gdGhpcy5ESVIuV0VTVCAmJiBuZXh0RGlyID09PSB0aGlzLkRJUi5TT1VUSCkgeyAvLyA2XHJcbiAgICAgICAgIGluZGljYXRvci5yb3RhdGlvbiA9IDEgLyAyICogTWF0aC5QSTtcclxuICAgICAgfSBlbHNlIGlmIChwcmV2RGlyID09PSB0aGlzLkRJUi5OT1JUSCAmJiBuZXh0RGlyID09PSB0aGlzLkRJUi5XRVNUKSB7IC8vIDdcclxuICAgICAgICAgaW5kaWNhdG9yLnJvdGF0aW9uID0gTWF0aC5QSTtcclxuICAgICAgfSBlbHNlIGlmIChwcmV2RGlyID09PSB0aGlzLkRJUi5FQVNUICYmIG5leHREaXIgPT09IHRoaXMuRElSLk5PUlRIKSB7IC8vIDhcclxuICAgICAgICAgaW5kaWNhdG9yLnJvdGF0aW9uID0gMyAvIDIgKiBNYXRoLlBJO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgICBpbmRpY2F0b3Iuc2NhbGUuc2V0VG8oLU1hdGguYWJzKGluZGljYXRvci5zY2FsZS54KSwgaW5kaWNhdG9yLnNjYWxlLnkpO1xyXG4gICAgICAgICBpZiAocHJldkRpciA9PT0gdGhpcy5ESVIuU09VVEggJiYgbmV4dERpciA9PT0gdGhpcy5ESVIuV0VTVCkgeyAvLyA5XHJcbiAgICAgICAgICAgIGluZGljYXRvci5yb3RhdGlvbiA9IDA7XHJcbiAgICAgICAgIH0gZWxzZSBpZiAocHJldkRpciA9PT0gdGhpcy5ESVIuV0VTVCAmJiBuZXh0RGlyID09PSB0aGlzLkRJUi5OT1JUSCkgeyAvLyAxMFxyXG4gICAgICAgICAgICBpbmRpY2F0b3Iucm90YXRpb24gPSAxIC8gMiAqIE1hdGguUEk7XHJcbiAgICAgICAgIH0gZWxzZSBpZiAocHJldkRpciA9PT0gdGhpcy5ESVIuTk9SVEggJiYgbmV4dERpciA9PT0gdGhpcy5ESVIuRUFTVCkgeyAvLyAxMVxyXG4gICAgICAgICAgICBpbmRpY2F0b3Iucm90YXRpb24gPSBNYXRoLlBJO1xyXG4gICAgICAgICB9IGVsc2UgaWYgKHByZXZEaXIgPT09IHRoaXMuRElSLkVBU1QgJiYgbmV4dERpciA9PT0gdGhpcy5ESVIuU09VVEgpIHsgLy8gMTJcclxuICAgICAgICAgICAgaW5kaWNhdG9yLnJvdGF0aW9uID0gMyAvIDIgKiBNYXRoLlBJO1xyXG4gICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgfSBcclxufTtcclxuXHJcbkN1YmVHcm91cC5wcm90b3R5cGUuY3ViZXNUb0dyYXBoID0gZnVuY3Rpb24oKSB7XHJcbiAgdmFyIGdyYXBoID0gW107XHJcbiAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgdGhpcy5jdWJlc1dpZHRoKCk7IHJvdysrKSB7XHJcbiAgICAgdmFyIG5ld0NvbCA9IFtdO1xyXG4gICAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCB0aGlzLmN1YmVzSGVpZ2h0KCk7IGNvbCsrKSB7XHJcbiAgICAgICAgIGlmICh0aGlzLmN1YmVzW3Jvd11bY29sXSkge1xyXG4gICAgICAgICAgICBuZXdDb2wucHVzaCgxKTtcclxuICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbmV3Q29sLnB1c2goMCk7XHJcbiAgICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBncmFwaC5wdXNoKG5ld0NvbCk7XHJcbiAgIH1cclxuICAgcmV0dXJuIGdyYXBoO1xyXG59O1xyXG5cclxuQ3ViZUdyb3VwLnByb3RvdHlwZS5kaXJCZXR3ZWVuID0gZnVuY3Rpb24oYSwgYikge1xyXG4gICB2YXIgZGVsdGFYID0gYS54IC0gYi54O1xyXG4gICB2YXIgZGVsdGFZID0gYS55IC0gYi55O1xyXG4gICBpZiAoZGVsdGFYID4gMCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5ESVIuV0VTVDtcclxuICAgfVxyXG4gICBpZiAoZGVsdGFYIDwgMCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5ESVIuRUFTVDtcclxuICAgfVxyXG4gICBpZiAoZGVsdGFZID4gMCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5ESVIuU09VVEg7XHJcbiAgIH1cclxuICAgaWYgKGRlbHRhWSA8IDApIHtcclxuICAgICAgcmV0dXJuIHRoaXMuRElSLk5PUlRIO1xyXG4gICB9XHJcbiAgIHJldHVybiB0aGlzLkRJUi5OT1JUSDtcclxufTtcclxuXHJcbkN1YmVHcm91cC5wcm90b3R5cGUuZGlyVG9BbmdsZSA9IGZ1bmN0aW9uKGRpcikge1xyXG4gIHN3aXRjaCAoZGlyKSB7XHJcbiAgIGNhc2UgdGhpcy5ESVIuTk9SVEg6XHJcbiAgIHJldHVybiBNYXRoLlBJO1xyXG4gICBjYXNlIHRoaXMuRElSLkVBU1Q6XHJcbiAgIHJldHVybiAzIC8gMiAqIE1hdGguUEk7XHJcbiAgIGNhc2UgdGhpcy5ESVIuU09VVEg6XHJcbiAgIHJldHVybiAwO1xyXG4gICBjYXNlIHRoaXMuRElSLldFU1Q6XHJcbiAgIHJldHVybiAxIC8gMiAqIE1hdGguUEk7XHJcbiAgfSAgXHJcbn07XHJcblxyXG5DdWJlR3JvdXAucHJvdG90eXBlLmRlc3Ryb3lDdWJlID0gZnVuY3Rpb24oY3ViZSkge1xyXG4gIC8vIGNvbnNvbGUubG9nKCdkZXN0cm95Q3ViZScpO1xyXG4gIHZhciBsb2MgPSB0aGlzLmZpbmQoY3ViZSk7XHJcbiAgaWYgKCFsb2MpIHtcclxuICAgICBjb25zb2xlLmxvZygnYXR0ZW1wdCB0byBkZXN0cm95IGN1YmUgbm90IGluIGdyb3VwJyk7XHJcbiAgICAgcmV0dXJuO1xyXG4gIH1cclxuICAvLyByZW1vdmUgY3ViZSBmcm9tIGdyb3VwXHJcbiAgdGhpcy5yZW1vdmUoY3ViZSk7XHJcbiAgLy8gZGVzdHJveSBjdWJlXHJcbiAgY3ViZS5raWxsKHRydWUpO1xyXG59O1xyXG5cclxuQ3ViZUdyb3VwLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihjdWJlKSB7XHJcbiAgIC8vIGNvbnNvbGUubG9nKCdyZW1vdmUnKTtcclxuICAgaWYgKHRoaXMucm9vdCA9PT0gY3ViZSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgIH1cclxuICAgLy8gcmVtb3ZlIGN1YmUgZnJvbSBhcnJheVxyXG4gICB2YXIgcm93LCBjb2w7XHJcbiAgIGZvciAocm93ID0gMDsgcm93IDwgdGhpcy5jdWJlc1dpZHRoKCk7IHJvdysrKSB7XHJcbiAgICAgIGZvciAoY29sID0gMDsgY29sIDwgdGhpcy5jdWJlc0hlaWdodCgpOyBjb2wrKykge1xyXG4gICAgICAgICBpZiAodGhpcy5jdWJlc1tyb3ddW2NvbF0gPT09IGN1YmUpIHtcclxuICAgICAgICAgICAgLy8gdGhpcy5jdWJlc1tyb3ddW2NvbF0uZ3JvdXAgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIHRoaXMuY3ViZXNbcm93XVtjb2xdID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgIH1cclxuICAgLy8gcmVtb3ZlIGNvbnN0cmFpbnRzIGZyb20gY3ViZVxyXG4gICB0aGlzLnJlbW92ZUNvbnN0cmFpbnRzKGN1YmUpO1xyXG4gICBjdWJlLmdyb3VwID0gdW5kZWZpbmVkO1xyXG4gICBpZiAoY3ViZS5tb2R1bGUgJiYgY3ViZS5tb2R1bGUuaGFzT3duUHJvcGVydHkoJ29uUmVtb3ZlJykpIHtcclxuICAgICAgY3ViZS5tb2R1bGUub25SZW1vdmUoKTtcclxuICAgfVxyXG4gICAvLyB0ZXN0IGZvciBleGlsZXNcclxuICAgZm9yIChyb3cgPSAwOyByb3cgPCB0aGlzLmN1YmVzV2lkdGgoKTsgcm93KyspIHtcclxuICAgICAgZm9yIChjb2wgPSAwOyBjb2wgPCB0aGlzLmN1YmVzSGVpZ2h0KCk7IGNvbCsrKSB7XHJcbiAgICAgICAgIHZhciBleGlsZSA9IHRoaXMuY3ViZXNbcm93XVtjb2xdO1xyXG4gICAgICAgICBpZiAoZXhpbGUgJiYgdGhpcy5pc0V4aWxlKGV4aWxlKSkge1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZShleGlsZSk7XHJcbiAgICAgICAgIH1cclxuICAgICAgfVxyXG4gICB9XHJcbiAgIC8vIHRoaXMuZGlzcGxheUN1YmVzKCk7XHJcbn07XHJcblxyXG5DdWJlR3JvdXAucHJvdG90eXBlLnJlbW92ZU5laWdoYm9yc0NvbnN0cmFpbnQgPSBmdW5jdGlvbihjb25zdHJhaW50LCBjdWJlKSB7XHJcbiAgIC8vIGNvbnNvbGUubG9nKCdyZW1vdmVOZWlnaGJvcnNDb25zdHJhaW50Jyk7XHJcbiAgIHZhciBuZWlnaGJvcnMgPSB0aGlzLmdldE5laWdoYm9ycyhjdWJlKTtcclxuICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZWlnaGJvcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgdmFyIG5laWdoYm9yID0gbmVpZ2hib3JzW2ldO1xyXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5laWdoYm9yLmNvbnN0cmFpbnRzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgIGlmIChuZWlnaGJvci5jb25zdHJhaW50c1tqXSA9PT0gY29uc3RyYWludCkge1xyXG4gICAgICAgICAgICBuZWlnaGJvci5jb25zdHJhaW50cy5zcGxpY2UoaiwgMSk7XHJcbiAgICAgICAgIH1cclxuICAgICAgfVxyXG4gICB9XHJcbn07XHJcblxyXG5DdWJlR3JvdXAucHJvdG90eXBlLmdldE5laWdoYm9ycyA9IGZ1bmN0aW9uKGN1YmUpIHtcclxuICAgdmFyIGxvYyA9IHRoaXMuZmluZChjdWJlKTtcclxuICAgdmFyIG5vcnRoID0gdGhpcy5nZXQodGhpcy5hZGp1c3QobG9jLCB0aGlzLkRJUi5OT1JUSCkpO1xyXG4gICB2YXIgZWFzdCA9IHRoaXMuZ2V0KHRoaXMuYWRqdXN0KGxvYywgdGhpcy5ESVIuRUFTVCkpO1xyXG4gICB2YXIgc291dGggPSB0aGlzLmdldCh0aGlzLmFkanVzdChsb2MsIHRoaXMuRElSLlNPVVRIKSk7XHJcbiAgIHZhciB3ZXN0ID0gdGhpcy5nZXQodGhpcy5hZGp1c3QobG9jLCB0aGlzLkRJUi5XRVNUKSk7XHJcbiAgIHZhciBuZWlnaGJvcnMgPSBbXTtcclxuICAgaWYgKG5vcnRoKSB7XHJcbiAgICAgIG5laWdoYm9ycy5wdXNoKG5vcnRoKTtcclxuICAgfVxyXG4gICBpZiAoZWFzdCkge1xyXG4gICAgICBuZWlnaGJvcnMucHVzaChlYXN0KTtcclxuICAgfVxyXG4gICBpZiAoc291dGgpIHtcclxuICAgICAgbmVpZ2hib3JzLnB1c2goc291dGgpO1xyXG4gICB9XHJcbiAgIGlmICh3ZXN0KSB7XHJcbiAgICAgIG5laWdoYm9ycy5wdXNoKHdlc3QpO1xyXG4gICB9XHJcbiAgIHJldHVybiBuZWlnaGJvcnM7XHJcbn07XHJcblxyXG5DdWJlR3JvdXAucHJvdG90eXBlLnJlbW92ZUNvbnN0cmFpbnRzID0gZnVuY3Rpb24oY3ViZSkge1xyXG4gICAvLyBjb25zb2xlLmxvZygncmVtb3ZlQ29uc3RyYWludHMnKTtcclxuICAgd2hpbGUgKGN1YmUuY29uc3RyYWludHMubGVuZ3RoID4gMCkge1xyXG4gICAgICB0aGlzLnJlbW92ZU5laWdoYm9yc0NvbnN0cmFpbnQoY3ViZS5jb25zdHJhaW50c1swXSwgY3ViZSk7XHJcbiAgICAgIHRoaXMuZ2FtZS5waHlzaWNzLnAyLnJlbW92ZUNvbnN0cmFpbnQoY3ViZS5jb25zdHJhaW50c1swXSk7XHJcbiAgICAgIGN1YmUuY29uc3RyYWludHMuc3BsaWNlKDAsIDEpO1xyXG4gICB9XHJcbn07XHJcblxyXG4vLyBvbmx5IHVzZWQgdG8gdGVzdCBBc3RhclxyXG5DdWJlR3JvdXAucHJvdG90eXBlLnRlc3RQYXRoID0gZnVuY3Rpb24oKSB7XHJcbiAgdmFyIGdyYXBoID0gbmV3IEFzdGFyLkdyYXBoKFtcclxuICAgICAgICBbMSwxLDEsMV0sXHJcbiAgICAgICAgWzAsMSwxLDBdLFxyXG4gICAgICAgIFswLDAsMCwxXVxyXG4gICAgXSk7XHJcbiAgIHZhciBzdGFydCA9IGdyYXBoLmdyaWRbMF1bMF07XHJcbiAgIHZhciBlbmQgPSBncmFwaC5ncmlkWzJdWzNdO1xyXG4gICB2YXIgcmVzdWx0ID0gQXN0YXIuYXN0YXIuc2VhcmNoKGdyYXBoLCBzdGFydCwgZW5kKTtcclxuICAgcmVzdWx0LnVuc2hpZnQoc3RhcnQpO1xyXG4gICBmb3IodmFyIGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKHJlc3VsdFtpXS54LCByZXN1bHRbaV0ueSk7XHJcbiAgICB9IFxyXG59O1xyXG5cclxuQ3ViZUdyb3VwLnByb3RvdHlwZS5pc0V4aWxlID0gZnVuY3Rpb24oY3ViZSkge1xyXG4gICBpZiAoY3ViZSA9PT0gdGhpcy5yb290KSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgfVxyXG4gICB2YXIgZ3JhcGggPSBuZXcgQXN0YXIuR3JhcGgodGhpcy5jdWJlc1RvR3JhcGgoKSk7XHJcbiAgIHZhciBzdGFydFBvaW50ID0gdGhpcy5maW5kKHRoaXMucm9vdCk7XHJcbiAgIHZhciBlbmRQb2ludCA9IHRoaXMuZmluZChjdWJlKTtcclxuICAgdmFyIHN0YXJ0ID0gZ3JhcGguZ3JpZFtzdGFydFBvaW50LnhdW3N0YXJ0UG9pbnQueV07XHJcbiAgIHZhciBlbmQgPSBncmFwaC5ncmlkW2VuZFBvaW50LnhdW2VuZFBvaW50LnldO1xyXG4gICB2YXIgcmVzdWx0ID0gQXN0YXIuYXN0YXIuc2VhcmNoKGdyYXBoLCBzdGFydCwgZW5kKTtcclxuICAgLy8gaWYgbm8gcGF0aCBpcyBmb3VuZCwgdGhlIGN1YmUgaXMgYW4gZXhpbGVcclxuICAgaWYgKHJlc3VsdC5sZW5ndGggPT09IDApIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgIH1cclxuICAgcmV0dXJuIGZhbHNlO1xyXG59O1xyXG5cclxuQ3ViZUdyb3VwLnByb3RvdHlwZS5jb3VudEN1YmVzID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIHJvdywgY29sO1xyXG5cdHZhciBudW0gID0gMDtcclxuXHRmb3IgKHJvdyA9IDA7IHJvdyA8IHRoaXMuY3ViZXNXaWR0aCgpOyByb3crKykge1xyXG5cdFx0Zm9yIChjb2wgPSAwOyBjb2wgPCB0aGlzLmN1YmVzSGVpZ2h0KCk7IGNvbCsrKSB7XHJcblx0XHRcdGlmICh0aGlzLmN1YmVzW3Jvd11bY29sXSAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0bnVtKys7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblx0Ly9jb25zb2xlLmxvZyhudW0pO1xyXG5cdHRoaXMubnVtQ3ViZXMgPSBudW07XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEN1YmVHcm91cDtcclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbiIsInZhciBVdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzLmpzJyk7XHJcblxyXG52YXIgRW5lbXlBSSA9IGZ1bmN0aW9uKGdhbWUsIGdyb3VwLCB0eXBlLCBwbGF5ZXJHcm91cCkge1xyXG4gICB0aGlzLmdhbWUgPSBnYW1lO1xyXG4gICB0aGlzLmdyb3VwID0gZ3JvdXA7XHJcbiAgIHRoaXMudHlwZSA9IHR5cGU7XHJcbiAgIHRoaXMucGxheWVyR3JvdXAgPSBwbGF5ZXJHcm91cDtcclxuICAgdGhpcy5wbGF5ZXIgPSB0aGlzLnBsYXllckdyb3VwLnJvb3Q7XHJcbiAgIHRoaXMucmFtRGlzdCA9IDUwMDtcclxuICAgdGhpcy5yb3RhdGlvbkZvcmNlID0gNTA7XHJcbiAgIHRoaXMuZmFjaW5nQWxsb3dhbmNlID0gTWF0aC5QSSAvIDIwO1xyXG4gICB0aGlzLnRocnVzdGVyc0ZpcmluZyA9IGZhbHNlO1xyXG4gICBzd2l0Y2ggKHRoaXMudHlwZSkge1xyXG4gICAgICBjYXNlICdyYW0nOlxyXG4gICAgICB0aGlzLmFsbG9jYXRlVG9UaHJ1c3RlcnMoKTtcclxuICAgICAgYnJlYWs7XHJcbiAgIH1cclxufTtcclxuXHJcbkVuZW15QUkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRW5lbXlBSTtcclxuXHJcbkVuZW15QUkucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICBzd2l0Y2ggKHRoaXMudHlwZSkge1xyXG4gICAgICBjYXNlICdyYW0nOlxyXG4gICAgICB0aGlzLnJhbVVwZGF0ZSgpO1xyXG4gICAgICBicmVhaztcclxuICAgfVxyXG59O1xyXG5cclxuRW5lbXlBSS5wcm90b3R5cGUucmFtVXBkYXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgIHJldHVybjtcclxuICAgaWYgKCF0aGlzLmdyb3VwLnJvb3QpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICB9XHJcbiAgIHZhciByb290ID0gdGhpcy5ncm91cC5yb290O1xyXG4gICB2YXIgbXlQb3MgPSBuZXcgUGhhc2VyLlBvaW50KHJvb3QueCwgcm9vdC55KTtcclxuICAgdmFyIHBsYXllclBvcyA9IG5ldyBQaGFzZXIuUG9pbnQodGhpcy5wbGF5ZXIueCwgdGhpcy5wbGF5ZXIueSk7XHJcbiAgIHZhciBkaXN0ID0gVXRpbHMuZGlzdGFuY2UobXlQb3MueCwgbXlQb3MueSwgcGxheWVyUG9zLngsIHBsYXllclBvcy55KTtcclxuICAgaWYgKGRpc3QgPD0gdGhpcy5yYW1EaXN0KSB7XHJcbiAgICAgIHZhciBhbmdsZVRvID0gdGhpcy5hbmdsZVRvKG15UG9zLCBwbGF5ZXJQb3MpO1xyXG4gICAgICB2YXIgZGlmZkFuZ2xlID0gYW5nbGVUbyAtIHJvb3QuYm9keS5yb3RhdGlvbjtcclxuICAgICAgaWYgKGRpZmZBbmdsZSA+IDApIHtcclxuICAgICAgICAgcm9vdC5ib2R5LmFuZ3VsYXJGb3JjZSA9IHRoaXMucm90YXRpb25Gb3JjZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgcm9vdC5ib2R5LmFuZ3VsYXJGb3JjZSA9IC10aGlzLnJvdGF0aW9uRm9yY2U7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKE1hdGguYWJzKGRpZmZBbmdsZSkgPD0gdGhpcy5mYWNpbmdBbGxvd2FuY2UgJiYgIXRoaXMudGhydXN0ZXJzRmlyaW5nKSB7XHJcbiAgICAgICAgIHRoaXMuZ3JvdXAuY2FsbCgnYmVnaW5UaHJ1c3QnKTtcclxuICAgICAgICAgdGhpcy50aHJ1c3RlcnNGaXJpbmcgPSB0cnVlO1xyXG4gICAgICAgICB0aGlzLmFsbG9jYXRlVG9UaHJ1c3RlcnMoKTtcclxuICAgICAgfSBlbHNlIGlmIChNYXRoLmFicyhkaWZmQW5nbGUpID4gdGhpcy5mYWNpbmdBbGxvd2FuY2UgJiYgdGhpcy50aHJ1c3RlcnNGaXJpbmcpe1xyXG4gICAgICAgICB0aGlzLmdyb3VwLmNhbGwoJ2VuZFRocnVzdCcpO1xyXG4gICAgICAgICB0aGlzLnRocnVzdGVyc0ZpcmluZyA9IGZhbHNlO1xyXG4gICAgICB9XHJcbiAgIH1cclxufTtcclxuXHJcbkVuZW15QUkucHJvdG90eXBlLmFsbG9jYXRlVG9UaHJ1c3RlcnMgPSBmdW5jdGlvbigpIHtcclxuICAgdmFyIHBhbmVscyA9IFtdO1xyXG4gICB2YXIgdGhydXN0ZXJzID0gW107XHJcbiAgIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IHRoaXMuZ3JvdXAuY3ViZXNXaWR0aCgpOyByb3crKykge1xyXG4gICAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCB0aGlzLmdyb3VwLmN1YmVzSGVpZ2h0KCk7IGNvbCsrKSB7XHJcbiAgICAgICAgIHZhciBjdWJlID0gdGhpcy5ncm91cC5jdWJlc1tyb3ddW2NvbF07XHJcbiAgICAgICAgIGlmIChjdWJlICYmIGN1YmUubW9kdWxlKSB7XHJcbiAgICAgICAgICAgIGlmIChjdWJlLm1vZHVsZS50eXBlID09PSAnc29sYXJQYW5lbCcgJiYgIWN1YmUubXlDb25uZWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgIHBhbmVscy5wdXNoKGN1YmUubW9kdWxlKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChjdWJlLm1vZHVsZS50eXBlID09PSAndGhydXN0ZXInICYmICFjdWJlLm15Q29ubmVjdGlvbikge1xyXG4gICAgICAgICAgICAgICB0aHJ1c3RlcnMucHVzaChjdWJlLm1vZHVsZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgIH1cclxuICAgdmFyIGkgPSAwO1xyXG4gICB3aGlsZSAoaSA8IHRocnVzdGVycy5sZW5ndGggJiYgaSA8IHBhbmVscy5sZW5ndGgpIHtcclxuICAgICAgdmFyIHRhclBhbmVsID0gcGFuZWxzW2ldO1xyXG4gICAgICB2YXIgdGFyVGhydXN0ZXIgPSB0aHJ1c3RlcnNbaV07XHJcbiAgICAgIHZhciBuZXdDb25uZWN0aW9uID0ge3N0YXJ0OiB0YXJQYW5lbC5jdWJlLCBlbmQ6IHRhclRocnVzdGVyLmN1YmV9O1xyXG4gICAgICB0YXJQYW5lbC5jdWJlLm15Q29ubmVjdGlvbiA9IG5ld0Nvbm5lY3Rpb247XHJcbiAgICAgIHRhclRocnVzdGVyLmN1YmUubXlDb25uZWN0aW9uID0gbmV3Q29ubmVjdGlvbjtcclxuICAgICAgdGhpcy5ncm91cC5kaXNwbGF5Q29ubmVjdGlvbih0YXJQYW5lbC5jdWJlLm15Q29ubmVjdGlvbik7XHJcbiAgICAgIGkrKztcclxuICAgfVxyXG59O1xyXG5cclxuRW5lbXlBSS5wcm90b3R5cGUuYW5nbGVUbyA9IGZ1bmN0aW9uKGZyb20sIHRvKSB7XHJcbiAgdmFyIGFuZ2xlVG9PdGhlciA9IFBoYXNlci5Qb2ludC5hbmdsZShmcm9tLCB0byk7XHJcbiAgaWYgKGFuZ2xlVG9PdGhlciA8IDApIHsgLy8gZml4IGR1bWIgcGFydCBvZiBQaGFzZXIuUG9pbnQuYW5nbGUoKVxyXG4gICAgIGFuZ2xlVG9PdGhlciA9IDIgKiBNYXRoLlBJICsgYW5nbGVUb090aGVyO1xyXG4gIH1cclxuICBhbmdsZVRvT3RoZXIgPSAoYW5nbGVUb090aGVyICsgMy8yICogTWF0aC5QSSkgJSAoMiAqIE1hdGguUEkpOyAvLyByb3RhdGUgOTAgZCBjbG9ja3dpc2VcclxuICByZXR1cm4gYW5nbGVUb090aGVyO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBFbmVteUFJO1xyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuIiwidmFyIFV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMuanMnKTtcclxuXHJcbnZhciBNb3VzZSA9IGZ1bmN0aW9uKGdhbWUsIGlucHV0LCBwbGF5ZXJHcm91cCkge1xyXG4gICB0aGlzLmdhbWUgPSBnYW1lO1xyXG4gICB0aGlzLmlucHV0ID0gaW5wdXQ7XHJcblx0dGhpcy5ib2R5ID0gbmV3IHAyLkJvZHkoKTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXHJcbiAgIHRoaXMuZ2FtZS5waHlzaWNzLnAyLndvcmxkLmFkZEJvZHkodGhpcy5ib2R5KTtcclxuICAgLy8gdGhpcy5nYW1lLnBoeXNpY3MucDIuZW5hYmxlKHRoaXMpO1xyXG4gICBcclxuICAgdGhpcy5pbnB1dC5vbkRvd24uYWRkKHRoaXMuY2xpY2ssIHRoaXMpO1xyXG4gICB0aGlzLmlucHV0Lm9uVXAuYWRkKHRoaXMucmVsZWFzZSwgdGhpcyk7XHJcbiAgIHRoaXMuaW5wdXQuYWRkTW92ZUNhbGxiYWNrKHRoaXMubW92ZSwgdGhpcyk7XHJcbiAgIHRoaXMueCA9IDA7XHJcbiAgIHRoaXMueSA9IDA7XHJcbiAgIFxyXG4gICB0aGlzLmdyYWJiZWQgPSB1bmRlZmluZWQ7XHJcbiAgIHRoaXMubGFzdENsaWNrZWQgPSB1bmRlZmluZWQ7XHJcbiAgIHRoaXMubGluZSA9IG5ldyBQaGFzZXIuTGluZSgwLCAwLCAwLCAwKTtcclxuICAgXHJcbiAgIHRoaXMucmVtb3ZlVGhyZXNob2xkID0gNDAwOyAvLyB0aW1lIGluIG1pbGxpc2Vjb25kc1xyXG4gICB0aGlzLnJlbW92ZVRpbWUgPSAwOyAvLyB0aW1lIHRpbGwgdGhyZXNob2xkXHJcbiAgIFxyXG4gICB0aGlzLnBsYXllckdyb3VwID0gcGxheWVyR3JvdXA7XHJcbn07XHJcblxyXG5Nb3VzZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNb3VzZTtcclxuXHJcbk1vdXNlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpIHtcclxuICAgaWYgKHRoaXMuZ3JhYmJlZCkge1xyXG4gICAgICB2YXIgYW5nbGUgPSBNYXRoLmF0YW4yKHRoaXMuZ3JhYmJlZC5zcHJpdGUueSAtICh0aGlzLmlucHV0LnBvc2l0aW9uLnkgKyB0aGlzLmdhbWUuY2FtZXJhLnkpLCB0aGlzLmdyYWJiZWQuc3ByaXRlLnggLSAodGhpcy5pbnB1dC5wb3NpdGlvbi54KyB0aGlzLmdhbWUuY2FtZXJhLngpKSArIE1hdGguUEk7XHJcbiAgICAgIHZhciBkaXN0ID0gVXRpbHMuZGlzdGFuY2UodGhpcy5ncmFiYmVkLnNwcml0ZS54LCB0aGlzLmdyYWJiZWQuc3ByaXRlLnksICh0aGlzLmlucHV0LnBvc2l0aW9uLngrIHRoaXMuZ2FtZS5jYW1lcmEueCksICh0aGlzLmlucHV0LnBvc2l0aW9uLnkgKyB0aGlzLmdhbWUuY2FtZXJhLnkpKTtcclxuICAgICAgdmFyIHdlaWdodCA9IDEwO1xyXG4gICAgICBpZiAoIXRoaXMuZ3JhYmJlZC5zcHJpdGUuZ3JvdXApIHtcclxuICAgICAgICAgdGhpcy5ncmFiYmVkLmZvcmNlLnggPSBNYXRoLmNvcyhhbmdsZSkgKiBkaXN0ICogd2VpZ2h0O1xyXG4gICAgICAgICB0aGlzLmdyYWJiZWQuZm9yY2UueSA9IE1hdGguc2luKGFuZ2xlKSAqIGRpc3QgKiB3ZWlnaHQ7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5saW5lLnNldFRvKHRoaXMuZ3JhYmJlZC5zcHJpdGUueCwgdGhpcy5ncmFiYmVkLnNwcml0ZS55LCAodGhpcy5pbnB1dC5wb3NpdGlvbi54KyB0aGlzLmdhbWUuY2FtZXJhLngpLCAodGhpcy5pbnB1dC5wb3NpdGlvbi55ICsgdGhpcy5nYW1lLmNhbWVyYS55KSk7XHJcbiAgICAgIHRoaXMucmVtb3ZlVGltZSArPSB0aGlzLmdhbWUudGltZS5lbGFwc2VkO1xyXG4gICAgICBpZiAodGhpcy5yZW1vdmVUaW1lID49IHRoaXMucmVtb3ZlVGhyZXNob2xkICYmIHRoaXMuZ3JhYmJlZC5zcHJpdGUua2V5ICE9PSAnYXN0ZXJvaWQnKSB7XHJcbiAgICAgICAgIHRoaXMuZ3JhYmJlZC5zcHJpdGUucmVtb3ZlKCk7XHJcbiAgICAgICAgIHRoaXMucmVtb3ZlVGltZSA9IDA7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICB0aGlzLmxpbmUuc2V0VG8oMCwgMCwgMCwgMCk7XHJcbiAgICB9XHJcbiAgICB2YXIgcG9pbnQgPSBuZXcgUGhhc2VyLlBvaW50KHRoaXMueCwgdGhpcy55KTtcclxuICAgIHZhciBib2RpZXMgPSB0aGlzLmdhbWUucGh5c2ljcy5wMi5oaXRUZXN0KHBvaW50KTtcclxuICAgIGlmIChib2RpZXMubGVuZ3RoKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBob3ZlciA9IGJvZGllc1swXS5wYXJlbnQ7XHJcbiAgICAgICAgaWYgKGhvdmVyLnNwcml0ZS5tb2R1bGUgJiYgaG92ZXIuc3ByaXRlLm1vZHVsZS5tb3VzZU92ZXIpIHtcclxuICAgICAgICAgICBob3Zlci5zcHJpdGUubW9kdWxlLm1vdXNlT3ZlcigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbk1vdXNlLnByb3RvdHlwZS5jbGljayA9IGZ1bmN0aW9uKHBvaW50ZXIpIHtcclxuICAgdmFyIHBvaW50ID0gbmV3IFBoYXNlci5Qb2ludChwb2ludGVyLnggKyB0aGlzLmdhbWUuY2FtZXJhLngsIHBvaW50ZXIueSArIHRoaXMuZ2FtZS5jYW1lcmEueSk7XHJcbiAgIHZhciBib2RpZXMgPSB0aGlzLmdhbWUucGh5c2ljcy5wMi5oaXRUZXN0KHBvaW50KTtcclxuICAgaWYgKGJvZGllcy5sZW5ndGgpXHJcbiAgIHtcclxuICAgICB2YXIgdGVtcCA9IGJvZGllc1swXS5wYXJlbnQ7XHJcbiAgICAgaWYgKHRlbXAuc3ByaXRlICYmIHRlbXAuc3ByaXRlLm1vZHVsZSAmJiB0ZW1wLnNwcml0ZS5tb2R1bGUudHlwZSA9PT0gJ2NvcmUnKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgIH1cclxuICAgICBpZiAodGVtcC5zcHJpdGUgJiYgdGVtcC5zcHJpdGUuZ3JvdXAgJiYgdGVtcC5zcHJpdGUuZ3JvdXAgIT09IHRoaXMucGxheWVyR3JvdXApIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgfVxyXG4gICAgIHRoaXMucmVtb3ZlVGltZSA9IDA7XHJcbiAgICAgdGhpcy5ncmFiYmVkID0gdGVtcDtcclxuICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLmdyYWJiZWQuc3ByaXRlLm5hbWUpO1xyXG4gICAgIGlmICh0aGlzLmdyYWJiZWQuc3ByaXRlLm1vZHVsZSAmJiB0aGlzLmdyYWJiZWQuc3ByaXRlLm1vZHVsZS5oYXNPd25Qcm9wZXJ0eSgnbW91c2VEb3duJykpIHtcclxuICAgICAgICB0aGlzLmdyYWJiZWQuc3ByaXRlLm1vZHVsZS5tb3VzZURvd24oKTtcclxuICAgICB9XHJcbiAgICAgaWYgKHRoaXMubGFzdENsaWNrZWQgJiYgdGhpcy5sYXN0Q2xpY2tlZC5zcHJpdGUgJiYgdGhpcy5sYXN0Q2xpY2tlZC5zcHJpdGUubW9kdWxlICYmXHJcbiAgICAgdGhpcy5sYXN0Q2xpY2tlZC5zcHJpdGUubW9kdWxlLmdpdmVUYXJnZXQpIHtcclxuICAgICAgICB0aGlzLmxhc3RDbGlja2VkLnNwcml0ZS5tb2R1bGUuZ2l2ZVRhcmdldCh0aGlzLmdyYWJiZWQuc3ByaXRlLm1vZHVsZSk7XHJcbiAgICAgfVxyXG4gICAgIHRoaXMubGFzdENsaWNrZWQgPSB0ZW1wO1xyXG4gICB9XHJcbn07XHJcbiAgXHJcbiBNb3VzZS5wcm90b3R5cGUucmVsZWFzZSA9IGZ1bmN0aW9uKCkge1xyXG4gICBpZiAodGhpcy5ncmFiYmVkKSB7XHJcbiAgICAgdGhpcy5ncmFiYmVkID0gdW5kZWZpbmVkO1xyXG4gICB9XHJcbn07XHJcbiAgXHJcbk1vdXNlLnByb3RvdHlwZS5tb3ZlID0gZnVuY3Rpb24ocG9pbnRlcikge1xyXG4gICAvLyBwMiB1c2VzIGRpZmZlcmVudCBjb29yZGluYXRlIHN5c3RlbSwgc28gY29udmVydCB0aGUgcG9pbnRlciBwb3NpdGlvbiB0byBwMidzIGNvb3JkaW5hdGUgc3lzdGVtXHJcbiAgIHRoaXMuYm9keS5wb3NpdGlvblswXSA9IHRoaXMuZ2FtZS5waHlzaWNzLnAyLnB4bWkocG9pbnRlci5wb3NpdGlvbi54KTtcclxuICAgdGhpcy5ib2R5LnBvc2l0aW9uWzFdID0gdGhpcy5nYW1lLnBoeXNpY3MucDIucHhtaShwb2ludGVyLnBvc2l0aW9uLnkpO1xyXG4gICB0aGlzLnggPSBwb2ludGVyLnBvc2l0aW9uLnggKyB0aGlzLmdhbWUuY2FtZXJhLng7XHJcbiAgIHRoaXMueSA9IHBvaW50ZXIucG9zaXRpb24ueSArIHRoaXMuZ2FtZS5jYW1lcmEueTtcclxufTtcclxuXHJcbk1vdXNlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbigpIHtcclxuICAgdGhpcy5nYW1lLmRlYnVnLmdlb20odGhpcy5saW5lKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTW91c2U7XHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuIiwiLy8gamF2YXNjcmlwdC1hc3RhciAwLjQuMFxyXG4vLyBodHRwOi8vZ2l0aHViLmNvbS9iZ3JpbnMvamF2YXNjcmlwdC1hc3RhclxyXG4vLyBGcmVlbHkgZGlzdHJpYnV0YWJsZSB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcbi8vIEltcGxlbWVudHMgdGhlIGFzdGFyIHNlYXJjaCBhbGdvcml0aG0gaW4gamF2YXNjcmlwdCB1c2luZyBhIEJpbmFyeSBIZWFwLlxyXG4vLyBJbmNsdWRlcyBCaW5hcnkgSGVhcCAod2l0aCBtb2RpZmljYXRpb25zKSBmcm9tIE1hcmlqbiBIYXZlcmJla2UuXHJcbi8vIGh0dHA6Ly9lbG9xdWVudGphdmFzY3JpcHQubmV0L2FwcGVuZGl4Mi5odG1sXHJcblxyXG4oZnVuY3Rpb24oZGVmaW5pdGlvbikge1xyXG4gICAgLyogZ2xvYmFsIG1vZHVsZSwgZGVmaW5lICovXHJcbiAgICBpZih0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBkZWZpbml0aW9uKCk7XHJcbiAgICB9IGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICAgICAgZGVmaW5lKFtdLCBkZWZpbml0aW9uKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdmFyIGV4cG9ydHMgPSBkZWZpbml0aW9uKCk7XHJcbiAgICAgICAgd2luZG93LmFzdGFyID0gZXhwb3J0cy5hc3RhcjtcclxuICAgICAgICB3aW5kb3cuR3JhcGggPSBleHBvcnRzLkdyYXBoO1xyXG4gICAgfVxyXG59KShmdW5jdGlvbigpIHtcclxuXHJcbmZ1bmN0aW9uIHBhdGhUbyhub2RlKXtcclxuICAgIHZhciBjdXJyID0gbm9kZSxcclxuICAgICAgICBwYXRoID0gW107XHJcbiAgICB3aGlsZShjdXJyLnBhcmVudCkge1xyXG4gICAgICAgIHBhdGgucHVzaChjdXJyKTtcclxuICAgICAgICBjdXJyID0gY3Vyci5wYXJlbnQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcGF0aC5yZXZlcnNlKCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEhlYXAoKSB7XHJcbiAgICByZXR1cm4gbmV3IEJpbmFyeUhlYXAoZnVuY3Rpb24obm9kZSkge1xyXG4gICAgICAgIHJldHVybiBub2RlLmY7XHJcbiAgICB9KTtcclxufVxyXG5cclxudmFyIGFzdGFyID0ge1xyXG4gICAgLyoqXHJcbiAgICAqIFBlcmZvcm0gYW4gQSogU2VhcmNoIG9uIGEgZ3JhcGggZ2l2ZW4gYSBzdGFydCBhbmQgZW5kIG5vZGUuXHJcbiAgICAqIEBwYXJhbSB7R3JhcGh9IGdyYXBoXHJcbiAgICAqIEBwYXJhbSB7R3JpZE5vZGV9IHN0YXJ0XHJcbiAgICAqIEBwYXJhbSB7R3JpZE5vZGV9IGVuZFxyXG4gICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXHJcbiAgICAqIEBwYXJhbSB7Ym9vbH0gW29wdGlvbnMuY2xvc2VzdF0gU3BlY2lmaWVzIHdoZXRoZXIgdG8gcmV0dXJuIHRoZVxyXG4gICAgICAgICAgICAgICBwYXRoIHRvIHRoZSBjbG9zZXN0IG5vZGUgaWYgdGhlIHRhcmdldCBpcyB1bnJlYWNoYWJsZS5cclxuICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuaGV1cmlzdGljXSBIZXVyaXN0aWMgZnVuY3Rpb24gKHNlZVxyXG4gICAgKiAgICAgICAgICBhc3Rhci5oZXVyaXN0aWNzKS5cclxuICAgICovXHJcbiAgICBzZWFyY2g6IGZ1bmN0aW9uKGdyYXBoLCBzdGFydCwgZW5kLCBvcHRpb25zKSB7XHJcbiAgICAgICAgZ3JhcGguY2xlYW5EaXJ0eSgpO1xyXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgICAgIHZhciBoZXVyaXN0aWMgPSBvcHRpb25zLmhldXJpc3RpYyB8fCBhc3Rhci5oZXVyaXN0aWNzLm1hbmhhdHRhbixcclxuICAgICAgICAgICAgY2xvc2VzdCA9IG9wdGlvbnMuY2xvc2VzdCB8fCBmYWxzZTtcclxuXHJcbiAgICAgICAgdmFyIG9wZW5IZWFwID0gZ2V0SGVhcCgpLFxyXG4gICAgICAgICAgICBjbG9zZXN0Tm9kZSA9IHN0YXJ0OyAvLyBzZXQgdGhlIHN0YXJ0IG5vZGUgdG8gYmUgdGhlIGNsb3Nlc3QgaWYgcmVxdWlyZWRcclxuXHJcbiAgICAgICAgc3RhcnQuaCA9IGhldXJpc3RpYyhzdGFydCwgZW5kKTtcclxuXHJcbiAgICAgICAgb3BlbkhlYXAucHVzaChzdGFydCk7XHJcblxyXG4gICAgICAgIHdoaWxlKG9wZW5IZWFwLnNpemUoKSA+IDApIHtcclxuXHJcbiAgICAgICAgICAgIC8vIEdyYWIgdGhlIGxvd2VzdCBmKHgpIHRvIHByb2Nlc3MgbmV4dC4gIEhlYXAga2VlcHMgdGhpcyBzb3J0ZWQgZm9yIHVzLlxyXG4gICAgICAgICAgICB2YXIgY3VycmVudE5vZGUgPSBvcGVuSGVhcC5wb3AoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEVuZCBjYXNlIC0tIHJlc3VsdCBoYXMgYmVlbiBmb3VuZCwgcmV0dXJuIHRoZSB0cmFjZWQgcGF0aC5cclxuICAgICAgICAgICAgaWYoY3VycmVudE5vZGUgPT09IGVuZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhdGhUbyhjdXJyZW50Tm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIE5vcm1hbCBjYXNlIC0tIG1vdmUgY3VycmVudE5vZGUgZnJvbSBvcGVuIHRvIGNsb3NlZCwgcHJvY2VzcyBlYWNoIG9mIGl0cyBuZWlnaGJvcnMuXHJcbiAgICAgICAgICAgIGN1cnJlbnROb2RlLmNsb3NlZCA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICAvLyBGaW5kIGFsbCBuZWlnaGJvcnMgZm9yIHRoZSBjdXJyZW50IG5vZGUuXHJcbiAgICAgICAgICAgIHZhciBuZWlnaGJvcnMgPSBncmFwaC5uZWlnaGJvcnMoY3VycmVudE5vZGUpO1xyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlsID0gbmVpZ2hib3JzLmxlbmd0aDsgaSA8IGlsOyArK2kpIHtcclxuICAgICAgICAgICAgICAgIHZhciBuZWlnaGJvciA9IG5laWdoYm9yc1tpXTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAobmVpZ2hib3IuY2xvc2VkIHx8IG5laWdoYm9yLmlzV2FsbCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTm90IGEgdmFsaWQgbm9kZSB0byBwcm9jZXNzLCBza2lwIHRvIG5leHQgbmVpZ2hib3IuXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVGhlIGcgc2NvcmUgaXMgdGhlIHNob3J0ZXN0IGRpc3RhbmNlIGZyb20gc3RhcnQgdG8gY3VycmVudCBub2RlLlxyXG4gICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBjaGVjayBpZiB0aGUgcGF0aCB3ZSBoYXZlIGFycml2ZWQgYXQgdGhpcyBuZWlnaGJvciBpcyB0aGUgc2hvcnRlc3Qgb25lIHdlIGhhdmUgc2VlbiB5ZXQuXHJcbiAgICAgICAgICAgICAgICB2YXIgZ1Njb3JlID0gY3VycmVudE5vZGUuZyArIG5laWdoYm9yLmdldENvc3QoY3VycmVudE5vZGUpLFxyXG4gICAgICAgICAgICAgICAgICAgIGJlZW5WaXNpdGVkID0gbmVpZ2hib3IudmlzaXRlZDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIWJlZW5WaXNpdGVkIHx8IGdTY29yZSA8IG5laWdoYm9yLmcpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRm91bmQgYW4gb3B0aW1hbCAoc28gZmFyKSBwYXRoIHRvIHRoaXMgbm9kZS4gIFRha2Ugc2NvcmUgZm9yIG5vZGUgdG8gc2VlIGhvdyBnb29kIGl0IGlzLlxyXG4gICAgICAgICAgICAgICAgICAgIG5laWdoYm9yLnZpc2l0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIG5laWdoYm9yLnBhcmVudCA9IGN1cnJlbnROb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgIG5laWdoYm9yLmggPSBuZWlnaGJvci5oIHx8IGhldXJpc3RpYyhuZWlnaGJvciwgZW5kKTtcclxuICAgICAgICAgICAgICAgICAgICBuZWlnaGJvci5nID0gZ1Njb3JlO1xyXG4gICAgICAgICAgICAgICAgICAgIG5laWdoYm9yLmYgPSBuZWlnaGJvci5nICsgbmVpZ2hib3IuaDtcclxuICAgICAgICAgICAgICAgICAgICBncmFwaC5tYXJrRGlydHkobmVpZ2hib3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjbG9zZXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBuZWlnaGJvdXIgaXMgY2xvc2VyIHRoYW4gdGhlIGN1cnJlbnQgY2xvc2VzdE5vZGUgb3IgaWYgaXQncyBlcXVhbGx5IGNsb3NlIGJ1dCBoYXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYSBjaGVhcGVyIHBhdGggdGhhbiB0aGUgY3VycmVudCBjbG9zZXN0IG5vZGUgdGhlbiBpdCBiZWNvbWVzIHRoZSBjbG9zZXN0IG5vZGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5laWdoYm9yLmggPCBjbG9zZXN0Tm9kZS5oIHx8IChuZWlnaGJvci5oID09PSBjbG9zZXN0Tm9kZS5oICYmIG5laWdoYm9yLmcgPCBjbG9zZXN0Tm9kZS5nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VzdE5vZGUgPSBuZWlnaGJvcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFiZWVuVmlzaXRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQdXNoaW5nIHRvIGhlYXAgd2lsbCBwdXQgaXQgaW4gcHJvcGVyIHBsYWNlIGJhc2VkIG9uIHRoZSAnZicgdmFsdWUuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5IZWFwLnB1c2gobmVpZ2hib3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxyZWFkeSBzZWVuIHRoZSBub2RlLCBidXQgc2luY2UgaXQgaGFzIGJlZW4gcmVzY29yZWQgd2UgbmVlZCB0byByZW9yZGVyIGl0IGluIHRoZSBoZWFwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5IZWFwLnJlc2NvcmVFbGVtZW50KG5laWdoYm9yKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChjbG9zZXN0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwYXRoVG8oY2xvc2VzdE5vZGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gTm8gcmVzdWx0IHdhcyBmb3VuZCAtIGVtcHR5IGFycmF5IHNpZ25pZmllcyBmYWlsdXJlIHRvIGZpbmQgcGF0aC5cclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9LFxyXG4gICAgLy8gU2VlIGxpc3Qgb2YgaGV1cmlzdGljczogaHR0cDovL3RoZW9yeS5zdGFuZm9yZC5lZHUvfmFtaXRwL0dhbWVQcm9ncmFtbWluZy9IZXVyaXN0aWNzLmh0bWxcclxuICAgIGhldXJpc3RpY3M6IHtcclxuICAgICAgICBtYW5oYXR0YW46IGZ1bmN0aW9uKHBvczAsIHBvczEpIHtcclxuICAgICAgICAgICAgdmFyIGQxID0gTWF0aC5hYnMocG9zMS54IC0gcG9zMC54KTtcclxuICAgICAgICAgICAgdmFyIGQyID0gTWF0aC5hYnMocG9zMS55IC0gcG9zMC55KTtcclxuICAgICAgICAgICAgcmV0dXJuIGQxICsgZDI7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBkaWFnb25hbDogZnVuY3Rpb24ocG9zMCwgcG9zMSkge1xyXG4gICAgICAgICAgICB2YXIgRCA9IDE7XHJcbiAgICAgICAgICAgIHZhciBEMiA9IE1hdGguc3FydCgyKTtcclxuICAgICAgICAgICAgdmFyIGQxID0gTWF0aC5hYnMocG9zMS54IC0gcG9zMC54KTtcclxuICAgICAgICAgICAgdmFyIGQyID0gTWF0aC5hYnMocG9zMS55IC0gcG9zMC55KTtcclxuICAgICAgICAgICAgcmV0dXJuIChEICogKGQxICsgZDIpKSArICgoRDIgLSAoMiAqIEQpKSAqIE1hdGgubWluKGQxLCBkMikpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBjbGVhbk5vZGU6ZnVuY3Rpb24obm9kZSl7XHJcbiAgICAgICAgbm9kZS5mID0gMDtcclxuICAgICAgICBub2RlLmcgPSAwO1xyXG4gICAgICAgIG5vZGUuaCA9IDA7XHJcbiAgICAgICAgbm9kZS52aXNpdGVkID0gZmFsc2U7XHJcbiAgICAgICAgbm9kZS5jbG9zZWQgPSBmYWxzZTtcclxuICAgICAgICBub2RlLnBhcmVudCA9IG51bGw7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuKiBBIGdyYXBoIG1lbW9yeSBzdHJ1Y3R1cmVcclxuKiBAcGFyYW0ge0FycmF5fSBncmlkSW4gMkQgYXJyYXkgb2YgaW5wdXQgd2VpZ2h0c1xyXG4qIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cclxuKiBAcGFyYW0ge2Jvb2x9IFtvcHRpb25zLmRpYWdvbmFsXSBTcGVjaWZpZXMgd2hldGhlciBkaWFnb25hbCBtb3ZlcyBhcmUgYWxsb3dlZFxyXG4qL1xyXG5mdW5jdGlvbiBHcmFwaChncmlkSW4sIG9wdGlvbnMpIHtcclxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgdGhpcy5ub2RlcyA9IFtdO1xyXG4gICAgdGhpcy5kaWFnb25hbCA9ICEhb3B0aW9ucy5kaWFnb25hbDtcclxuICAgIHRoaXMuZ3JpZCA9IFtdO1xyXG4gICAgZm9yICh2YXIgeCA9IDA7IHggPCBncmlkSW4ubGVuZ3RoOyB4KyspIHtcclxuICAgICAgICB0aGlzLmdyaWRbeF0gPSBbXTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgeSA9IDAsIHJvdyA9IGdyaWRJblt4XTsgeSA8IHJvdy5sZW5ndGg7IHkrKykge1xyXG4gICAgICAgICAgICB2YXIgbm9kZSA9IG5ldyBHcmlkTm9kZSh4LCB5LCByb3dbeV0pO1xyXG4gICAgICAgICAgICB0aGlzLmdyaWRbeF1beV0gPSBub2RlO1xyXG4gICAgICAgICAgICB0aGlzLm5vZGVzLnB1c2gobm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdGhpcy5pbml0KCk7XHJcbn1cclxuXHJcbkdyYXBoLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLmRpcnR5Tm9kZXMgPSBbXTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ub2Rlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGFzdGFyLmNsZWFuTm9kZSh0aGlzLm5vZGVzW2ldKTtcclxuICAgIH1cclxufTtcclxuXHJcbkdyYXBoLnByb3RvdHlwZS5jbGVhbkRpcnR5ID0gZnVuY3Rpb24oKSB7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGlydHlOb2Rlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGFzdGFyLmNsZWFuTm9kZSh0aGlzLmRpcnR5Tm9kZXNbaV0pO1xyXG4gICAgfVxyXG4gICAgdGhpcy5kaXJ0eU5vZGVzID0gW107XHJcbn07XHJcblxyXG5HcmFwaC5wcm90b3R5cGUubWFya0RpcnR5ID0gZnVuY3Rpb24obm9kZSkge1xyXG4gICAgdGhpcy5kaXJ0eU5vZGVzLnB1c2gobm9kZSk7XHJcbn07XHJcblxyXG5HcmFwaC5wcm90b3R5cGUubmVpZ2hib3JzID0gZnVuY3Rpb24obm9kZSkge1xyXG4gICAgdmFyIHJldCA9IFtdLFxyXG4gICAgICAgIHggPSBub2RlLngsXHJcbiAgICAgICAgeSA9IG5vZGUueSxcclxuICAgICAgICBncmlkID0gdGhpcy5ncmlkO1xyXG5cclxuICAgIC8vIFdlc3RcclxuICAgIGlmKGdyaWRbeC0xXSAmJiBncmlkW3gtMV1beV0pIHtcclxuICAgICAgICByZXQucHVzaChncmlkW3gtMV1beV0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEVhc3RcclxuICAgIGlmKGdyaWRbeCsxXSAmJiBncmlkW3grMV1beV0pIHtcclxuICAgICAgICByZXQucHVzaChncmlkW3grMV1beV0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFNvdXRoXHJcbiAgICBpZihncmlkW3hdICYmIGdyaWRbeF1beS0xXSkge1xyXG4gICAgICAgIHJldC5wdXNoKGdyaWRbeF1beS0xXSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTm9ydGhcclxuICAgIGlmKGdyaWRbeF0gJiYgZ3JpZFt4XVt5KzFdKSB7XHJcbiAgICAgICAgcmV0LnB1c2goZ3JpZFt4XVt5KzFdKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5kaWFnb25hbCkge1xyXG4gICAgICAgIC8vIFNvdXRod2VzdFxyXG4gICAgICAgIGlmKGdyaWRbeC0xXSAmJiBncmlkW3gtMV1beS0xXSkge1xyXG4gICAgICAgICAgICByZXQucHVzaChncmlkW3gtMV1beS0xXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBTb3V0aGVhc3RcclxuICAgICAgICBpZihncmlkW3grMV0gJiYgZ3JpZFt4KzFdW3ktMV0pIHtcclxuICAgICAgICAgICAgcmV0LnB1c2goZ3JpZFt4KzFdW3ktMV0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gTm9ydGh3ZXN0XHJcbiAgICAgICAgaWYoZ3JpZFt4LTFdICYmIGdyaWRbeC0xXVt5KzFdKSB7XHJcbiAgICAgICAgICAgIHJldC5wdXNoKGdyaWRbeC0xXVt5KzFdKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIE5vcnRoZWFzdFxyXG4gICAgICAgIGlmKGdyaWRbeCsxXSAmJiBncmlkW3grMV1beSsxXSkge1xyXG4gICAgICAgICAgICByZXQucHVzaChncmlkW3grMV1beSsxXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXQ7XHJcbn07XHJcblxyXG5HcmFwaC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciBncmFwaFN0cmluZyA9IFtdLFxyXG4gICAgICAgIG5vZGVzID0gdGhpcy5ncmlkLCAvLyB3aGVuIHVzaW5nIGdyaWRcclxuICAgICAgICByb3dEZWJ1Zywgcm93LCB5LCBsO1xyXG4gICAgZm9yICh2YXIgeCA9IDAsIGxlbiA9IG5vZGVzLmxlbmd0aDsgeCA8IGxlbjsgeCsrKSB7XHJcbiAgICAgICAgcm93RGVidWcgPSBbXTtcclxuICAgICAgICByb3cgPSBub2Rlc1t4XTtcclxuICAgICAgICBmb3IgKHkgPSAwLCBsID0gcm93Lmxlbmd0aDsgeSA8IGw7IHkrKykge1xyXG4gICAgICAgICAgICByb3dEZWJ1Zy5wdXNoKHJvd1t5XS53ZWlnaHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBncmFwaFN0cmluZy5wdXNoKHJvd0RlYnVnLmpvaW4oJyAnKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZ3JhcGhTdHJpbmcuam9pbignXFxuJyk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBHcmlkTm9kZSh4LCB5LCB3ZWlnaHQpIHtcclxuICAgIHRoaXMueCA9IHg7XHJcbiAgICB0aGlzLnkgPSB5O1xyXG4gICAgdGhpcy53ZWlnaHQgPSB3ZWlnaHQ7XHJcbn1cclxuXHJcbkdyaWROb2RlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuICdbJyArIHRoaXMueCArICcgJyArIHRoaXMueSArICddJztcclxufTtcclxuXHJcbkdyaWROb2RlLnByb3RvdHlwZS5nZXRDb3N0ID0gZnVuY3Rpb24oZnJvbU5laWdoYm9yKSB7XHJcbiAgICAvLyBUYWtlIGRpYWdvbmFsIHdlaWdodCBpbnRvIGNvbnNpZGVyYXRpb24uXHJcbiAgICBpZiAoZnJvbU5laWdoYm9yICYmIGZyb21OZWlnaGJvci54ICE9PSB0aGlzLnggJiYgZnJvbU5laWdoYm9yLnkgIT09IHRoaXMueSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLndlaWdodCAqIDEuNDE0MjE7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy53ZWlnaHQ7XHJcbn07XHJcblxyXG5HcmlkTm9kZS5wcm90b3R5cGUuaXNXYWxsID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy53ZWlnaHQgPT09IDA7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBCaW5hcnlIZWFwKHNjb3JlRnVuY3Rpb24pe1xyXG4gICAgdGhpcy5jb250ZW50ID0gW107XHJcbiAgICB0aGlzLnNjb3JlRnVuY3Rpb24gPSBzY29yZUZ1bmN0aW9uO1xyXG59XHJcblxyXG5CaW5hcnlIZWFwLnByb3RvdHlwZSA9IHtcclxuICAgIHB1c2g6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcclxuICAgICAgICAvLyBBZGQgdGhlIG5ldyBlbGVtZW50IHRvIHRoZSBlbmQgb2YgdGhlIGFycmF5LlxyXG4gICAgICAgIHRoaXMuY29udGVudC5wdXNoKGVsZW1lbnQpO1xyXG5cclxuICAgICAgICAvLyBBbGxvdyBpdCB0byBzaW5rIGRvd24uXHJcbiAgICAgICAgdGhpcy5zaW5rRG93bih0aGlzLmNvbnRlbnQubGVuZ3RoIC0gMSk7XHJcbiAgICB9LFxyXG4gICAgcG9wOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAvLyBTdG9yZSB0aGUgZmlyc3QgZWxlbWVudCBzbyB3ZSBjYW4gcmV0dXJuIGl0IGxhdGVyLlxyXG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmNvbnRlbnRbMF07XHJcbiAgICAgICAgLy8gR2V0IHRoZSBlbGVtZW50IGF0IHRoZSBlbmQgb2YgdGhlIGFycmF5LlxyXG4gICAgICAgIHZhciBlbmQgPSB0aGlzLmNvbnRlbnQucG9wKCk7XHJcbiAgICAgICAgLy8gSWYgdGhlcmUgYXJlIGFueSBlbGVtZW50cyBsZWZ0LCBwdXQgdGhlIGVuZCBlbGVtZW50IGF0IHRoZVxyXG4gICAgICAgIC8vIHN0YXJ0LCBhbmQgbGV0IGl0IGJ1YmJsZSB1cC5cclxuICAgICAgICBpZiAodGhpcy5jb250ZW50Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgdGhpcy5jb250ZW50WzBdID0gZW5kO1xyXG4gICAgICAgICAgICB0aGlzLmJ1YmJsZVVwKDApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfSxcclxuICAgIHJlbW92ZTogZnVuY3Rpb24obm9kZSkge1xyXG4gICAgICAgIHZhciBpID0gdGhpcy5jb250ZW50LmluZGV4T2Yobm9kZSk7XHJcblxyXG4gICAgICAgIC8vIFdoZW4gaXQgaXMgZm91bmQsIHRoZSBwcm9jZXNzIHNlZW4gaW4gJ3BvcCcgaXMgcmVwZWF0ZWRcclxuICAgICAgICAvLyB0byBmaWxsIHVwIHRoZSBob2xlLlxyXG4gICAgICAgIHZhciBlbmQgPSB0aGlzLmNvbnRlbnQucG9wKCk7XHJcblxyXG4gICAgICAgIGlmIChpICE9PSB0aGlzLmNvbnRlbnQubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRbaV0gPSBlbmQ7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5zY29yZUZ1bmN0aW9uKGVuZCkgPCB0aGlzLnNjb3JlRnVuY3Rpb24obm9kZSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2lua0Rvd24oaSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJ1YmJsZVVwKGkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHNpemU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQubGVuZ3RoO1xyXG4gICAgfSxcclxuICAgIHJlc2NvcmVFbGVtZW50OiBmdW5jdGlvbihub2RlKSB7XHJcbiAgICAgICAgdGhpcy5zaW5rRG93bih0aGlzLmNvbnRlbnQuaW5kZXhPZihub2RlKSk7XHJcbiAgICB9LFxyXG4gICAgc2lua0Rvd246IGZ1bmN0aW9uKG4pIHtcclxuICAgICAgICAvLyBGZXRjaCB0aGUgZWxlbWVudCB0aGF0IGhhcyB0byBiZSBzdW5rLlxyXG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5jb250ZW50W25dO1xyXG5cclxuICAgICAgICAvLyBXaGVuIGF0IDAsIGFuIGVsZW1lbnQgY2FuIG5vdCBzaW5rIGFueSBmdXJ0aGVyLlxyXG4gICAgICAgIHdoaWxlIChuID4gMCkge1xyXG5cclxuICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgcGFyZW50IGVsZW1lbnQncyBpbmRleCwgYW5kIGZldGNoIGl0LlxyXG4gICAgICAgICAgICB2YXIgcGFyZW50TiA9ICgobiArIDEpID4+IDEpIC0gMSwgcGFyZW50ID0gdGhpcy5jb250ZW50W3BhcmVudE5dOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcclxuICAgICAgICAgICAgLy8gU3dhcCB0aGUgZWxlbWVudHMgaWYgdGhlIHBhcmVudCBpcyBncmVhdGVyLlxyXG4gICAgICAgICAgICBpZiAodGhpcy5zY29yZUZ1bmN0aW9uKGVsZW1lbnQpIDwgdGhpcy5zY29yZUZ1bmN0aW9uKHBhcmVudCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udGVudFtwYXJlbnROXSA9IGVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnRbbl0gPSBwYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgJ24nIHRvIGNvbnRpbnVlIGF0IHRoZSBuZXcgcG9zaXRpb24uXHJcbiAgICAgICAgICAgICAgICBuID0gcGFyZW50TjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBGb3VuZCBhIHBhcmVudCB0aGF0IGlzIGxlc3MsIG5vIG5lZWQgdG8gc2luayBhbnkgZnVydGhlci5cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBidWJibGVVcDogZnVuY3Rpb24obikge1xyXG4gICAgICAgIC8vIExvb2sgdXAgdGhlIHRhcmdldCBlbGVtZW50IGFuZCBpdHMgc2NvcmUuXHJcbiAgICAgICAgdmFyIGxlbmd0aCA9IHRoaXMuY29udGVudC5sZW5ndGgsXHJcbiAgICAgICAgICAgIGVsZW1lbnQgPSB0aGlzLmNvbnRlbnRbbl0sXHJcbiAgICAgICAgICAgIGVsZW1TY29yZSA9IHRoaXMuc2NvcmVGdW5jdGlvbihlbGVtZW50KTtcclxuXHJcbiAgICAgICAgd2hpbGUodHJ1ZSkge1xyXG4gICAgICAgICAgICAvLyBDb21wdXRlIHRoZSBpbmRpY2VzIG9mIHRoZSBjaGlsZCBlbGVtZW50cy5cclxuICAgICAgICAgICAgdmFyIGNoaWxkMk4gPSAobiArIDEpIDw8IDEsIGNoaWxkMU4gPSBjaGlsZDJOIC0gMTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXHJcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdXNlZCB0byBzdG9yZSB0aGUgbmV3IHBvc2l0aW9uIG9mIHRoZSBlbGVtZW50LCBpZiBhbnkuXHJcbiAgICAgICAgICAgIHZhciBzd2FwID0gbnVsbCxcclxuICAgICAgICAgICAgICAgIGNoaWxkMVNjb3JlO1xyXG4gICAgICAgICAgICAvLyBJZiB0aGUgZmlyc3QgY2hpbGQgZXhpc3RzIChpcyBpbnNpZGUgdGhlIGFycmF5KS4uLlxyXG4gICAgICAgICAgICBpZiAoY2hpbGQxTiA8IGxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgLy8gTG9vayBpdCB1cCBhbmQgY29tcHV0ZSBpdHMgc2NvcmUuXHJcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQxID0gdGhpcy5jb250ZW50W2NoaWxkMU5dO1xyXG4gICAgICAgICAgICAgICAgY2hpbGQxU2NvcmUgPSB0aGlzLnNjb3JlRnVuY3Rpb24oY2hpbGQxKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgc2NvcmUgaXMgbGVzcyB0aGFuIG91ciBlbGVtZW50J3MsIHdlIG5lZWQgdG8gc3dhcC5cclxuICAgICAgICAgICAgICAgIGlmIChjaGlsZDFTY29yZSA8IGVsZW1TY29yZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgc3dhcCA9IGNoaWxkMU47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIERvIHRoZSBzYW1lIGNoZWNrcyBmb3IgdGhlIG90aGVyIGNoaWxkLlxyXG4gICAgICAgICAgICBpZiAoY2hpbGQyTiA8IGxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkMiA9IHRoaXMuY29udGVudFtjaGlsZDJOXSxcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZDJTY29yZSA9IHRoaXMuc2NvcmVGdW5jdGlvbihjaGlsZDIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkMlNjb3JlIDwgKHN3YXAgPT09IG51bGwgPyBlbGVtU2NvcmUgOiBjaGlsZDFTY29yZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBzd2FwID0gY2hpbGQyTjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gSWYgdGhlIGVsZW1lbnQgbmVlZHMgdG8gYmUgbW92ZWQsIHN3YXAgaXQsIGFuZCBjb250aW51ZS5cclxuICAgICAgICAgICAgaWYgKHN3YXAgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udGVudFtuXSA9IHRoaXMuY29udGVudFtzd2FwXTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udGVudFtzd2FwXSA9IGVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICBuID0gc3dhcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIHdlIGFyZSBkb25lLlxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxucmV0dXJuIHtcclxuICAgIGFzdGFyOiBhc3RhcixcclxuICAgIEdyYXBoOiBHcmFwaFxyXG59O1xyXG5cclxufSk7XHJcbiIsIid1c2Ugc3RyaWN0JztcclxuXHJcbi8qKlxyXG4qIEBhdXRob3IgICAgICAgSmVyZW15IERvd2VsbCA8amVyZW15QGNvZGV2aW5za3kuY29tPlxyXG4qIEBsaWNlbnNlICAgICAge0BsaW5rIGh0dHA6Ly93d3cud3RmcGwubmV0L3R4dC9jb3B5aW5nL3xXVEZQTH1cclxuKi9cclxuXHJcbi8qKlxyXG4qIENyZWF0ZXMgYSBuZXcgYEp1aWN5YCBvYmplY3QuXHJcbipcclxuKiBAY2xhc3MgUGhhc2VyLlBsdWdpbi5KdWljeVxyXG4qIEBjb25zdHJ1Y3RvclxyXG4qXHJcbiogQHBhcmFtIHtQaGFzZXIuR2FtZX0gZ2FtZSBDdXJyZW50IGdhbWUgaW5zdGFuY2UuXHJcbiovXHJcblBoYXNlci5QbHVnaW4uSnVpY3kgPSBmdW5jdGlvbiAoZ2FtZSkge1xyXG5cclxuICBQaGFzZXIuUGx1Z2luLmNhbGwodGhpcywgZ2FtZSk7XHJcblxyXG4gIC8qKlxyXG4gICogQHByb3BlcnR5IHtQaGFzZXIuUmVjdGFuZ2xlfSBfYm91bmRzQ2FjaGUgLSBBIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCB3b3JsZCBib3VuZHMuXHJcbiAgKiBAcHJpdmF0ZVxyXG4gICovXHJcbiAgdGhpcy5fYm91bmRzQ2FjaGUgPSBQaGFzZXIuVXRpbHMuZXh0ZW5kKGZhbHNlLCB7fSwgdGhpcy5nYW1lLndvcmxkLmJvdW5kcyk7XHJcblxyXG4gIC8qKlxyXG4gICogQHByb3BlcnR5IHtudW1iZXJ9IF9zaGFrZVdvcmxkTWF4IC0gVGhlIG1heGltdW0gd29ybGQgc2hha2UgcmFkaXVzXHJcbiAgKiBAcHJpdmF0ZVxyXG4gICovXHJcbiAgdGhpcy5fc2hha2VXb3JsZE1heCA9IDIwO1xyXG5cclxuICAvKipcclxuICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBfc2hha2VXb3JsZFRpbWUgLSBUaGUgbWF4aW11bSB3b3JsZCBzaGFrZSB0aW1lXHJcbiAgKiBAcHJpdmF0ZVxyXG4gICovXHJcbiAgdGhpcy5fc2hha2VXb3JsZFRpbWUgPSAwO1xyXG5cclxuICAvKipcclxuICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBfdHJhaWxDb3VudGVyIC0gQSBjb3VudCBvZiBob3cgbWFueSB0cmFpbHMgd2UncmUgdHJhY2tpbmdcclxuICAqIEBwcml2YXRlXHJcbiAgKi8gIFxyXG4gIHRoaXMuX3RyYWlsQ291bnRlciA9IDA7XHJcblxyXG4gIC8qKlxyXG4gICogQHByb3BlcnR5IHtvYmplY3R9IF9vdmVyU2NhbGVzIC0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgb3ZlcnNjYWxpbmcgY29uZmlndXJhdGlvbnNcclxuICAqIEBwcml2YXRlXHJcbiAgKi8gIFxyXG4gIHRoaXMuX292ZXJTY2FsZXMgPSB7fTtcclxuXHJcbiAgLyoqXHJcbiAgKiBAcHJvcGVydHkge251bWJlcn0gX292ZXJTY2FsZXNDb3VudGVyIC0gQSBjb3VudCBvZiBob3cgbWFueSBvdmVyU2NhbGVzIHdlJ3JlIHRyYWNraW5nXHJcbiAgKiBAcHJpdmF0ZVxyXG4gICovICBcclxuICB0aGlzLl9vdmVyU2NhbGVzQ291bnRlciA9IDA7XHJcbn07XHJcblxyXG5pZih0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xyXG4gIG1vZHVsZS5leHBvcnRzID0gUGhhc2VyLlBsdWdpbi5KdWljeTtcclxufVxyXG5cclxuUGhhc2VyLlBsdWdpbi5KdWljeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFBoYXNlci5QbHVnaW4ucHJvdG90eXBlKTtcclxuUGhhc2VyLlBsdWdpbi5KdWljeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQaGFzZXIuUGx1Z2luLkp1aWN5O1xyXG5cclxuLyoqXHJcbiogQ3JlYXRlcyBhIG5ldyBgSnVpY3kuU2NyZWVuRmxhc2hgIG9iamVjdC5cclxuKlxyXG4qIEBjbGFzcyBQaGFzZXIuUGx1Z2luLkp1aWN5LlNjcmVlbkZsYXNoXHJcbiogQGNvbnN0cnVjdG9yXHJcbipcclxuKiBAcGFyYW0ge1BoYXNlci5HYW1lfSBnYW1lIC0gIEN1cnJlbnQgZ2FtZSBpbnN0YW5jZS5cclxuKiBAcGFyYW0ge3N0cmluZ30gY29sb3I9J3doaXRlJyAtIFRoZSBjb2xvciB0byBmbGFzaCB0aGUgc2NyZWVuLlxyXG4qIEBtZW1iZXJvZiBQaGFzZXIuUGx1Z2luLkp1aWN5XHJcbiovXHJcblBoYXNlci5QbHVnaW4uSnVpY3kuU2NyZWVuRmxhc2ggPSBmdW5jdGlvbihnYW1lLCBjb2xvcikge1xyXG4gIGNvbG9yID0gY29sb3IgfHwgJ3doaXRlJztcclxuICB2YXIgYm1kID0gZ2FtZS5hZGQuYml0bWFwRGF0YShnYW1lLndpZHRoLCBnYW1lLmhlaWdodCk7XHJcbiAgYm1kLmN0eC5maWxsU3R5bGUgPSBjb2xvcjtcclxuICBibWQuY3R4LmZpbGxSZWN0KDAsMCwgZ2FtZS53aWR0aCwgZ2FtZS5oZWlnaHQpO1xyXG5cclxuICBQaGFzZXIuU3ByaXRlLmNhbGwodGhpcywgZ2FtZSwgMCwwLCBibWQpO1xyXG4gIHRoaXMuYWxwaGEgPSAwO1xyXG59O1xyXG5cclxuUGhhc2VyLlBsdWdpbi5KdWljeS5TY3JlZW5GbGFzaC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFBoYXNlci5TcHJpdGUucHJvdG90eXBlKTtcclxuUGhhc2VyLlBsdWdpbi5KdWljeS5TY3JlZW5GbGFzaC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQaGFzZXIuUGx1Z2luLkp1aWN5LlNjcmVlbkZsYXNoO1xyXG5cclxuXHJcbi8qXHJcbiogRmxhc2hlcyB0aGUgc2NyZWVuXHJcbipcclxuKiBAcGFyYW0ge251bWJlcn0gW21heEFscGhhPTFdIC0gVGhlIG1heGltdW0gYWxwaGEgdG8gZmxhc2ggdGhlIHNjcmVlbiB0b1xyXG4qIEBwYXJhbSB7bnVtYmVyfSBbZHVyYXRpb249MTAwXSAtIFRoZSBkdXJhdGlvbiBvZiB0aGUgZmxhc2ggaW4gbWlsbGlzZWNvbmRzXHJcbiogQG1ldGhvZCBQaGFzZXIuUGx1Z2luLkp1aWN5LlNjcmVlbkZsYXNoLnByb3RvdHlwZS5mbGFzaFxyXG4qIEBtZW1iZXJvZiBQaGFzZXIuUGx1Z2luLkp1aWN5LlNjcmVlbkZsYXNoXHJcbiovXHJcblBoYXNlci5QbHVnaW4uSnVpY3kuU2NyZWVuRmxhc2gucHJvdG90eXBlLmZsYXNoID0gZnVuY3Rpb24obWF4QWxwaGEsIGR1cmF0aW9uKSB7XHJcbiAgbWF4QWxwaGEgPSBtYXhBbHBoYSB8fCAxO1xyXG4gIGR1cmF0aW9uID0gZHVyYXRpb24gfHwgMTAwO1xyXG4gIHZhciBmbGFzaFR3ZWVuID0gdGhpcy5nYW1lLmFkZC50d2Vlbih0aGlzKS50byh7YWxwaGE6IG1heEFscGhhfSwgMTAwLCBQaGFzZXIuRWFzaW5nLkJvdW5jZS5Jbk91dCwgdHJ1ZSwwLCAwLCB0cnVlKTtcclxuICBmbGFzaFR3ZWVuLm9uQ29tcGxldGUuYWRkKGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5hbHBoYSA9IDA7XHJcbiAgfSwgdGhpcyk7XHJcbn07XHJcblxyXG4vKipcclxuKiBDcmVhdGVzIGEgbmV3IGBKdWljeS5UcmFpbGAgb2JqZWN0LlxyXG4qXHJcbiogQGNsYXNzIFBoYXNlci5QbHVnaW4uSnVpY3kuVHJhaWxcclxuKiBAY29uc3RydWN0b3JcclxuKlxyXG4qIEBwYXJhbSB7UGhhc2VyLkdhbWV9IGdhbWUgLSAgQ3VycmVudCBnYW1lIGluc3RhbmNlLlxyXG4qIEBwYXJhbSB7bnVtYmVyfSBbdHJhaWxMZW5ndGg9MTAwXSAtIFRoZSBsZW5ndGggb2YgdGhlIHRyYWlsXHJcbiogQHBhcmFtIHtudW1iZXJ9IFtjb2xvcj0weEZGRkZGRl0gLSBUaGUgY29sb3Igb2YgdGhlIHRyYWlsXHJcbiogQG1lbWJlcm9mIFBoYXNlci5QbHVnaW4uSnVpY3lcclxuKi9cclxuUGhhc2VyLlBsdWdpbi5KdWljeS5UcmFpbCA9IGZ1bmN0aW9uKGdhbWUsIHRyYWlsTGVuZ3RoLCBjb2xvcikge1xyXG4gIFBoYXNlci5HcmFwaGljcy5jYWxsKHRoaXMsIGdhbWUsIDAsMCk7XHJcbiAgXHJcbiAgLyoqXHJcbiAgKiBAcHJvcGVydHkge1BoYXNlci5TcHJpdGV9IHRhcmdldCAtIFRoZSB0YXJnZXQgc3ByaXRlIHdob3NlIG1vdmVtZW50IHdlIHdhbnQgdG8gY3JlYXRlIHRoZSB0cmFpbCBmcm9tXHJcbiAgKi9cclxuICB0aGlzLnRhcmdldCA9IG51bGw7XHJcbiAgLyoqXHJcbiAgKiBAcHJvcGVydHkge251bWJlcn0gdHJhaWxMZW5ndGggLSBUaGUgbnVtYmVyIG9mIHNlZ21lbnRzIHRvIHVzZSB0byBjcmVhdGUgdGhlIHRyYWlsXHJcbiAgKi9cclxuICB0aGlzLnRyYWlsTGVuZ3RoID0gdHJhaWxMZW5ndGggfHwgMTAwO1xyXG4gIC8qKlxyXG4gICogQHByb3BlcnR5IHtudW1iZXJ9IHRyYWlsV2lkdGggLSBUaGUgd2lkdGggb2YgdGhlIHRyYWlsXHJcbiAgKi9cclxuICB0aGlzLnRyYWlsV2lkdGggPSAxNS4wO1xyXG5cclxuICAvKipcclxuICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gdHJhaWxTY2FsZSAtIFdoZXRoZXIgb3Igbm90IHRvIHRhcGVyIHRoZSB0cmFpbCB0b3dhcmRzIHRoZSBlbmRcclxuICAqL1xyXG4gIHRoaXMudHJhaWxTY2FsaW5nID0gZmFsc2U7XHJcblxyXG4gIC8qKlxyXG4gICogQHByb3BlcnR5IHtQaGFzZXIuU3ByaXRlfSB0cmFpbENvbG9yIC0gVGhlIGNvbG9yIG9mIHRoZSB0cmFpbFxyXG4gICovXHJcbiAgdGhpcy50cmFpbENvbG9yID0gY29sb3IgfHwgMHhGRkZGRkY7XHJcbiAgXHJcbiAgLyoqXHJcbiAgKiBAcHJvcGVydHkge0FycmF5PFBoYXNlci5Qb2ludD59IF9zZWdtZW50cyAtIEEgaGlzdG9yaWNhbCBjb2xsZWN0aW9uIG9mIHRoZSBwcmV2aW91cyBwb3NpdGlvbiBvZiB0aGUgdGFyZ2V0XHJcbiAgKiBAcHJpdmF0ZVxyXG4gICovXHJcbiAgdGhpcy5fc2VnbWVudHMgPSBbXTtcclxuICAvKipcclxuICAqIEBwcm9wZXJ0eSB7QXJyYXk8bnVtYmVyPn0gX3ZlcnRzIC0gQSBjb2xsZWN0aW9uIG9mIHZlcnRpY2VzIGNyZWF0ZWQgZnJvbSBfc2VnbWVudHNcclxuICAqIEBwcml2YXRlXHJcbiAgKi9cclxuICB0aGlzLl92ZXJ0cyA9IFtdO1xyXG4gIC8qKlxyXG4gICogQHByb3BlcnR5IHtBcnJheTxQaGFzZXIuUG9pbnQ+fSBfc2VnbWVudHMgLSBBIGNvbGxlY3Rpb24gb2YgaW5kaWNlcyBjcmVhdGVkIGZyb20gX3ZlcnRzXHJcbiAgKiBAcHJpdmF0ZVxyXG4gICovXHJcbiAgdGhpcy5faW5kaWNlcyA9IFtdO1xyXG5cclxufTtcclxuXHJcblBoYXNlci5QbHVnaW4uSnVpY3kuVHJhaWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShQaGFzZXIuR3JhcGhpY3MucHJvdG90eXBlKTtcclxuUGhhc2VyLlBsdWdpbi5KdWljeS5UcmFpbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQaGFzZXIuUGx1Z2luLkp1aWN5LlRyYWlsO1xyXG5cclxuLyoqXHJcbiogVXBkYXRlcyB0aGUgVHJhaWwgaWYgYSB0YXJnZXQgaXMgc2V0XHJcbipcclxuKiBAbWV0aG9kIFBoYXNlci5QbHVnaW4uSnVpY3kuVHJhaWwjdXBkYXRlXHJcbiogQG1lbWJlcm9mIFBoYXNlci5QbHVnaW4uSnVpY3kuVHJhaWxcclxuKi9cclxuXHJcblBoYXNlci5QbHVnaW4uSnVpY3kuVHJhaWwucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gIGlmKHRoaXMudGFyZ2V0KSB7XHJcbiAgICB0aGlzLnggPSB0aGlzLnRhcmdldC54O1xyXG4gICAgdGhpcy55ID0gdGhpcy50YXJnZXQueTtcclxuICAgIHRoaXMuYWRkU2VnbWVudCh0aGlzLnRhcmdldC54LCB0aGlzLnRhcmdldC55KTtcclxuICAgIHRoaXMucmVkcmF3U2VnbWVudHModGhpcy50YXJnZXQueCwgdGhpcy50YXJnZXQueSk7XHJcbiAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiogQWRkcyBhIHNlZ21lbnQgdG8gdGhlIHNlZ21lbnRzIGxpc3QgYW5kIGN1bGxzIHRoZSBsaXN0IGlmIGl0IGlzIHRvbyBsb25nXHJcbiogXHJcbiogQHBhcmFtIHtudW1iZXJ9IFt4XSAtIFRoZSB4IHBvc2l0aW9uIG9mIHRoZSBwb2ludFxyXG4qIEBwYXJhbSB7bnVtYmVyfSBbeV0gLSBUaGUgeSBwb3NpdGlvbiBvZiB0aGUgcG9pbnRcclxuKiBcclxuKiBAbWV0aG9kIFBoYXNlci5QbHVnaW4uSnVpY3kuVHJhaWwjYWRkU2VnbWVudFxyXG4qIEBtZW1iZXJvZiBQaGFzZXIuUGx1Z2luLkp1aWN5LlRyYWlsXHJcbiovXHJcblBoYXNlci5QbHVnaW4uSnVpY3kuVHJhaWwucHJvdG90eXBlLmFkZFNlZ21lbnQgPSBmdW5jdGlvbih4LCB5KSB7XHJcbiAgdmFyIHNlZ21lbnQ7XHJcblxyXG4gIHdoaWxlKHRoaXMuX3NlZ21lbnRzLmxlbmd0aCA+IHRoaXMudHJhaWxMZW5ndGgpIHtcclxuICAgIHNlZ21lbnQgPSB0aGlzLl9zZWdtZW50cy5zaGlmdCgpO1xyXG4gIH1cclxuICBpZighc2VnbWVudCkge1xyXG4gICAgc2VnbWVudCA9IG5ldyBQaGFzZXIuUG9pbnQoKTtcclxuICB9XHJcblxyXG4gIHNlZ21lbnQueCA9IHg7XHJcbiAgc2VnbWVudC55ID0geTtcclxuXHJcbiAgdGhpcy5fc2VnbWVudHMucHVzaChzZWdtZW50KTtcclxufTtcclxuXHJcblxyXG4vKipcclxuKiBDcmVhdGVzIGFuZCBkcmF3cyB0aGUgdHJpYW5nbGUgdHJhaWwgZnJvbSBzZWdtZW50c1xyXG4qIFxyXG4qIEBwYXJhbSB7bnVtYmVyfSBbb2Zmc2V0WF0gLSBUaGUgeCBwb3NpdGlvbiBvZiB0aGUgb2JqZWN0XHJcbiogQHBhcmFtIHtudW1iZXJ9IFtvZmZzZXRZXSAtIFRoZSB5IHBvc2l0aW9uIG9mIHRoZSBvYmplY3RcclxuKiBcclxuKiBAbWV0aG9kIFBoYXNlci5QbHVnaW4uSnVpY3kuVHJhaWwjcmVkcmF3U2VnbWVudFxyXG4qIEBtZW1iZXJvZiBQaGFzZXIuUGx1Z2luLkp1aWN5LlRyYWlsXHJcbiovXHJcblBoYXNlci5QbHVnaW4uSnVpY3kuVHJhaWwucHJvdG90eXBlLnJlZHJhd1NlZ21lbnRzID0gZnVuY3Rpb24ob2Zmc2V0WCwgb2Zmc2V0WSkge1xyXG4gIHRoaXMuY2xlYXIoKTtcclxuICB2YXIgczEsIC8vIGN1cnJlbnQgc2VnbWVudFxyXG4gICAgICBzMiwgLy8gcHJldmlvdXMgc2VnbWVudFxyXG4gICAgICB2ZXJ0SW5kZXggPSAwLCAvLyBrZWVwcyB0cmFjayBvZiB3aGljaCB2ZXJ0ZXggaW5kZXggd2UncmUgYXRcclxuICAgICAgb2Zmc2V0LCAvLyB0ZW1wb3Jhcnkgc3RvcmFnZSBmb3IgYW1vdW50IHRvIGV4dGVuZCBsaW5lIG91dHdhcmRzLCBiaWdnZXIgPSB3aWRlclxyXG4gICAgICBhbmcsIC8vdGVtcG9yYXJ5IHN0b3JhZ2Ugb2YgdGhlIGludGVyLXNlZ21lbnQgYW5nbGVzXHJcbiAgICAgIHNpbiA9IDAsIC8vIGFzIGFib3ZlXHJcbiAgICAgIGNvcyA9IDA7IC8vIGFnYWluIGFzIGFib3ZlXHJcblxyXG4gIC8vIGZpcnN0IHdlIG1ha2Ugc3VyZSB0aGF0IHRoZSB2ZXJ0aWNlIGxpc3QgaXMgdGhlIHNhbWUgbGVuZ3RoIGFzIHdlIHdlIHdhbnRcclxuICAvLyBlYWNoIHNlZ21lbnQgKGV4Y2VwdCB0aGUgZmlyc3QpIHdpbGwgY3JlYXRlIHRvIHZlcnRpY2VzIHdpdGggdHdvIHZhbHVlcyBlYWNoXHJcbiAgaWYgKHRoaXMuX3ZlcnRzLmxlbmd0aCAhPT0gKHRoaXMuX3NlZ21lbnRzLmxlbmd0aCAtMSkgKiA0KSB7XHJcbiAgICAvLyBpZiBpdCdzIG5vdCBjb3JyZWN0LCB3ZSBjbGVhciB0aGUgZW50aXJlIGxpc3RcclxuICAgIHRoaXMuX3ZlcnRzID0gW107XHJcbiAgfVxyXG5cclxuICAvLyBub3cgd2UgbG9vcCBvdmVyIGFsbCB0aGUgc2VnbWVudHMsIHRoZSBsaXN0IGhhcyB0aGUgXCJ5b3VuZ2VzdFwiIHNlZ21lbnQgYXQgdGhlIGVuZFxyXG4gIHZhciBwcmV2QW5nID0gMDsgLy8ganNoaW50IGlnbm9yZTpsaW5lXHJcbiAgXHJcbiAgZm9yKHZhciBqID0gMDsgaiA8IHRoaXMuX3NlZ21lbnRzLmxlbmd0aDsgKytqKSB7XHJcbiAgICAvLyBzdG9yZSB0aGUgYWN0aXZlIHNlZ21lbnQgZm9yIGNvbnZlbmllbmNlXHJcbiAgICBzMSA9IHRoaXMuX3NlZ21lbnRzW2pdO1xyXG5cclxuICAgIC8vIGlmIHRoZXJlJ3MgYSBwcmV2aW91cyBzZWdtZW50LCB0aW1lIHRvIGRvIHNvbWUgbWF0aFxyXG4gICAgaWYoczIpIHtcclxuICAgICAgLy8gd2UgY2FsY3VsYXRlIHRoZSBhbmdsZSBiZXR3ZWVuIHRoZSB0d28gc2VnbWVudHNcclxuICAgICAgLy8gdGhlIHJlc3VsdCB3aWxsIGJlIGluIHJhZGlhbnMsIHNvIGFkZGluZyBoYWxmIG9mIHBpIHdpbGwgXCJ0dXJuXCIgdGhlIGFuZ2xlIDkwIGRlZ3JlZXNcclxuICAgICAgLy8gdGhhdCBtZWFucyB3ZSBjYW4gdXNlIHRoZSBzaW4gYW5kIGNvcyB2YWx1ZXMgdG8gXCJleHBhbmRcIiB0aGUgbGluZSBvdXR3YXJkc1xyXG4gICAgICBhbmcgPSBNYXRoLmF0YW4yKHMxLnkgLSBzMi55LCBzMS54IC0gczIueCkgKyBNYXRoLlBJIC8gMjtcclxuICAgICAgc2luID0gTWF0aC5zaW4oYW5nKTtcclxuICAgICAgY29zID0gTWF0aC5jb3MoYW5nKTtcclxuXHJcbiAgICAgIC8vIG5vdyBpdCdzIHRpbWUgdG8gY3JlYXQgZXRoZSB0d28gdmVydGljZXMgdGhhdCB3aWxsIHJlcHJlc2VudCB0aGlzIHBhaXIgb2Ygc2VnbWVudHNcclxuICAgICAgLy8gdXNpbmcgYSBsb29wIGhlcmUgaXMgcHJvYmFibHkgYSBiaXQgb3ZlcmtpbGwgc2luY2UgaXQncyBvbmx5IHR3byBpdGVyYXRpb25zXHJcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCAyOyArK2kpIHtcclxuICAgICAgICAvLyB0aGlzIG1ha2VzIHRoZSBmaXJzdCBzZWdtZW50IHN0YW5kIG91dCB0byB0aGUgXCJsZWZ0XCIgb2YgdGhlIGxpbmVcclxuICAgICAgICAvLyBhbm5kIHRoZSBzZWNvbmQgdG8gdGhlIHJpZ2h0LCBjaGFuZ2luZyB0aGF0IG1hZ2ljIG51bWJlciBhdCB0aGUgZW5kIHdpbGwgYWx0aGVyIHRoZSBsaW5lIHdpZHRoXHJcbiAgICAgICAgb2Zmc2V0ID0gKCAtMC41ICsgaSAvIDEpICogdGhpcy50cmFpbFdpZHRoO1xyXG5cclxuICAgICAgICAvLyBpZiB0cmFpbCBzY2FsZSBlZmZlY3QgaXMgZW5hYmxlZCwgd2Ugc2NhbGUgZG93biB0aGUgb2Zmc2V0IGFzIHdlIG1vdmUgZG93biB0aGUgbGlzdFxyXG4gICAgICAgIGlmKHRoaXMudHJhaWxTY2FsaW5nKSB7XHJcbiAgICAgICAgICBvZmZzZXQgKj0gaiAvIHRoaXMuX3NlZ21lbnRzLmxlbmd0aDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGZpbmFsbHkgd2UgcHV0IHRvIHZhbHVlcyBpbiB0aGUgdmVydCBsaXN0XHJcbiAgICAgICAgLy8gdXNpbmcgdGhlIHNlZ21lbnQgY29vcmRpbmF0ZXMgYXMgYSBiYXNlIHdlIGFkZCB0aGUgXCJleHRlbmRlZFwiIHBvaW50XHJcbiAgICAgICAgLy8gb2Zmc2V0WCBhbmQgb2Zmc2V0WSBhcmUgdXNlZCBoZXIgdG8gbW92ZSB0aGUgZW50aXJlIHRyYWlsXHJcbiAgICAgICAgdGhpcy5fdmVydHNbdmVydEluZGV4KytdID0gczEueCArIGNvcyAqIG9mZnNldCAtIG9mZnNldFg7XHJcbiAgICAgICAgdGhpcy5fdmVydHNbdmVydEluZGV4KytdID0gczEueSArIHNpbiAqIG9mZnNldCAtIG9mZnNldFk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIGZpbmFsbHkgc3RvcmUgdGhlIGN1cnJlbnQgc2VnbWVudCBhcyB0aGUgcHJldmlvdXMgc2VnbWVudCBhbmQgZ28gZm9yIGFub3RoZXIgcm91bmRcclxuICAgIHMyID0gczEuY29weVRvKHt9KTtcclxuICB9XHJcbiAgLy8gd2UgbmVlZCBhdCBsZWFzdCBmb3VyIHZlcnRpY2VzIHRvIGRyYXcgc29tZXRoaW5nXHJcbiAgaWYodGhpcy5fdmVydHMubGVuZ3RoID49IDgpIHtcclxuICAgIC8vIG5vdywgd2UgaGF2ZSBhIHRyaWFuZ2xlIFwic3RyaXBcIiwgYnV0IGZsYXNoIGNhbid0IGRyYXcgdGhhdCB3aXRob3V0IFxyXG4gICAgLy8gaW5zdHJ1Y3Rpb25zIGZvciB3aGljaCB2ZXJ0aWNlcyB0byBjb25uZWN0LCBzbyBpdCdzIHRpbWUgdG8gbWFrZSB0aG9zZVxyXG4gICAgXHJcbiAgICAvLyBoZXJlLCB3ZSBsb29wIG92ZXIgYWxsIHRoZSB2ZXJ0aWNlcyBhbmQgcGFpciB0aGVtIHRvZ2V0aGVyIGluIHRyaWFuZ2xlc1xyXG4gICAgLy8gZWFjaCBncm91cCBvZiBmb3VyIHZlcnRpY2VzIGZvcm1zIHR3byB0cmlhbmdsZXNcclxuICAgIGZvcih2YXIgayA9IDA7IGsgPCB0aGlzLl92ZXJ0cy5sZW5ndGg7IGsrKykge1xyXG4gICAgICB0aGlzLl9pbmRpY2VzW2sgKiA2ICsgMF0gPSBrICogMiArIDA7XHJcbiAgICAgIHRoaXMuX2luZGljZXNbayAqIDYgKyAxXSA9IGsgKiAyICsgMTtcclxuICAgICAgdGhpcy5faW5kaWNlc1trICogNiArIDJdID0gayAqIDIgKyAyO1xyXG4gICAgICB0aGlzLl9pbmRpY2VzW2sgKiA2ICsgM10gPSBrICogMiArIDE7XHJcbiAgICAgIHRoaXMuX2luZGljZXNbayAqIDYgKyA0XSA9IGsgKiAyICsgMjtcclxuICAgICAgdGhpcy5faW5kaWNlc1trICogNiArIDVdID0gayAqIDIgKyAzO1xyXG4gICAgfVxyXG4gICAgdGhpcy5iZWdpbkZpbGwodGhpcy50cmFpbENvbG9yKTtcclxuICAgIHRoaXMuZHJhd1RyaWFuZ2xlcyh0aGlzLl92ZXJ0cywgdGhpcy5faW5kaWNlcyk7XHJcbiAgICB0aGlzLmVuZEZpbGwoKTtcclxuICAgIFxyXG4gIH1cclxufTtcclxuXHJcblBoYXNlci5QbHVnaW4uSnVpY3kucHJvdG90eXBlLnNoYWtlID0gZnVuY3Rpb24gKGR1cmF0aW9uLCBzdHJlbmd0aCkge1xyXG4gIGlmICh0aGlzLmdhbWUuY2FtZXJhLnRhcmdldCAhPT0gbnVsbCkge1xyXG4gICAgIHRoaXMuY2FtZXJhVGFyZ2V0ID0gdGhpcy5nYW1lLmNhbWVyYS50YXJnZXQ7XHJcbiAgICAgdGhpcy5nYW1lLmNhbWVyYS51bmZvbGxvdygpO1xyXG4gIH1cclxuICB0aGlzLl9zaGFrZVdvcmxkVGltZSA9IGR1cmF0aW9uIHx8IDIwO1xyXG4gIHRoaXMuX3NoYWtlV29ybGRNYXggPSBzdHJlbmd0aCB8fCAyMDtcclxufTtcclxuXHJcblBoYXNlci5QbHVnaW4uSnVpY3kucHJvdG90eXBlLmNyZWF0ZVNjcmVlbkZsYXNoID0gZnVuY3Rpb24oY29sb3IpIHtcclxuICAgIHJldHVybiBuZXcgUGhhc2VyLlBsdWdpbi5KdWljeS5TY3JlZW5GbGFzaCh0aGlzLmdhbWUsIGNvbG9yKTtcclxufTtcclxuXHJcblxyXG5QaGFzZXIuUGx1Z2luLkp1aWN5LnByb3RvdHlwZS5jcmVhdGVUcmFpbCA9IGZ1bmN0aW9uKGxlbmd0aCwgY29sb3IpIHtcclxuICByZXR1cm4gbmV3IFBoYXNlci5QbHVnaW4uSnVpY3kuVHJhaWwodGhpcy5nYW1lLCBsZW5ndGgsIGNvbG9yKTtcclxufTtcclxuXHJcblBoYXNlci5QbHVnaW4uSnVpY3kucHJvdG90eXBlLm92ZXJTY2FsZSA9IGZ1bmN0aW9uKG9iamVjdCwgc2NhbGUsIGluaXRpYWxTY2FsZSkge1xyXG4gIHNjYWxlID0gc2NhbGUgfHwgMS41O1xyXG4gIHZhciBpZCA9IHRoaXMuX292ZXJTY2FsZXNDb3VudGVyKys7XHJcbiAgaW5pdGlhbFNjYWxlID0gaW5pdGlhbFNjYWxlIHx8IG5ldyBQaGFzZXIuUG9pbnQoMSwxKTtcclxuICB2YXIgc2NhbGVPYmogPSB0aGlzLl9vdmVyU2NhbGVzW2lkXTtcclxuICBpZighc2NhbGVPYmopIHtcclxuICAgIHNjYWxlT2JqID0ge1xyXG4gICAgICBvYmplY3Q6IG9iamVjdCxcclxuICAgICAgY2FjaGU6IGluaXRpYWxTY2FsZS5jb3B5VG8oe30pXHJcbiAgICB9O1xyXG4gIH0gXHJcbiAgc2NhbGVPYmouc2NhbGUgPSBzY2FsZTtcclxuICBcclxuICB0aGlzLl9vdmVyU2NhbGVzW2lkXSA9IHNjYWxlT2JqO1xyXG59O1xyXG5cclxuUGhhc2VyLlBsdWdpbi5KdWljeS5wcm90b3R5cGUuamVsbHkgPSBmdW5jdGlvbihvYmplY3QsIHN0cmVuZ3RoLCBkZWxheSwgaW5pdGlhbFNjYWxlKSB7XHJcbiAgc3RyZW5ndGggPSBzdHJlbmd0aCB8fCAwLjI7XHJcbiAgZGVsYXkgPSBkZWxheSB8fCAwO1xyXG4gIGluaXRpYWxTY2FsZSA9IGluaXRpYWxTY2FsZSB8fCAgbmV3IFBoYXNlci5Qb2ludCgxLCAxKTtcclxuICBcclxuICB0aGlzLmdhbWUuYWRkLnR3ZWVuKG9iamVjdC5zY2FsZSkudG8oe3g6IGluaXRpYWxTY2FsZS54ICsgKGluaXRpYWxTY2FsZS54ICogc3RyZW5ndGgpfSwgNTAsIFBoYXNlci5FYXNpbmcuUXVhZHJhdGljLkluT3V0LCB0cnVlLCBkZWxheSlcclxuICAudG8oe3g6IGluaXRpYWxTY2FsZS54fSwgNjAwLCBQaGFzZXIuRWFzaW5nLkVsYXN0aWMuT3V0LCB0cnVlKTtcclxuXHJcbiAgdGhpcy5nYW1lLmFkZC50d2VlbihvYmplY3Quc2NhbGUpLnRvKHt5OiBpbml0aWFsU2NhbGUueSArIChpbml0aWFsU2NhbGUueSAqIHN0cmVuZ3RoKX0sIDUwLCBQaGFzZXIuRWFzaW5nLlF1YWRyYXRpYy5Jbk91dCwgdHJ1ZSwgZGVsYXkgKyA1MClcclxuICAudG8oe3k6IGluaXRpYWxTY2FsZS55fSwgNjAwLCBQaGFzZXIuRWFzaW5nLkVsYXN0aWMuT3V0LCB0cnVlKTtcclxufTtcclxuXHJcblBoYXNlci5QbHVnaW4uSnVpY3kucHJvdG90eXBlLm1vdXNlU3RyZXRjaCA9IGZ1bmN0aW9uKG9iamVjdCwgc3RyZW5ndGgsIGluaXRpYWxTY2FsZSkge1xyXG4gICAgc3RyZW5ndGggPSBzdHJlbmd0aCB8fCAwLjU7XHJcbiAgICBpbml0aWFsU2NhbGUgPSBpbml0aWFsU2NhbGUgfHwgbmV3IFBoYXNlci5Qb2ludCgxLDEpO1xyXG4gICAgb2JqZWN0LnNjYWxlLnggPSBpbml0aWFsU2NhbGUueCArIChNYXRoLmFicyhvYmplY3QueCAtIHRoaXMuZ2FtZS5pbnB1dC5hY3RpdmVQb2ludGVyLngpIC8gMTAwKSAqIHN0cmVuZ3RoO1xyXG4gICAgb2JqZWN0LnNjYWxlLnkgPSBpbml0aWFsU2NhbGUueSArIChpbml0aWFsU2NhbGUueSAqIHN0cmVuZ3RoKSAtIChvYmplY3Quc2NhbGUueCAqIHN0cmVuZ3RoKTtcclxufTtcclxuXHJcblBoYXNlci5QbHVnaW4uSnVpY3kucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgc2NhbGVPYmo7XHJcbiAgLy8gU2NyZWVuIFNoYWtlXHJcbiAgaWYodGhpcy5fc2hha2VXb3JsZFRpbWUgPiAwKSB7IFxyXG4gICAgdmFyIG1hZ25pdHVkZSA9ICh0aGlzLl9zaGFrZVdvcmxkVGltZSAvIHRoaXMuX3NoYWtlV29ybGRNYXgpICogdGhpcy5fc2hha2VXb3JsZE1heDtcclxuICAgIHZhciB4ID0gdGhpcy5nYW1lLnJuZC5pbnRlZ2VySW5SYW5nZSgtbWFnbml0dWRlLCBtYWduaXR1ZGUpICsgdGhpcy5jYW1lcmFUYXJnZXQueCAtIHRoaXMuZ2FtZS5jYW1lcmEud2lkdGggLyAyO1xyXG4gICAgdmFyIHkgPSB0aGlzLmdhbWUucm5kLmludGVnZXJJblJhbmdlKC1tYWduaXR1ZGUsIG1hZ25pdHVkZSkgKyB0aGlzLmNhbWVyYVRhcmdldC55IC0gdGhpcy5nYW1lLmNhbWVyYS5oZWlnaHQgLyAyO1xyXG5cclxuICAgIHRoaXMuZ2FtZS5jYW1lcmEueCA9IHg7XHJcbiAgICB0aGlzLmdhbWUuY2FtZXJhLnkgPSB5O1xyXG4gICAgdGhpcy5fc2hha2VXb3JsZFRpbWUtLTtcclxuICAgIGlmKHRoaXMuX3NoYWtlV29ybGRUaW1lIDw9IDApIHtcclxuICAgICAgIHRoaXMuZ2FtZS5jYW1lcmEuZm9sbG93KHRoaXMuY2FtZXJhVGFyZ2V0KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIG92ZXIgc2NhbGVzXHJcbiAgZm9yKHZhciBzIGluIHRoaXMuX292ZXJTY2FsZXMpIHtcclxuICAgIGlmKHRoaXMuX292ZXJTY2FsZXMuaGFzT3duUHJvcGVydHkocykpIHtcclxuICAgICAgc2NhbGVPYmogPSB0aGlzLl9vdmVyU2NhbGVzW3NdO1xyXG4gICAgICBpZihzY2FsZU9iai5zY2FsZSA+IDAuMDEpIHtcclxuICAgICAgICBzY2FsZU9iai5vYmplY3Quc2NhbGUueCA9IHNjYWxlT2JqLnNjYWxlICogc2NhbGVPYmouY2FjaGUueDtcclxuICAgICAgICBzY2FsZU9iai5vYmplY3Quc2NhbGUueSA9IHNjYWxlT2JqLnNjYWxlICogc2NhbGVPYmouY2FjaGUueTtcclxuICAgICAgICBzY2FsZU9iai5zY2FsZSAtPSB0aGlzLmdhbWUudGltZS5lbGFwc2VkICogc2NhbGVPYmouc2NhbGUgKiAwLjM1O1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHNjYWxlT2JqLm9iamVjdC5zY2FsZS54ID0gc2NhbGVPYmouY2FjaGUueDtcclxuICAgICAgICBzY2FsZU9iai5vYmplY3Quc2NhbGUueSA9IHNjYWxlT2JqLmNhY2hlLnk7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMuX292ZXJTY2FsZXNbc107XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG4vLyBEcmF3IFRyaWFuZ2xlcyBQb2x5ZmlsbCBmb3IgYmFjayBjb21wYXRpYmlsaXR5XHJcbmlmKCFQaGFzZXIuR3JhcGhpY3MucHJvdG90eXBlLmRyYXdUcmlhbmdsZSkge1xyXG4gIFBoYXNlci5HcmFwaGljcy5wcm90b3R5cGUuZHJhd1RyaWFuZ2xlID0gZnVuY3Rpb24ocG9pbnRzLCBjdWxsKSB7XHJcbiAgICAgIHZhciB0cmlhbmdsZSA9IG5ldyBQaGFzZXIuUG9seWdvbihwb2ludHMpO1xyXG4gICAgICBpZiAoY3VsbCkge1xyXG4gICAgICAgICAgdmFyIGNhbWVyYVRvRmFjZSA9IG5ldyBQaGFzZXIuUG9pbnQodGhpcy5nYW1lLmNhbWVyYS54IC0gcG9pbnRzWzBdLngsIHRoaXMuZ2FtZS5jYW1lcmEueSAtIHBvaW50c1swXS55KTtcclxuICAgICAgICAgIHZhciBhYiA9IG5ldyBQaGFzZXIuUG9pbnQocG9pbnRzWzFdLnggLSBwb2ludHNbMF0ueCwgcG9pbnRzWzFdLnkgLSBwb2ludHNbMF0ueSk7XHJcbiAgICAgICAgICB2YXIgY2IgPSBuZXcgUGhhc2VyLlBvaW50KHBvaW50c1sxXS54IC0gcG9pbnRzWzJdLngsIHBvaW50c1sxXS55IC0gcG9pbnRzWzJdLnkpO1xyXG4gICAgICAgICAgdmFyIGZhY2VOb3JtYWwgPSBjYi5jcm9zcyhhYik7XHJcbiAgICAgICAgICBpZiAoY2FtZXJhVG9GYWNlLmRvdChmYWNlTm9ybWFsKSA+IDApIHtcclxuICAgICAgICAgICAgICB0aGlzLmRyYXdQb2x5Z29uKHRyaWFuZ2xlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRoaXMuZHJhd1BvbHlnb24odHJpYW5nbGUpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybjtcclxuICB9O1xyXG59IiwidmFyIEJvb3QgPSBmdW5jdGlvbiAoKSB7fTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQm9vdDtcclxuXHJcbkJvb3QucHJvdG90eXBlID0ge1xyXG5cclxuICBwcmVsb2FkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLmxvYWQuaW1hZ2UoJ3ByZWxvYWRlcicsICdhc3NldHMvcHJlbG9hZGVyLmdpZicpO1xyXG4gIH0sXHJcblxyXG4gIGNyZWF0ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy5nYW1lLmlucHV0Lm1heFBvaW50ZXJzID0gMTtcclxuXHJcbiAgICAvKlxyXG4gICAgaWYgKHRoaXMuZ2FtZS5kZXZpY2UuZGVza3RvcCkge1xyXG4gICAgICAvL3RoaXMuZ2FtZS5zdGFnZS5zY2FsZS5wYWdlQWxpZ25Ib3Jpem9udGFsbHkgPSB0cnVlO1xyXG4gICAgICB0aGlzLmdhbWUuc2NhbGUuc2NhbGVNb2RlID0gUGhhc2VyLlNjYWxlTWFuYWdlci5SRVNJWkU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLmdhbWUuc2NhbGUuc2NhbGVNb2RlID0gUGhhc2VyLlNjYWxlTWFuYWdlci5TSE9XX0FMTDtcclxuICAgICAgdGhpcy5nYW1lLnNjYWxlLm1pbldpZHRoID0gIDQ4MDtcclxuICAgICAgdGhpcy5nYW1lLnNjYWxlLm1pbkhlaWdodCA9IDI2MDtcclxuICAgICAgdGhpcy5nYW1lLnNjYWxlLm1heFdpZHRoID0gNjQwO1xyXG4gICAgICB0aGlzLmdhbWUuc2NhbGUubWF4SGVpZ2h0ID0gNDgwO1xyXG4gICAgICB0aGlzLmdhbWUuc2NhbGUuZm9yY2VMYW5kc2NhcGUgPSB0cnVlO1xyXG4gICAgICB0aGlzLmdhbWUuc2NhbGUucGFnZUFsaWduSG9yaXpvbnRhbGx5ID0gdHJ1ZTtcclxuICAgICAgdGhpcy5nYW1lLnNjYWxlLnNldFNjcmVlblNpemUodHJ1ZSk7XHJcbiAgICB9XHJcbiAgICAqL1xyXG4gICAgdmFyIHdpZHRoID0gODAwO1xyXG4gICAgdmFyIGhlaWdodCA9IDgwMDtcclxuICAgIHRoaXMuZ2FtZS53aWR0aCA9IHdpZHRoO1xyXG4gICAgdGhpcy5nYW1lLmhlaWdodCA9IGhlaWdodDtcclxuICAgIC8vIHRoaXMuZ2FtZS5zdGFnZS5ib3VuZHMud2lkdGggPSB3aWR0aDtcclxuICAgIC8vIHRoaXMuZ2FtZS5zdGFnZS5ib3VuZHMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgLy8gdGhpcy5nYW1lLnJlbmRlcmVyLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcclxuXHJcbiAgICB0aGlzLmdhbWUuc3RhdGUuc3RhcnQoJ1ByZWxvYWRlcicpO1xyXG4gIH1cclxufTtcclxuIiwiLypcclxuTWFpbiB0ZXN0aW5nIGVudmlyb25tZW50LlxyXG4qL1xyXG5cclxudmFyIE1vZHVsZUJ1aWxkZXIgPSByZXF1aXJlKCcuLi9lbnRpdGllcy9Nb2R1bGVCdWlsZGVyJyk7XHJcbnZhciBDdWJlR3JvdXAgPSByZXF1aXJlKCcuLi9lbnRpdGllcy9jdWJlX2dyb3VwJyk7XHJcbnZhciBNb3VzZSA9IHJlcXVpcmUoJy4uL2VudGl0aWVzL21vdXNlJyk7XHJcbnZhciBKdWljeSA9IHJlcXVpcmUoJy4uL3BsdWdpbnMvSnVpY3knKTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXHJcblxyXG52YXIgYmcsIGJnMjtcclxudmFyIG51bVJvaWRzID0gMDtcclxudmFyIG1heFJvaWRzID0gNTA7XHJcbnZhciBhc3Rlcm9pZHMsIGFzdGVyb2lkTGlzdDtcclxudmFyIGxlZnRLZXksIHJpZ2h0S2V5LCBjd0tleSwgY2N3S2V5O1xyXG52YXIgYXN0ZXJvaWRDRywgY3ViZUNHO1xyXG5cclxudmFyIEdhbWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdGhpcy50ZXN0ZW50aXR5ID0gbnVsbDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2FtZTtcclxuXHJcbkdhbWUucHJvdG90eXBlID0ge1xyXG5cdFxyXG4gIGNyZWF0ZTogZnVuY3Rpb24gKCkge1xyXG5cdHRoaXMuZ2FtZS53b3JsZC5zZXRCb3VuZHMoMCwgMCwgODAwMCwgNDAwMCk7XHJcblx0XHJcblx0Ly9DcmVhdGUgdGhlIHR3byBiYWNrZ3JvdW5kIGltYWdlc1xyXG4gICAgYmcgPSB0aGlzLmdhbWUuYWRkLnNwcml0ZSgwLCAwLCAnZWFydGhOaWdodCcpO1xyXG5cdGJnMiA9IHRoaXMuZ2FtZS5hZGQuc3ByaXRlKC04MDAwLCAwLCAnZWFydGhOaWdodCcpO1xyXG5cdFxyXG5cdHRoaXMuZ2FtZS5waHlzaWNzLnN0YXJ0U3lzdGVtKFBoYXNlci5QaHlzaWNzLlAySlMpO1xyXG4gICB0aGlzLmdhbWUucGh5c2ljcy5wMi5zZXRJbXBhY3RFdmVudHModHJ1ZSk7XHJcblxyXG5cdGN1YmVDRyA9IHRoaXMuZ2FtZS5waHlzaWNzLnAyLmNyZWF0ZUNvbGxpc2lvbkdyb3VwKCk7XHJcblx0YXN0ZXJvaWRDRyA9IHRoaXMuZ2FtZS5waHlzaWNzLnAyLmNyZWF0ZUNvbGxpc2lvbkdyb3VwKCk7XHJcblx0XHJcbiAgIHRoaXMubW91c2UgPSBuZXcgTW91c2UodGhpcy5nYW1lLCB0aGlzLmlucHV0KTtcclxuICAgXHJcbiAgIHRoaXMudXBkYXRlRGVwZW5kZW50cyA9IFtdO1xyXG4gICBcclxuXHQvL2NyZWF0ZSBNb2R1bGVCdWlsZGVyIGFuZCBzdG9yZSBpdCBpbiB0aGlzIGdhbWUgc3RhdGUgb2JqZWN0XHJcblx0dGhpcy5tb2R1bGVCdWlsZGVyID0gbmV3IE1vZHVsZUJ1aWxkZXIodGhpcyk7XHJcblx0Ly9jcmVhdGUgYW5kIHN0b3JlIHRoZSBjb3JlIG1vZHVsZVxyXG5cdHRoaXMuY29yZU1vZHVsZSA9IHRoaXMubW9kdWxlQnVpbGRlci5idWlsZCgnY29yZScsIDE1MDAsIDE1MDAsIHRydWUpO1xyXG5cdHRoaXMuY3ViZVdpZHRoID0gdGhpcy5jb3JlTW9kdWxlLmN1YmUud2lkdGg7XHJcblx0dGhpcy5jb3JlTW9kdWxlLmN1YmUuYm9keS5zZXRDb2xsaXNpb25Hcm91cChjdWJlQ0cpO1xyXG5cdHRoaXMuY29yZU1vZHVsZS5jdWJlLmJvZHkuY29sbGlkZXMoW2N1YmVDRywgYXN0ZXJvaWRDR10pO1xyXG5cdHRoaXMuY3ViZUJ1ZmZlciA9IDI7XHJcblx0dmFyIHBsYXllckdyb3VwID0gbmV3IEN1YmVHcm91cCh0aGlzLCB0aGlzLmNvcmVNb2R1bGUuY3ViZSk7XHJcblx0dGhpcy51cGRhdGVEZXBlbmRlbnRzLnB1c2gocGxheWVyR3JvdXApO1xyXG5cdHRoaXMucGxheWVyID0gcGxheWVyR3JvdXA7XHJcbiAgIHRoaXMucGxheWVyLmlzUGxheWVyID0gdHJ1ZTtcclxuICAgXHJcbiAgIHRoaXMubW91c2UgPSBuZXcgTW91c2UodGhpcy5nYW1lLCB0aGlzLmlucHV0LCBwbGF5ZXJHcm91cCk7XHJcblx0dGhpcy5wbGF5ZXIuaXNQbGF5ZXIgPSB0cnVlO1xyXG4gICBcclxuXHR0aGlzLnNwYWNlS2V5ID0gdGhpcy5nYW1lLmlucHV0LmtleWJvYXJkLmFkZEtleShQaGFzZXIuS2V5Ym9hcmQuU1BBQ0VCQVIpO1xyXG5cdHRoaXMuZ2FtZS5pbnB1dC5rZXlib2FyZC5hZGRLZXlDYXB0dXJlKFt0aGlzLnNwYWNlS2V5XSk7XHJcblx0XHJcblx0YXN0ZXJvaWRzID0gdGhpcy5nYW1lLmFkZC5ncm91cCgpO1xyXG5cdGFzdGVyb2lkcy5lbmFibGVCb2R5ID0gdHJ1ZTtcclxuXHRhc3Rlcm9pZHMucGh5c2ljc0JvZHlUeXBlID0gUGhhc2VyLlBoeXNpY3MuUDJKUztcclxuXHRhc3Rlcm9pZExpc3QgPSBuZXcgUGhhc2VyLkFycmF5U2V0KCk7XHJcblx0dGhpcy5nZW5lcmF0ZUFzdGVyb2lkcygpO1xyXG5cdFxyXG5cdGxlZnRLZXkgPSB0aGlzLmdhbWUuaW5wdXQua2V5Ym9hcmQuYWRkS2V5KFBoYXNlci5LZXlib2FyZC5BKTtcclxuXHRyaWdodEtleSA9IHRoaXMuZ2FtZS5pbnB1dC5rZXlib2FyZC5hZGRLZXkoUGhhc2VyLktleWJvYXJkLkQpO1xyXG5cdGNjd0tleSA9IHRoaXMuZ2FtZS5pbnB1dC5rZXlib2FyZC5hZGRLZXkoUGhhc2VyLktleWJvYXJkLlEpO1xyXG5cdGN3S2V5ID0gdGhpcy5nYW1lLmlucHV0LmtleWJvYXJkLmFkZEtleShQaGFzZXIuS2V5Ym9hcmQuRSk7XHJcblx0XHJcblx0Ly9ERUJVR0dJTkcgTElTVEVORVJTLSBhbGxvdyB5b3UgdG8gY3JlYXRlIG1vZHVsZXMgYnkgcHJlc3Npbmcga2V5c1xyXG5cdC8vY29yZVxyXG5cdHRoaXMucGxhY2VDb3JlS2V5ID0gdGhpcy5nYW1lLmlucHV0LmtleWJvYXJkLmFkZEtleShQaGFzZXIuS2V5Ym9hcmQuUCk7XHJcblx0dGhpcy5wbGFjZUNvcmVLZXkub25Eb3duLmFkZCh0aGlzLmFkZENvcmUsIHRoaXMpO1xyXG5cdC8vc2hpZWxkXHJcblx0dGhpcy5wbGFjZVNoaWVsZEtleSA9IHRoaXMuZ2FtZS5pbnB1dC5rZXlib2FyZC5hZGRLZXkoUGhhc2VyLktleWJvYXJkLk8pO1xyXG4gICAgdGhpcy5wbGFjZVNoaWVsZEtleS5vbkRvd24uYWRkKHRoaXMuYWRkU2hpZWxkLCB0aGlzKTtcclxuXHQvL3RocnVzdGVyXHJcblx0dGhpcy5wbGFjZVRocnVzdGVyS2V5ID0gdGhpcy5nYW1lLmlucHV0LmtleWJvYXJkLmFkZEtleShQaGFzZXIuS2V5Ym9hcmQuSSk7XHJcbiAgICB0aGlzLnBsYWNlVGhydXN0ZXJLZXkub25Eb3duLmFkZCh0aGlzLmFkZFRocnVzdGVyLCB0aGlzKTtcclxuXHQvL3NvbGFyUGFuZWxcclxuXHR0aGlzLnBsYWNlU1BLZXkgPSB0aGlzLmdhbWUuaW5wdXQua2V5Ym9hcmQuYWRkS2V5KFBoYXNlci5LZXlib2FyZC5VKTtcclxuICAgIHRoaXMucGxhY2VTUEtleS5vbkRvd24uYWRkKHRoaXMuYWRkU1AsIHRoaXMpO1xyXG5cdC8vZ3VuXHJcblx0dGhpcy5wbGFjZUd1bktleSA9IHRoaXMuZ2FtZS5pbnB1dC5rZXlib2FyZC5hZGRLZXkoUGhhc2VyLktleWJvYXJkLlkpO1xyXG4gICAgdGhpcy5wbGFjZUd1bktleS5vbkRvd24uYWRkKHRoaXMuYWRkR3VuLCB0aGlzKTtcclxuXHQvL0VORFxyXG4gICAgXHJcbiAgICAvLyBEZWJ1ZyBjb250cm9sbGVyXHJcbiAgICB0aGlzLmRlYnVnS2V5ID0gdGhpcy5nYW1lLmlucHV0LmtleWJvYXJkLmFkZEtleShQaGFzZXIuS2V5Ym9hcmQuSCk7XHJcbiAgICB0aGlzLmRlYnVnS2V5Lm9uRG93bi5hZGQodGhpcy5kZWJ1ZywgdGhpcyk7XHJcbiAgICB0aGlzLnJvb3RTcGF3bmVkID0gZmFsc2U7XHJcbiAgICBcclxuICAgIHRoaXMuZGVidWdOdW0gPSAwO1xyXG4gICAgdGhpcy5teVJvb3QgPSB1bmRlZmluZWQ7XHJcblxyXG5cdCB0aGlzLmdhbWUuY2FtZXJhLnNldFBvc2l0aW9uKDEwMDAsIDEwMDApO1xyXG4gICAgXHJcbiAgICB0aGlzLmxldmVsRGF0YSA9IEpTT04ucGFyc2UodGhpcy5nYW1lLmNhY2hlLmdldFRleHQoJ2xldmVsX29uZScpKTtcclxuICAgIHRoaXMubG9hZERhdGEoKTtcclxuICAgIFxyXG4gICAgdGhpcy5qdWljeSA9IHRoaXMuZ2FtZS5wbHVnaW5zLmFkZChuZXcgUGhhc2VyLlBsdWdpbi5KdWljeSh0aGlzKSk7XHJcbiAgICB0aGlzLmdhbWUuY2FtZXJhLmZvbGxvdyh0aGlzLmNvcmVNb2R1bGUuY3ViZSk7XHJcbiAgfSxcclxuICBcclxuICBsb2FkRGF0YTogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHZhciBteUxldmVsID0gdGhpcy5sZXZlbERhdGFbJ2xldmVsX29uZSddO1xyXG4gICAgICBmb3IgKHZhciBrZXkgaW4gbXlMZXZlbCkge1xyXG4gICAgICAgICBpZiAobXlMZXZlbC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gbXlMZXZlbFtrZXldO1xyXG4gICAgICAgICAgICBpZiAoZWxlbWVudC5oYXNPd25Qcm9wZXJ0eSgnYmx1ZXByaW50JykpIHsgLy8gZW5lbXkgdHlwZVxyXG4gICAgICAgICAgICAgICB2YXIgZW5lbXlYID0gZWxlbWVudFsneF9wb3MnXTtcclxuICAgICAgICAgICAgICAgdmFyIGVuZW15WSA9IGVsZW1lbnRbJ3lfcG9zJ107XHJcbiAgICAgICAgICAgICAgIHZhciBlbmVteUdyb3VwID0gbmV3IEN1YmVHcm91cCh0aGlzLCB1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICAgICB0aGlzLnVwZGF0ZURlcGVuZGVudHMucHVzaChlbmVteUdyb3VwKTtcclxuICAgICAgICAgICAgICAgdmFyIGJsdWVwcmludCA9IGVsZW1lbnRbJ2JsdWVwcmludCddO1xyXG4gICAgICAgICAgICAgICAvLyB2YXIgcHJhY3RpY2FsID0gW107XHJcbiAgICAgICAgICAgICAgIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IGJsdWVwcmludC5sZW5ndGg7IHJvdysrKSB7XHJcbiAgICAgICAgICAgICAgICAgIC8vIHZhciBuZXdDb2wgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgY29sID0gMDsgY29sIDwgYmx1ZXByaW50W3Jvd10ubGVuZ3RoOyBjb2wrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IGJsdWVwcmludFtyb3ddW2NvbF07XHJcbiAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdNb2R1bGUgPSB0aGlzLm1vZHVsZUJ1aWxkZXIuYnVpbGQodHlwZSwgZW5lbXlYICsgcm93ICogKHRoaXMuY3ViZVdpZHRoICsgdGhpcy5jdWJlQnVmZmVyKSxcclxuICAgICAgICAgICAgICAgICAgICAgZW5lbXlZIC0gY29sICogKHRoaXMuY3ViZVdpZHRoICsgdGhpcy5jdWJlQnVmZmVyKSwgZmFsc2UpO1xyXG5cdFx0XHRcdFx0IG5ld01vZHVsZS5jdWJlLmJvZHkuc2V0Q29sbGlzaW9uR3JvdXAoY3ViZUNHKTtcclxuXHRcdFx0XHRcdCBuZXdNb2R1bGUuY3ViZS5ib2R5LmNvbGxpZGVzKFtjdWJlQ0csIGFzdGVyb2lkQ0ddKTtcclxuICAgICAgICAgICAgICAgICAgICAgLy8gbmV3Q29sLnB1c2gobmV3TW9kdWxlLmN1YmUpO1xyXG4gICAgICAgICAgICAgICAgICAgICB2YXIgcG9pbnQgPSBuZXcgUGhhc2VyLlBvaW50KHJvdywgY29sKTtcclxuICAgICAgICAgICAgICAgICAgICAgZW5lbXlHcm91cC5hZGQobmV3TW9kdWxlLmN1YmUsIHBvaW50KTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAvLyBwcmFjdGljYWwucHVzaChuZXdDb2wpO1xyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIC8vIFRPRE86IGdpdmUgZGlmZmVyZW50IHR5cGVzIGhlcmVcclxuICAgICAgICAgICAgICAgZW5lbXlHcm91cC5naXZlQUkoJ3JhbScsIHRoaXMucGxheWVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICB9XHJcbiAgICAgIH1cclxuICB9LFxyXG5cclxuICB1cGRhdGU6IGZ1bmN0aW9uICgpIHsgICAgXHJcblx0aWYobGVmdEtleS5pc0Rvd24pIHtcclxuXHRcdGlmKHRoaXMuY29yZU1vZHVsZS5jdWJlLmJvZHkuYW5ndWxhclZlbG9jaXR5ID4gLTkpIHsgXHJcblx0XHRcdHRoaXMuY29yZU1vZHVsZS5jdWJlLmJvZHkuYW5ndWxhckZvcmNlICs9IC01ICogTWF0aC5wb3codGhpcy5wbGF5ZXIubnVtQ3ViZXMsIDEuNjUpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRcclxuXHRpZihyaWdodEtleS5pc0Rvd24pIHtcclxuXHRcdGlmKHRoaXMuY29yZU1vZHVsZS5jdWJlLmJvZHkuYW5ndWxhclZlbG9jaXR5IDwgOSkge1xyXG5cdFx0XHR0aGlzLmNvcmVNb2R1bGUuY3ViZS5ib2R5LmFuZ3VsYXJGb3JjZSArPSA1ICogTWF0aC5wb3codGhpcy5wbGF5ZXIubnVtQ3ViZXMsIDEuNjUpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRcclxuXHRpZihjY3dLZXkuaXNEb3duKSB7XHJcblx0XHRpZih0aGlzLm1vdXNlLmdyYWJiZWQgIT09IHVuZGVmaW5lZCAmJiB0aGlzLm1vdXNlLmdyYWJiZWQuc3ByaXRlLmdyb3VwID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0dGhpcy5tb3VzZS5ncmFiYmVkLmFuZ3VsYXJGb3JjZSArPSAtNTtcclxuXHRcdH1cclxuXHR9XHJcblx0XHJcblx0aWYoY3dLZXkuaXNEb3duKSB7XHJcblx0XHRpZih0aGlzLm1vdXNlLmdyYWJiZWQgIT09IHVuZGVmaW5lZCAmJiB0aGlzLm1vdXNlLmdyYWJiZWQuc3ByaXRlLmdyb3VwID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0dGhpcy5tb3VzZS5ncmFiYmVkLmFuZ3VsYXJGb3JjZSArPSA1O1xyXG5cdFx0fVxyXG5cdH1cclxuXHRcclxuXHR0aGlzLm1vdXNlLnVwZGF0ZSgpO1xyXG5cdHRoaXMuc2Nyb2xsQkcoKTtcclxuICAgXHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnVwZGF0ZURlcGVuZGVudHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdGlmICh0aGlzLnVwZGF0ZURlcGVuZGVudHNbaV0udXBkYXRlKSB7XHJcblx0XHRcdHRoaXMudXBkYXRlRGVwZW5kZW50c1tpXS51cGRhdGUoKTtcclxuXHRcdH1cclxuXHR9XHJcbiAgfSxcclxuICBcclxuICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcclxuXHR0aGlzLm1vdXNlLnJlbmRlcigpO1xyXG4gIH0sXHJcbiAgXHJcblx0c2Nyb2xsQkc6IGZ1bmN0aW9uKCkge1xyXG5cdFx0YmcueCArPSAwLjEyNTtcclxuXHRcdGlmKGJnLnggPj0gODAwMCkge1xyXG5cdFx0XHRiZy54ICs9IDA7XHJcblx0XHR9XHJcblx0XHRiZzIueCArPSAwLjEyNTtcclxuXHRcdGlmKGJnMi54ID49IDgwMDApIHtcclxuXHRcdFx0YmcyLnggPSAwO1xyXG5cdFx0fVxyXG5cdH0sXHJcblx0XHJcblx0Z2VuZXJhdGVBc3Rlcm9pZHM6IGZ1bmN0aW9uKCkge1xyXG5cdFx0Zm9yKDtudW1Sb2lkcyA8IG1heFJvaWRzOyBudW1Sb2lkcysrKSB7XHJcblx0XHRcdHZhciBjb2luQSA9IHRoaXMuZ2FtZS5ybmQuaW50ZWdlckluUmFuZ2UoMCwxKTtcclxuXHRcdFx0dmFyIGNvaW5CID0gdGhpcy5nYW1lLnJuZC5pbnRlZ2VySW5SYW5nZSgwLDEpO1xyXG5cdFx0XHR2YXIgYXN0ZXJvaWQ7XHJcblx0XHRcdGlmKGNvaW5BID09PSAxKSB7XHJcblx0XHRcdFx0aWYoY29pbkIgPT09IDEpIHsgLy9TcGF3biBhc3Rlcm9pZCBhYm92ZSBzY3JlZW5cclxuXHRcdFx0XHRcdGFzdGVyb2lkID0gYXN0ZXJvaWRzLmNyZWF0ZSh0aGlzLmNvcmVNb2R1bGUuY3ViZS54ICsgdGhpcy5nYW1lLnJuZC5pbnRlZ2VySW5SYW5nZSgtdGhpcy5nYW1lLmNhbWVyYS53aWR0aC8yLCB0aGlzLmdhbWUuY2FtZXJhLndpZHRoLzIpLCB0aGlzLmNvcmVNb2R1bGUuY3ViZS55IC0gdGhpcy5nYW1lLmNhbWVyYS5oZWlnaHQvMiAtIHRoaXMuZ2FtZS5ybmQuaW50ZWdlckluUmFuZ2UoMzIsIDMwMCksICdhc3Rlcm9pZCcpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbHNlIHsgLy9TcGF3biBhc3Rlcm9pZCBiZWxvdyBzY3JlZW5cclxuXHRcdFx0XHRcdGFzdGVyb2lkID0gYXN0ZXJvaWRzLmNyZWF0ZSh0aGlzLmNvcmVNb2R1bGUuY3ViZS54ICsgdGhpcy5nYW1lLnJuZC5pbnRlZ2VySW5SYW5nZSgtdGhpcy5nYW1lLmNhbWVyYS53aWR0aC8yLCB0aGlzLmdhbWUuY2FtZXJhLndpZHRoLzIpLCB0aGlzLmNvcmVNb2R1bGUuY3ViZS55ICsgdGhpcy5nYW1lLmNhbWVyYS5oZWlnaHQvMiArIHRoaXMuZ2FtZS5ybmQuaW50ZWdlckluUmFuZ2UoMzIsIDMwMCksICdhc3Rlcm9pZCcpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRpZihjb2luQiA9PT0gMSkgeyAvL1NwYXduIGFzdGVyb2lkIHRvIGxlZnQgb2Ygc2NyZWVuXHJcblx0XHRcdFx0XHRhc3Rlcm9pZCA9IGFzdGVyb2lkcy5jcmVhdGUodGhpcy5jb3JlTW9kdWxlLmN1YmUueCAtIHRoaXMuZ2FtZS5jYW1lcmEud2lkdGgvMiAtIHRoaXMuZ2FtZS5ybmQuaW50ZWdlckluUmFuZ2UoMzIsIDMwMCksIHRoaXMuY29yZU1vZHVsZS5jdWJlLnkgKyB0aGlzLmdhbWUucm5kLmludGVnZXJJblJhbmdlKC10aGlzLmdhbWUuY2FtZXJhLmhlaWdodC8yLCB0aGlzLmdhbWUuY2FtZXJhLmhlaWdodC8yKSwgJ2FzdGVyb2lkJyk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2UgeyAvL1NwYXduIGFzdGVyb2lkIHRvIHJpZ2h0XHJcblx0XHRcdFx0XHRhc3Rlcm9pZCA9IGFzdGVyb2lkcy5jcmVhdGUodGhpcy5jb3JlTW9kdWxlLmN1YmUueCArIHRoaXMuZ2FtZS5jYW1lcmEud2lkdGgvMiArIHRoaXMuZ2FtZS5ybmQuaW50ZWdlckluUmFuZ2UoMzIsIDMwMCksIHRoaXMuY29yZU1vZHVsZS5jdWJlLnkgKyB0aGlzLmdhbWUucm5kLmludGVnZXJJblJhbmdlKC10aGlzLmdhbWUuY2FtZXJhLmhlaWdodC8yLCB0aGlzLmdhbWUuY2FtZXJhLmhlaWdodC8yKSwgJ2FzdGVyb2lkJyk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdFxyXG5cdFx0XHRhc3Rlcm9pZC5ib2R5LnNldENpcmNsZSgxNik7IC8vQ2hhbmdlIHRoZSBjb2xsaXNpb24gZGV0ZWN0aW9uIGZyb20gYW4gQUFCQiB0byBhIGNpcmNsZVxyXG5cdFx0XHRhc3Rlcm9pZC5ib2R5LmFuZ3VsYXJEYW1waW5nID0gMDtcclxuXHRcdFx0YXN0ZXJvaWQuYm9keS5kYW1waW5nID0gMDtcclxuXHRcdFx0YXN0ZXJvaWQuYm9keS5yb3RhdGlvbiA9IHRoaXMuZ2FtZS5ybmQucmVhbEluUmFuZ2UoMCwgMiAqIDMuMTQpO1xyXG5cdFx0XHRhc3Rlcm9pZC5ib2R5LmZvcmNlLnggPSB0aGlzLmdhbWUucm5kLmludGVnZXJJblJhbmdlKC0xMCwgMTApICogNzUwO1xyXG5cdFx0XHRhc3Rlcm9pZC5ib2R5LmZvcmNlLnkgPSB0aGlzLmdhbWUucm5kLmludGVnZXJJblJhbmdlKC0xMCwgMTApICogNzUwO1xyXG5cdFx0XHRhc3Rlcm9pZC5ib2R5LnNldENvbGxpc2lvbkdyb3VwKGFzdGVyb2lkQ0cpO1xyXG5cdFx0XHRhc3Rlcm9pZC5ib2R5LmNvbGxpZGVzKFthc3Rlcm9pZENHLCBjdWJlQ0ddKTtcclxuXHRcdFx0YXN0ZXJvaWQuYm9keS5jb2xsaWRlV29ybGRCb3VuZHMgPSBmYWxzZTtcclxuXHRcdFx0YXN0ZXJvaWQuYXV0b0N1bGwgPSB0cnVlO1xyXG5cdFx0XHRhc3Rlcm9pZC5jaGVja1dvcmxkQm91bmRzID0gdHJ1ZTtcclxuXHRcdFx0YXN0ZXJvaWQuZXZlbnRzLm9uT3V0T2ZCb3VuZHMuYWRkKHRoaXMucmVzZXRBc3Rlcm9pZCwgYXN0ZXJvaWQpO1xyXG5cdFx0XHRhc3Rlcm9pZExpc3QuYWRkKGFzdGVyb2lkKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cdFxyXG5cdHJlc2V0QXN0ZXJvaWQ6IGZ1bmN0aW9uKCkgeyAvL05lZWRzIHRvIGJlIHVwZGF0ZWQgb25jZSBjb2xsaXNpb24gZ3JvdXBzIGFyZSB3b3JraW5nXHJcblx0XHQvL3RoaXMub2JqLnggPSAxMDtcclxuXHRcdC8vdGhpcy5vYmoueSA9IDEwO1xyXG5cdH0sXHJcblx0XHJcbiAgLy9ERUJVRyBGVU5DVElPTlMtIGV2ZW50IGZ1bmN0aW9ucyBjYWxsZWQgZnJvbSBsaXN0ZW5lcnMgdGhhdCBhbGxvdyB5b3UgdG8gY3JlYXRlIG1vZHVsZXMgd2l0aCBrZXkgcHJlc3Nlc1xyXG4gIGFkZENvcmU6IGZ1bmN0aW9uICgpIHsgXHJcblx0Ly9BdHRlbXB0cyB0byBjcmVhdGUgbW9yZSBjb3JlIG1vZHVsZXMgaGVyZSB3aWxsIG9ubHkgcmV0dXJuIHRoZSBleGlzdGluZyBjb3JlXHJcblx0dmFyIG5ld01vZHVsZSA9IHRoaXMubW9kdWxlQnVpbGRlci5idWlsZCgnY29yZScsIHRoaXMubW91c2UueCwgdGhpcy5tb3VzZS55LCB0cnVlKTtcclxuXHRuZXdNb2R1bGUuY3ViZS5ib2R5LnNldENvbGxpc2lvbkdyb3VwKGN1YmVDRyk7XHJcblx0bmV3TW9kdWxlLmN1YmUuYm9keS5jb2xsaWRlcyhbY3ViZUNHLCBhc3Rlcm9pZENHXSk7XHJcbiAgfSxcclxuICBhZGRTaGllbGQ6IGZ1bmN0aW9uICgpIHtcclxuXHR2YXIgbmV3TW9kdWxlID0gdGhpcy5tb2R1bGVCdWlsZGVyLmJ1aWxkKCdzaGllbGQnLCB0aGlzLm1vdXNlLngsIHRoaXMubW91c2UueSwgdHJ1ZSk7XHJcblx0bmV3TW9kdWxlLmN1YmUuYm9keS5zZXRDb2xsaXNpb25Hcm91cChjdWJlQ0cpO1xyXG5cdG5ld01vZHVsZS5jdWJlLmJvZHkuY29sbGlkZXMoW2N1YmVDRywgYXN0ZXJvaWRDR10pO1xyXG4gIH0sXHJcbiAgYWRkVGhydXN0ZXI6IGZ1bmN0aW9uICgpIHtcclxuXHR2YXIgbmV3TW9kdWxlID0gdGhpcy5tb2R1bGVCdWlsZGVyLmJ1aWxkKCd0aHJ1c3RlcicsIHRoaXMubW91c2UueCwgdGhpcy5tb3VzZS55LCB0cnVlKTtcclxuXHRuZXdNb2R1bGUuY3ViZS5ib2R5LnNldENvbGxpc2lvbkdyb3VwKGN1YmVDRyk7XHJcblx0bmV3TW9kdWxlLmN1YmUuYm9keS5jb2xsaWRlcyhbY3ViZUNHLCBhc3Rlcm9pZENHXSk7XHJcbiAgfSxcclxuICBhZGRTUDogZnVuY3Rpb24gKCkge1xyXG5cdHZhciBuZXdNb2R1bGUgPSB0aGlzLm1vZHVsZUJ1aWxkZXIuYnVpbGQoJ3NvbGFyUGFuZWwnLCB0aGlzLm1vdXNlLngsIHRoaXMubW91c2UueSwgdHJ1ZSk7XHJcblx0bmV3TW9kdWxlLmN1YmUuYm9keS5zZXRDb2xsaXNpb25Hcm91cChjdWJlQ0cpO1xyXG5cdG5ld01vZHVsZS5jdWJlLmJvZHkuY29sbGlkZXMoW2N1YmVDRywgYXN0ZXJvaWRDR10pO1xyXG4gIH0sXHJcbiAgYWRkR3VuOiBmdW5jdGlvbiAoKSB7XHJcblx0dmFyIG5ld01vZHVsZSA9IHRoaXMubW9kdWxlQnVpbGRlci5idWlsZCgnZ3VuJywgdGhpcy5tb3VzZS54LCB0aGlzLm1vdXNlLnksIHRydWUpO1xyXG5cdG5ld01vZHVsZS5jdWJlLmJvZHkuc2V0Q29sbGlzaW9uR3JvdXAoY3ViZUNHKTtcclxuXHRuZXdNb2R1bGUuY3ViZS5ib2R5LmNvbGxpZGVzKFtjdWJlQ0csIGFzdGVyb2lkQ0ddKTtcclxuICB9LFxyXG5cclxuICBkZWJ1ZzogZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy5qdWljeS5zaGFrZSgpO1xyXG4gIH1cclxufTtcclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuIiwidmFyIE1lbnUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdGhpcy50ZXh0ID0gbnVsbDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTWVudTtcclxuXHJcbk1lbnUucHJvdG90eXBlID0ge1xyXG5cclxuICBjcmVhdGU6IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciB4ID0gdGhpcy5nYW1lLndpZHRoIC8gMjtcclxuICAgIHZhciB5ID0gdGhpcy5nYW1lLmhlaWdodCAvIDI7XHJcblxyXG4gICAgdmFyIHN0eWxlID0geyBmb250OiAnNjVweCBBcmlhbCcsIGZpbGw6ICcjZmZmZmZmJywgYWxpZ246ICdjZW50ZXInIH07XHJcbiAgICB0aGlzLnRpdGxlID0gdGhpcy5nYW1lLmFkZC50ZXh0KHRoaXMuZ2FtZS53b3JsZC5jZW50ZXJYLCB0aGlzLmdhbWUud29ybGQuY2VudGVyWSAtIDI1MCwgJ0Fib3ZlIFRoZSBJcm9uIEN1cnRhaW4nLCBzdHlsZSk7XHJcbiAgICB0aGlzLm5ld0dhbWUgPSB0aGlzLmdhbWUuYWRkLnRleHQodGhpcy5nYW1lLndvcmxkLmNlbnRlclgsIHRoaXMuZ2FtZS53b3JsZC5jZW50ZXJZIC0gMTUwLCAnTmV3IFNpbXVsYXRpb24nLCBzdHlsZSk7XHJcbiAgICB0aGlzLmxldmVsID0gdGhpcy5nYW1lLmFkZC50ZXh0KHRoaXMuZ2FtZS53b3JsZC5jZW50ZXJYLCB0aGlzLmdhbWUud29ybGQuY2VudGVyWSAtIDUwLCAnTWlzc2lvbiBTZWxlY3QnLCBzdHlsZSk7XHJcbiAgICB0aGlzLmNvbnRyb2xzID0gdGhpcy5nYW1lLmFkZC50ZXh0KHRoaXMuZ2FtZS53b3JsZC5jZW50ZXJYLCB0aGlzLmdhbWUud29ybGQuY2VudGVyWSArIDUwLCAnTWFudWFsJywgc3R5bGUpO1xyXG4gICAgdGhpcy5jcmVkaXRzID0gdGhpcy5nYW1lLmFkZC50ZXh0KHRoaXMuZ2FtZS53b3JsZC5jZW50ZXJYLCB0aGlzLmdhbWUud29ybGQuY2VudGVyWSArIDE1MCwgJ0NyZWRpdHMnLCBzdHlsZSk7XHJcblxyXG4gICAgdGhpcy5pbnB1dC5vbkRvd24uYWRkKHRoaXMub25Eb3duLCB0aGlzKTtcclxuICB9LFxyXG5cclxuICB1cGRhdGU6IGZ1bmN0aW9uICgpIHtcclxuICB9LFxyXG5cclxuICBvbkRvd246IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMuZ2FtZS5zdGF0ZS5zdGFydChwbGF5ZXJTdGF0ZS5jdXJyZW50TGV2ZWwpOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcclxuICB9XHJcbn07XHJcbiIsInZhciBQcmVsb2FkZXIgPSBmdW5jdGlvbiAoZ2FtZSkge1xyXG4gIGdhbWUgPSBudWxsO1xyXG4gIHRoaXMuYXNzZXQgPSBudWxsO1xyXG4gIHRoaXMucmVhZHkgPSBmYWxzZTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUHJlbG9hZGVyO1xyXG5cclxuUHJlbG9hZGVyLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgcHJlbG9hZDogZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy5hc3NldCA9IHRoaXMuYWRkLnNwcml0ZSg2NDAsIDM2MCwgJ3ByZWxvYWRlcicpO1xyXG4gICAgdGhpcy5hc3NldC5hbmNob3Iuc2V0VG8oMC41LCAwLjUpO1xyXG5cclxuICAgIHRoaXMubG9hZC5vbkxvYWRDb21wbGV0ZS5hZGRPbmNlKHRoaXMub25Mb2FkQ29tcGxldGUsIHRoaXMpO1xyXG4gICAgdGhpcy5sb2FkLnNldFByZWxvYWRTcHJpdGUodGhpcy5hc3NldCk7XHJcbiAgICB0aGlzLmxvYWQuaW1hZ2UoJ3Rlc3RzcHJpdGUnLCAnYXNzZXRzL3Rlc3QyLnBuZycpO1xyXG5cdHRoaXMubG9hZC5zcHJpdGVzaGVldCgnY29yZScsICdhc3NldHMvY29yZVNoZWV0LnBuZycsIDY0LCA2NCk7IFxyXG5cdHRoaXMubG9hZC5zcHJpdGVzaGVldCgndGhydXN0ZXInLCAnYXNzZXRzL3RocnVzdGVyU2hlZXQucG5nJywgNjQsIDY0KTtcclxuXHR0aGlzLmxvYWQuc3ByaXRlc2hlZXQoJ2d1bicsICdhc3NldHMvZ3VuU2hlZXQucG5nJywgNjQsIDY0KTtcclxuXHR0aGlzLmxvYWQuaW1hZ2UoJ3NoaWVsZCcsICdhc3NldHMvc2hpZWxkLnBuZycpO1xyXG5cdHRoaXMubG9hZC5pbWFnZSgnc29sYXJQYW5lbCcsICdhc3NldHMvc29sYXJQYW5lbC5wbmcnKTtcclxuXHR0aGlzLmxvYWQuaW1hZ2UoJ2FzdGVyb2lkJywgJ2Fzc2V0cy9hc3Rlcm9pZC5wbmcnKTtcclxuICAgdGhpcy5sb2FkLmF0bGFzSlNPTkhhc2goJ2Nvbm5lY3Rpb25zJywgJ2Fzc2V0cy9jb25uZWN0aW9ucy5wbmcnLCAnYXNzZXRzL2Nvbm5lY3Rpb25zLmpzb24nKTtcclxuXHR0aGlzLmxvYWQuaW1hZ2UoJ2VhcnRoTmlnaHQnLCAnYXNzZXRzL2JnX2VhcnRoTmlnaHRTbWFsbC5qcGcnKTtcclxuICAgIHRoaXMubG9hZC5waHlzaWNzKCdtb2R1bGVfcGh5c2ljcycsICdhc3NldHMvbW9kdWxlX3BoeXNpY3MuanNvbicpO1xyXG4gICB0aGlzLmxvYWQudGV4dCgnbGV2ZWxfb25lJywgJ2Fzc2V0cy9sZXZlbF9vbmUuanNvbicpO1xyXG4gIH0sXHJcblxyXG4gIGNyZWF0ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy5hc3NldC5jcm9wRW5hYmxlZCA9IGZhbHNlO1xyXG4gIH0sXHJcblxyXG4gIHVwZGF0ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKCEhdGhpcy5yZWFkeSkge1xyXG4gICAgICAvL3RoaXMuZ2FtZS5zdGF0ZS5zdGFydCgnTWVudScpO1xyXG4gICAgICB0aGlzLmdhbWUuc3RhdGUuc3RhcnQocGxheWVyU3RhdGUuY3VycmVudExldmVsKTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgb25Mb2FkQ29tcGxldGU6IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMucmVhZHkgPSB0cnVlO1xyXG4gIH1cclxufTtcclxuIiwidmFyIFNwbGFzaCA9IGZ1bmN0aW9uICgpIHtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU3BsYXNoO1xyXG5cclxuU3BsYXNoLnByb3RvdHlwZSA9IHtcclxuICBjcmVhdGU6IGZ1bmN0aW9uICgpIHtcclxuICB9XHJcbn07IiwiLypcclxuQ29sbGVjdGlvbiBvZiB1dGlsaXR5IGZ1bmN0aW9ucy5cclxuKi9cclxuXHJcbnZhciBVdGlscyA9IHtcclxuICAgIGNvbnRhaW5zT2JqZWN0OiBmdW5jdGlvbihvYmosIGxpc3QpIHtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAobGlzdFtpXSA9PT0gb2JqKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfSxcclxuICAgIGRpc3RhbmNlOiBmdW5jdGlvbih4MSwgeTEsIHgyLCB5Mikge1xyXG4gICAgICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyh4MSAtIHgyLCAyKSArIE1hdGgucG93KHkxIC0geTIsIDIpKTtcclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVXRpbHM7Il19
